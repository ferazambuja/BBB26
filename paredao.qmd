---
title: "BBB 26 â€” ParedÃ£o"
subtitle: "Acompanhe o paredÃ£o atual: formaÃ§Ã£o, votaÃ§Ã£o e anÃ¡lise de reaÃ§Ãµes"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

REACTION_SLUG_TO_LABEL = {
    'coracao': 'CoraÃ§Ã£o', 'planta': 'Planta', 'mala': 'Mala', 'biscoito': 'Biscoito',
    'cobra': 'Cobra', 'alvo': 'Alvo', 'vomito': 'VÃ´mito', 'mentiroso': 'Mentiroso',
    'coracao-partido': 'CoraÃ§Ã£o partido'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0,
    'CoraÃ§Ã£o partido': -0.5  # Mild negative (disappointment, not hostility)
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito', 'CoraÃ§Ã£o partido'}  # ğŸ’” = disappointment, not hostility
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}  # preenchido ao carregar dados

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Plotly Dark Theme Configuration (matches Bootswatch darkly)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PLOT_BG = '#303030'  # Darkly body background
PAPER_BG = '#303030'
GRID_COLOR = '#444444'
TEXT_COLOR = '#fff'

# Standard layout applied to ALL plots
import plotly.io as pio

pio.templates['bbb_dark'] = go.layout.Template(
    layout=go.Layout(
        paper_bgcolor=PAPER_BG,
        plot_bgcolor=PLOT_BG,
        font=dict(color=TEXT_COLOR, family='Lato, -apple-system, sans-serif', size=13),
        title=dict(font=dict(size=16), x=0.5, xanchor='center', y=0.95),
        margin=dict(l=70, r=30, t=70, b=60),
        xaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        yaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        legend=dict(
            bgcolor='rgba(0,0,0,0)',
            bordercolor='rgba(0,0,0,0)',
        ),
        colorway=['#00bc8c', '#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6'],
    )
)
pio.templates.default = 'bbb_dark'
```

```{python}
#| label: load-data

def load_snapshot(filepath):
    """Carrega um snapshot JSON (formato novo ou antigo)."""
    with open(filepath, encoding="utf-8") as f:
        data = json.load(f)
    if isinstance(data, dict) and "participants" in data:
        return data["participants"], data.get("_metadata")
    return data, None

def get_all_snapshots():
    """Retorna lista de (filepath, date_str) ordenada cronologicamente."""
    if not DATA_DIR.exists():
        return []
    snapshots = sorted(DATA_DIR.glob("*.json"))
    result = []
    for fp in snapshots:
        parts = fp.stem.split("_")
        date_str = parts[0]
        result.append((fp, date_str))
    return result

def parse_roles(roles_data):
    """Extrai nomes de roles (pode ser lista de strings ou lista de dicts)."""
    if not roles_data:
        return []
    result = []
    for r in roles_data:
        if isinstance(r, str):
            result.append(r)
        elif isinstance(r, dict):
            result.append(r.get('label', str(r)))
    return result

def build_reaction_matrix(participants):
    """ConstrÃ³i dicionÃ¡rio {(giver_name, receiver_name): reaction_label}."""
    matrix = {}
    for receiver in participants:
        rname = receiver['name']
        for rxn in receiver.get('characteristics', {}).get('receivedReactions', []):
            label = rxn.get('label', '')
            for giver in rxn.get('participants', []):
                gname = giver['name']
                matrix[(gname, rname)] = label
    return matrix

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

def avatar_html(name, size=24):
    """Generate HTML for participant avatar + name."""
    url = AVATARS.get(name, '')
    if url:
        return f'<img src="{url}" width="{size}" height="{size}" style="border-radius:50%; vertical-align:middle; margin-right:6px;" alt="{name}">{name}'
    return name

def avatar_img(name, size=24):
    """Generate just the avatar image HTML."""
    url = AVATARS.get(name, '')
    if url:
        return f'<img src="{url}" width="{size}" height="{size}" style="border-radius:50%;" alt="{name}" title="{name}">'
    return ''

# Enriquecer cada snapshot com label legÃ­vel e flag de sintÃ©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (Ãºltima do dia) â€” usada para anÃ¡lises de reaÃ§Ãµes
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)
```

```{python}
#| label: data-freshness
#| output: asis

# Data freshness shown in header area
print(f'<p class="text-muted small mb-0">ğŸ“… Dados de <strong>{latest["label"]}</strong> Â· {n_daily} dias de histÃ³rico</p>')
```

```{python}
#| label: paredao-results
#| output: asis

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  CARREGAR DADOS DE PAREDÃƒO DO JSON                          â•‘
# â•‘  Fonte: data/paredoes.json (atualizado manualmente)         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAREDOES_FILE = Path("data/paredoes.json")

def load_paredoes():
    """Carrega dados de paredÃ£o do arquivo JSON."""
    if not PAREDOES_FILE.exists():
        return []
    with open(PAREDOES_FILE, encoding="utf-8") as f:
        data = json.load(f)

    # Convert JSON structure to the format expected by the dashboard
    paredoes = []
    for p in data.get('paredoes', []):
        entry = {
            'numero': p['numero'],
            'status': p['status'],
            'data': p['data'],
            'titulo': p['titulo'],
            'lider': p.get('formacao', {}).get('lider'),
            'indicado_lider': p.get('formacao', {}).get('indicado_lider'),
            'motivo_lider': p.get('formacao', {}).get('motivo_lider'),
            'anjo': p.get('formacao', {}).get('anjo'),
            'anjo_autoimune': p.get('formacao', {}).get('anjo_autoimune'),
            'formacao': p.get('formacao', {}).get('resumo', ''),
            'dinamica': p.get('formacao', {}).get('dinamica'),
            'big_fone': p.get('formacao', {}).get('big_fone'),
            'contragolpe': p.get('formacao', {}).get('contragolpe'),
            'bate_volta': p.get('formacao', {}).get('bate_volta'),
            'votos_casa': p.get('votos_casa', {}),
            'fontes': p.get('fontes', []),
            'impedidos_votar': p.get('impedidos_votar', []),
            'votos_anulados': p.get('votos_anulados', []),
        }

        # Handle imunizado
        im = p.get('formacao', {}).get('imunizado')
        if im:
            entry['imunizado'] = im

        # Handle participantes based on status
        if p['status'] == 'finalizado' and p.get('resultado'):
            entry['participantes'] = []
            for ind in p.get('indicados_finais', []):
                part = {
                    'nome': ind['nome'],
                    'grupo': ind.get('grupo', MEMBER_OF.get(ind['nome'], '?')),
                    'como': ind.get('como', ''),
                }
                # Add vote data if available
                votos = p['resultado'].get('votos', {}).get(ind['nome'], {})
                if votos:
                    part['voto_unico'] = votos.get('voto_unico', 0)
                    part['voto_torcida'] = votos.get('voto_torcida', 0)
                    part['voto_total'] = votos.get('voto_total', 0)
                    part['resultado'] = 'ELIMINADA' if ind['nome'] == p['resultado'].get('eliminado') else 'Salva'
                entry['participantes'].append(part)
        else:
            entry['participantes'] = [
                {'nome': ind['nome'], 'grupo': ind.get('grupo', '?'), 'como': ind.get('como', '')}
                for ind in p.get('indicados_finais', [])
            ]
            entry['total_esperado'] = 3

        paredoes.append(entry)

    return paredoes

paredoes = load_paredoes()

# â”€â”€ Detectar paredÃ£o em andamento da API â”€â”€
# Se hÃ¡ participantes com role "ParedÃ£o" na API E nÃ£o temos um paredÃ£o 'em_andamento'
# no manual, mostramos um aviso para adicionar dados
def get_api_paredao_participants():
    """Retorna lista de nomes com role 'ParedÃ£o' no snapshot mais recente."""
    paredao_names = []
    for p in latest['participants']:
        roles = p.get('characteristics', {}).get('roles', [])
        role_labels = [r.get('label') if isinstance(r, dict) else r for r in roles]
        if 'ParedÃ£o' in role_labels:
            paredao_names.append(p['name'])
    return paredao_names

api_paredao = get_api_paredao_participants()

# â”€â”€ Merge API participants into manual paredÃ£o data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Auto-add participants from API that aren't in the manual list
def merge_api_paredao(paredao_entry, api_names):
    """Merge API-detected paredÃ£o participants into manual entry."""
    if not paredao_entry or paredao_entry.get('status') == 'finalizado':
        return  # Don't modify finalized paredÃµes

    participantes = paredao_entry.get('participantes', [])
    manual_names = {p['nome'] for p in participantes}

    # Add API participants not in manual list
    for name in api_names:
        if name not in manual_names:
            # Get grupo from latest snapshot
            grupo = 'Pipoca'
            for p in latest['participants']:
                if p['name'] == name:
                    grupo = p.get('characteristics', {}).get('memberOf', 'Pipoca')
                    break
            participantes.append({
                'nome': name,
                'grupo': grupo,
                'como': 'API'  # Will be updated manually later
            })

    paredao_entry['participantes'] = participantes

# Apply merge to the latest paredÃ£o if it's em_andamento
if paredoes and paredoes[-1].get('status') == 'em_andamento':
    merge_api_paredao(paredoes[-1], api_paredao)

# â”€â”€ VisualizaÃ§Ãµes do ParedÃ£o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXIBIÃ‡ÃƒO DO PAREDÃƒO â€” LÃ³gica flexÃ­vel que adapta ao dado disponÃ­vel
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# O cÃ³digo detecta automaticamente o estado baseado nos dados presentes:
# - Se tem 'resultado' nos participantes â†’ finalizado (mostra resultados)
# - Se nÃ£o tem 'resultado' â†’ em andamento (mostra formaÃ§Ã£o)
# - Se participantes < 3 â†’ formaÃ§Ã£o parcial (mostra "aguardando")
# - Se nÃ£o tem 'votos_casa' â†’ aguardando votaÃ§Ã£o da casa
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ultimo = paredoes[-1] if paredoes else None

if ultimo:
    is_finalizado = ultimo.get('status') == 'finalizado'
    participantes = ultimo.get('participantes', [])
    tem_resultado = any(p.get('resultado') for p in participantes)
    tem_votos_casa = bool(ultimo.get('votos_casa'))
    n_indicados = len(participantes)
    esperado_indicados = ultimo.get('total_esperado', 3)  # PadrÃ£o: 3 indicados

    if is_finalizado or tem_resultado:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO FINALIZADO â€” Resultado conhecido
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        pass  # Handled below in the else block

    else:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO EM ANDAMENTO â€” Ainda nÃ£o temos resultado
        # Adapta a exibiÃ§Ã£o baseado no que temos disponÃ­vel
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        # Determinar tÃ­tulo e mensagem baseado no estado
        if n_indicados < esperado_indicados:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” FORMAÃ‡ÃƒO EM ANDAMENTO"
            cor_titulo = '#3498db'  # Azul para formaÃ§Ã£o
            if n_indicados == 0:
                subtitulo = "Aguardando indicaÃ§Ãµes..."
            else:
                falta = esperado_indicados - n_indicados
                subtitulo = f"{n_indicados} indicado(s) confirmado(s). Aguardando mais {falta}..."
        else:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” EM VOTAÃ‡ÃƒO"
            cor_titulo = '#f39c12'  # Amarelo para votaÃ§Ã£o
            subtitulo = "VotaÃ§Ã£o popular em andamento. Resultado na terÃ§a-feira Ã  noite."

        # Check for auto-detected participants (need manual info)
        auto_detected = [p for p in participantes if p.get('como') == 'API']
        needs_manual_info = len(auto_detected) > 0 or not tem_votos_casa

        # Header
        print(f"""
<div style="text-align: center; margin-bottom: 2rem;">
<h2 style="color: {cor_titulo}; margin-bottom: 0.5rem;">ğŸ—³ï¸ {titulo}</h2>
<p style="color: #aaa; font-size: 1.1em;">{subtitulo}</p>
</div>
""")

        # Warning for incomplete data
        if needs_manual_info:
            missing = []
            if auto_detected:
                names = ', '.join([p['nome'] for p in auto_detected])
                missing.append(f"Como {names} foram indicados")
            if not tem_votos_casa and n_indicados >= esperado_indicados:
                missing.append("VotaÃ§Ã£o da casa")
            if not ultimo.get('lider'):
                missing.append("LÃ­der da semana")

            missing_text = ' Â· '.join(missing) if missing else "Detalhes da formaÃ§Ã£o"
            print(f"""
<div style="background: rgba(243, 156, 18, 0.15); border: 1px solid rgba(243, 156, 18, 0.4); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; text-align: center;">
<span style="color: #f39c12;">âš ï¸ <strong>Dados parciais</strong></span>
<p style="color: #ccc; margin: 0.5rem 0 0 0; font-size: 0.9em;">Participantes detectados da API. InformaÃ§Ãµes adicionais serÃ£o preenchidas manualmente.</p>
<p style="color: #888; margin: 0.3rem 0 0 0; font-size: 0.8em;">Pendente: {missing_text}</p>
</div>
""")

        # Cards dos indicados conhecidos
        if participantes:
            print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 2rem 0;">')
            for p in participantes:
                nome = p['nome']
                grupo = p.get('grupo', MEMBER_OF.get(nome, '?'))
                cor_grupo = GROUP_COLORS.get(grupo, '#666')
                avatar_url = AVATARS.get(nome, '')
                como_indicado = p.get('como', '')  # Ex: "DinÃ¢mica", "LÃ­der", "Casa", "API"
                is_auto = como_indicado == 'API'

                # Different border style for auto-detected
                border_style = f"2px dashed {cor_grupo}" if is_auto else f"2px solid {cor_grupo}"
                opacity = "0.85" if is_auto else "1"

                print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 180px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: {border_style}; opacity: {opacity};">')
                if avatar_url:
                    print(f'<img src="{avatar_url}" alt="{nome}" style="width: 120px; height: 120px; border-radius: 50%; object-fit: cover; border: 3px solid {cor_grupo}; margin-bottom: 1rem;">')
                print(f'<h4 style="margin: 0; color: #fff; font-size: 1.1em; text-align: center;">{nome}</h4>')
                print(f'<span style="display: inline-block; margin-top: 0.5rem; padding: 0.25rem 0.75rem; background: {cor_grupo}; color: #fff; border-radius: 12px; font-size: 0.85em;">{grupo}</span>')
                if como_indicado and not is_auto:
                    print(f'<div style="color: #aaa; font-size: 0.8em; margin-top: 0.5rem;">via {como_indicado}</div>')
                elif is_auto:
                    print(f'<div style="color: #f39c12; font-size: 0.75em; margin-top: 0.5rem;">â³ aguardando detalhes</div>')
                print('</div>')

            # Placeholder cards para indicados faltantes
            for i in range(esperado_indicados - n_indicados):
                print(f'<div style="background: linear-gradient(145deg, #2a2a2a, #1a1a1a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 180px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 2px dashed #555;">')
                print(f'<div style="width: 120px; height: 120px; border-radius: 50%; background: #333; margin: 0 auto 1rem auto; display: flex; align-items: center; justify-content: center; font-size: 2em; color: #555;">?</div>')
                print(f'<h4 style="margin: 0; color: #666; font-size: 1.1em; text-align: center;">Aguardando...</h4>')
                print('</div>')

            print('</div>')

        # Resumo da formaÃ§Ã£o (formato compacto)
        print("\n### ğŸ§© Resumo da FormaÃ§Ã£o\n")

        if ultimo.get('formacao'):
            prefixo = "Como foi formado" if n_indicados >= esperado_indicados else "Como estÃ¡ sendo formado"
            print(f"- **{prefixo}:** {ultimo['formacao']}")

        if ultimo.get('lider'):
            print(f"- **LÃ­der:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
            elif n_indicados < esperado_indicados:
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** *Aguardando...*")

        if ultimo.get('anjo'):
            auto = " (autoimune)" if ultimo.get('anjo_autoimune') else ""
            print(f"- **Anjo:** {ultimo['anjo']}{auto}")

        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"- **ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")

        if ultimo.get('dinamica'):
            dinamica = ultimo['dinamica']
            print(f"- **DinÃ¢mica:** {dinamica.get('nome', 'DinÃ¢mica especial')}")
            if dinamica.get('indicaram') and dinamica.get('indicado'):
                ind_list = ', '.join(dinamica['indicaram'])
                print(f"  - Indicaram: {ind_list} â†’ **{dinamica['indicado']}**")
            efeitos = dinamica.get('efeitos', {})
            if efeitos:
                for pessoa, efeito in efeitos.items():
                    print(f"  - {pessoa}: {efeito}")

        if ultimo.get('big_fone'):
            bf = ultimo['big_fone']
            print(f"- **Big Fone:** {bf.get('atendeu', 'â€”')} indicou {bf.get('indicou', 'â€”')}")

        if ultimo.get('contragolpe'):
            cg = ultimo['contragolpe']
            print(f"- **Contragolpe:** {cg.get('de', 'â€”')} â†’ {cg.get('para', 'â€”')}")

        if ultimo.get('bate_volta') is None and n_indicados >= esperado_indicados:
            print("- **Bate e Volta:** nÃ£o haverÃ¡")
        elif ultimo.get('bate_volta'):
            bv = ultimo['bate_volta']
            print(f"- **Bate e Volta:** {', '.join(bv.get('participantes', []))} â€” vencedor: {bv.get('vencedor', 'â€”')}")

        if ultimo.get('impedidos_votar'):
            print(f"- **Impedidos de votar:** {', '.join(ultimo['impedidos_votar'])}")

        if ultimo.get('votos_anulados'):
            print(f"- **Votos anulados:** {', '.join(ultimo['votos_anulados'])}")

        # VotaÃ§Ã£o da casa (formato mais legÃ­vel)
        if tem_votos_casa:
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"**Mais votado:** **{ranking[0][0]}** ({ranking[0][1]} votos)\n")

            print('<table class="table table-striped table-sm" style="max-width: 800px;">')
            print('<thead><tr><th>Alvo</th><th>Votos</th><th>Principais votantes</th></tr></thead>')
            print('<tbody>')
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                votantes_html = ' '.join([avatar_img(v, 24) for v in votantes[:6]])
                if len(votantes) > 6:
                    votantes_html += f' <span style="color:#888;">+{len(votantes) - 6}</span>'
                print(f'<tr><td>{avatar_html(alvo, 28)}</td><td style="text-align:center; font-weight:bold;">{n}</td><td>{votantes_html}</td></tr>')
            print('</tbody></table>\n')
        elif n_indicados >= esperado_indicados:
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"*Aguardando divulgaÃ§Ã£o da votaÃ§Ã£o da casa...*")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PAREDÃƒO FINALIZADO â€” Exibir se tem resultado
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if ultimo and (ultimo.get('status') == 'finalizado' or any(p.get('resultado') for p in ultimo.get('participantes', []))):
        df_p = pd.DataFrame(ultimo['participantes'])
        has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

        # â”€â”€ Visual: Cards com fotos e resultado â”€â”€
        print(f'<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 1.5rem 0 2rem 0;">')
        for _, row in df_p.iterrows():
            nome = row['nome']
            grupo = row.get('grupo', MEMBER_OF.get(nome, '?'))
            resultado = row.get('resultado', '')
            voto_total = row.get('voto_total', 0)
            avatar_url = AVATARS.get(nome, '')
            cor_grupo = GROUP_COLORS.get(grupo, '#666')

            # Card styling based on result
            if resultado == 'ELIMINADA':
                border_color = '#E6194B'
                badge_bg = '#E6194B'
                badge_text = 'ELIMINADO(A)'
                img_filter = 'grayscale(100%)'  # B&W for eliminated
            else:
                border_color = '#3CB44B'
                badge_bg = '#3CB44B'
                badge_text = 'SALVO(A)'
                img_filter = 'none'

            print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 3px solid {border_color};">')
            if avatar_url:
                print(f'<img src="{avatar_url}" alt="{nome}" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid {border_color}; margin-bottom: 0.75rem; filter: {img_filter};">')
            print(f'<h4 style="margin: 0 0 0.25rem 0; color: #fff; font-size: 1em; text-align: center;">{nome}</h4>')
            print(f'<span style="display: block; color: {cor_grupo}; font-size: 0.8em; margin-bottom: 0.5rem;">{grupo}</span>')
            print(f'<span style="display: inline-block; padding: 0.25rem 0.6rem; background: {badge_bg}; color: #fff; border-radius: 10px; font-size: 0.75em; font-weight: bold;">{badge_text}</span>')
            print(f'<div style="color: #fff; font-size: 1.3em; font-weight: bold; margin-top: 0.5rem;">{voto_total:.1f}%</div>')
            print('</div>')
        print('</div>')

        fig = go.Figure()

        if has_breakdown:
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_unico'],
                text=[f"{v:.1f}%" for v in df_p['voto_unico']],
                textposition='outside', name='Voto Ãšnico (70%)',
                marker_color='#1976D2',
                hovertemplate='%{x}: %{y:.1f}% (Voto Ãšnico)<extra></extra>',
            ))
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_torcida'],
                text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
                textposition='outside', name='Voto Torcida (30%)',
                marker_color='#FF9800',
                hovertemplate='%{x}: %{y:.1f}% (Voto Torcida)<extra></extra>',
            ))

        colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_total'],
            text=[f"{v:.1f}%" for v in df_p['voto_total']],
            textposition='outside', name='MÃ©dia Final',
            marker_color=colors_total,
            hovertemplate='%{x}: %{y:.1f}% (Final)<extra></extra>',
        ))

        fig.update_layout(
            title=dict(text=ultimo['titulo'], y=0.95, x=0.5, xanchor='center'),
            xaxis_title="", yaxis_title="Votos (%)",
            yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
            barmode='group',
            height=500,
            margin=dict(t=100),
            legend=dict(orientation='h', yanchor='bottom', y=1.08, xanchor='center', x=0.5),
            annotations=[dict(
                text="FÃ³rmula: (Voto Ãšnico Ã— 0,70) + (Voto Torcida Ã— 0,30) = MÃ©dia Final",
                xref="paper", yref="paper", x=0.5, y=-0.12, showarrow=False,
                font=dict(size=11, color='gray')
            )]
        )

        fig.show()

        # Resumo da formaÃ§Ã£o (finalizado)
        print("\n### ğŸ§© Resumo da FormaÃ§Ã£o\n")
        if ultimo.get('formacao'):
            print(f"- **Como foi formado:** {ultimo['formacao']}")
        if ultimo.get('lider'):
            print(f"- **LÃ­der:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
        if ultimo.get('anjo'):
            auto = " (autoimune)" if ultimo.get('anjo_autoimune') else ""
            print(f"- **Anjo:** {ultimo['anjo']}{auto}")
        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"- **ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")
        if ultimo.get('dinamica'):
            dinamica = ultimo['dinamica']
            print(f"- **DinÃ¢mica:** {dinamica.get('nome', 'DinÃ¢mica especial')}")
            if dinamica.get('indicaram') and dinamica.get('indicado'):
                ind_list = ', '.join(dinamica['indicaram'])
                print(f"  - Indicaram: {ind_list} â†’ **{dinamica['indicado']}**")
            efeitos = dinamica.get('efeitos', {})
            if efeitos:
                for pessoa, efeito in efeitos.items():
                    print(f"  - {pessoa}: {efeito}")
        if ultimo.get('big_fone'):
            bf = ultimo['big_fone']
            print(f"- **Big Fone:** {bf.get('atendeu', 'â€”')} indicou {bf.get('indicou', 'â€”')}")
        if ultimo.get('contragolpe'):
            cg = ultimo['contragolpe']
            print(f"- **Contragolpe:** {cg.get('de', 'â€”')} â†’ {cg.get('para', 'â€”')}")
        if ultimo.get('bate_volta'):
            bv = ultimo['bate_volta']
            print(f"- **Bate e Volta:** {', '.join(bv.get('participantes', []))} â€” vencedor: {bv.get('vencedor', 'â€”')}")

        # VotaÃ§Ã£o da casa (finalizado)
        if ultimo.get('votos_casa'):
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"**Mais votado:** **{ranking[0][0]}** ({ranking[0][1]} votos)\n")

            print('<table class="table table-striped table-sm" style="max-width: 800px;">')
            print('<thead><tr><th>Alvo</th><th>Votos</th><th>Principais votantes</th></tr></thead>')
            print('<tbody>')
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                votantes_html = ' '.join([avatar_img(v, 24) for v in votantes[:6]])
                if len(votantes) > 6:
                    votantes_html += f' <span style="color:#888;">+{len(votantes) - 6}</span>'
                print(f'<tr><td>{avatar_html(alvo, 28)}</td><td style="text-align:center; font-weight:bold;">{n}</td><td>{votantes_html}</td></tr>')
            print('</tbody></table>\n')

```

---

```{python}
#| label: paredao-quick-insights
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LEITURA RÃPIDA â€” QUERIDÃ”METRO DOS INDICADOS (HOJE + HISTÃ“RICO)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if ultimo and ultimo.get('participantes'):
    indicados = [p['nome'] for p in ultimo['participantes']]

    # Sentimento e negativas no dado do dia
    sent_hoje = {}
    neg_hoje = {}
    for p in latest['participants']:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        sent_hoje[name] = calc_sentiment(p)
        neg_hoje[name] = sum(
            r['amount'] for r in p.get('characteristics', {}).get('receivedReactions', [])
            if r['label'] != 'CoraÃ§Ã£o'
        )

    # Ranking do dia
    ranking_hoje = sorted(sent_hoje.items(), key=lambda x: x[1], reverse=True)
    rank_map = {name: i + 1 for i, (name, _) in enumerate(ranking_hoje)}

    # SÃ©rie histÃ³rica (diÃ¡ria)
    rows = []
    for snap in daily_snapshots:
        date = snap['date']
        for p in snap['participants']:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            rows.append({
                'date': date,
                'name': p['name'],
                'sentiment': calc_sentiment(p),
            })

    df_daily = pd.DataFrame(rows)

    # Top/bottom 5 por dia
    top5_counts = Counter()
    bottom5_counts = Counter()
    for date, g in df_daily.groupby('date'):
        g_sorted = g.sort_values('sentiment', ascending=False)
        top = g_sorted.head(5)['name']
        bottom = g_sorted.tail(5)['name']
        for n in top:
            top5_counts[n] += 1
        for n in bottom:
            bottom5_counts[n] += 1

    # FunÃ§Ãµes auxiliares
    def trend_3d(name):
        series = df_daily[df_daily['name'] == name].sort_values('date')['sentiment'].tolist()
        if len(series) < 2:
            return None
        last = series[-1]
        if len(series) >= 4:
            prev = sum(series[-4:-1]) / 3
        else:
            prev = sum(series[:-1]) / (len(series) - 1)
        return last - prev

    # Construir tabela resumida
    table_rows = []
    for nome in indicados:
        series = df_daily[df_daily['name'] == nome].sort_values('date')['sentiment'].tolist()
        total_days = len(series)
        neg_days = sum(1 for v in series if v < 0)
        pct_neg = (neg_days / total_days * 100) if total_days else 0

        delta = trend_3d(nome)
        if delta is None:
            delta_str = "â€”"
        elif delta >= 0.8:
            delta_str = f"â–² +{delta:.1f}"
        elif delta <= -0.8:
            delta_str = f"â–¼ {delta:.1f}"
        else:
            delta_str = f"â‰ˆ {delta:+.1f}"

        table_rows.append({
            'Indicado': nome,
            'Grupo': MEMBER_OF.get(nome, '?'),
            'Sentimento hoje': f"{sent_hoje.get(nome, 0):+.1f}",
            'Rank hoje': rank_map.get(nome, 'â€”'),
            'Î” 3 dias': delta_str,
            'Dias no Top 5': top5_counts.get(nome, 0),
            'Dias no Bottom 5': bottom5_counts.get(nome, 0),
            'Dias negativos': f"{neg_days}/{total_days} ({pct_neg:.0f}%)",
        })

    df_table = pd.DataFrame(table_rows)

    print("## ğŸ” Leitura RÃ¡pida dos Indicados\n")
    print("Como os emparedados estÃ£o no **queridÃ´metro de hoje** e no **histÃ³rico recente**.\n")

    # HTML table with avatars
    print('<table class="table table-striped table-hover" style="max-width: 100%;">')
    print('<thead><tr>')
    print('<th>Indicado</th><th>Grupo</th><th style="text-align:center;">Sentimento hoje</th>')
    print('<th style="text-align:center;">Rank</th><th style="text-align:center;">Î” 3 dias</th>')
    print('<th style="text-align:center;">Top 5</th><th style="text-align:center;">Bottom 5</th>')
    print('<th style="text-align:center;">Dias negativos</th>')
    print('</tr></thead><tbody>')
    for row in table_rows:
        nome = row['Indicado']
        grupo = row['Grupo']
        grupo_color = GROUP_COLORS.get(grupo, '#888')
        sent = row['Sentimento hoje']
        sent_val = float(sent.replace('+', ''))
        sent_color = '#4CAF50' if sent_val >= 0 else '#E6194B'
        delta = row['Î” 3 dias']
        delta_color = '#4CAF50' if 'â–²' in delta or '+' in delta else ('#E6194B' if 'â–¼' in delta else '#888')
        print(f'<tr>')
        print(f'<td>{avatar_html(nome, 28)}</td>')
        print(f'<td><span style="color:{grupo_color}; font-weight:500;">{grupo}</span></td>')
        print(f'<td style="text-align:center; color:{sent_color}; font-weight:bold;">{sent}</td>')
        print(f'<td style="text-align:center;">{row["Rank hoje"]}</td>')
        print(f'<td style="text-align:center; color:{delta_color};">{delta}</td>')
        print(f'<td style="text-align:center;">{row["Dias no Top 5"]}</td>')
        print(f'<td style="text-align:center;">{row["Dias no Bottom 5"]}</td>')
        print(f'<td style="text-align:center;">{row["Dias negativos"]}</td>')
        print(f'</tr>')
    print('</tbody></table>\n')

    # Destaques dos indicados
    if table_rows:
        worst_today = min(table_rows, key=lambda x: float(x['Sentimento hoje'].replace('+', '')))
        most_neg = max(table_rows, key=lambda x: neg_hoje.get(x['Indicado'], 0))
        most_bottom = max(table_rows, key=lambda x: x['Dias no Bottom 5'])
        most_top = max(table_rows, key=lambda x: x['Dias no Top 5'])

        deltas = {r['Indicado']: trend_3d(r['Indicado']) for r in table_rows}
        deltas = {k: v for k, v in deltas.items() if v is not None}

        print("\n### ğŸ“Š Destaques\n")
        print('<table class="table table-sm" style="max-width: 700px;">')
        print('<thead><tr><th>MÃ©trica</th><th>Participante</th><th style="text-align:center;">Valor</th></tr></thead>')
        print('<tbody>')
        print(f'<tr><td>ğŸ”´ <strong>Mais rejeitado hoje</strong></td><td>{avatar_html(worst_today["Indicado"], 24)}</td><td style="text-align:center;">{worst_today["Sentimento hoje"]} sentimento</td></tr>')
        print(f'<tr><td>ğŸ‘ <strong>Mais negativas recebidas</strong></td><td>{avatar_html(most_neg["Indicado"], 24)}</td><td style="text-align:center;">{neg_hoje.get(most_neg["Indicado"], 0)} reaÃ§Ãµes</td></tr>')
        if deltas:
            biggest_drop = min(deltas.items(), key=lambda x: x[1])
            biggest_rise = max(deltas.items(), key=lambda x: x[1])
            print(f'<tr><td>ğŸ“‰ <strong>Maior queda (3 dias)</strong></td><td>{avatar_html(biggest_drop[0], 24)}</td><td style="text-align:center;">{biggest_drop[1]:+.1f}</td></tr>')
            print(f'<tr><td>ğŸ“ˆ <strong>Maior recuperaÃ§Ã£o (3 dias)</strong></td><td>{avatar_html(biggest_rise[0], 24)}</td><td style="text-align:center;">{biggest_rise[1]:+.1f}</td></tr>')
        print(f'<tr><td>â¬‡ï¸ <strong>Mais dias no Bottom 5</strong></td><td>{avatar_html(most_bottom["Indicado"], 24)}</td><td style="text-align:center;">{most_bottom["Dias no Bottom 5"]} dias</td></tr>')
        if most_top['Dias no Top 5'] > 0:
            print(f'<tr><td>â¬†ï¸ <strong>Mais dias no Top 5</strong></td><td>{avatar_html(most_top["Indicado"], 24)}</td><td style="text-align:center;">{most_top["Dias no Top 5"]} dias</td></tr>')
        print('</tbody></table>')
```

```{python}
#| label: relationship-analysis
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANÃLISE ESTRATÃ‰GICA DE VOTOS â€” Baseada em Categorias de Relacionamento
#
# Classifica cada voto de acordo com o tipo de relacionamento entre votante e alvo:
#
# CATEGORIAS DE RELACIONAMENTO (votante â†’ alvo):
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1. INIMIGOS DECLARADOS (mÃºtuo) â€” Ambos se dÃ£o reaÃ§Ãµes negativas
#    â†’ Voto esperado. Ambos se dÃ£o reaÃ§Ãµes negativas (mesmo sem saber).
#
# 2. FALSOS AMIGOS â€” Votante deu â¤ï¸ ao alvo publicamente, mas votou contra
#    â†’ TraiÃ§Ã£o. O alvo achava que tinha um amigo, mas foi apunhalado.
#
# 3. PONTO CEGO â€” Alvo dÃ¡ â¤ï¸ ao votante, mas votante dÃ¡ negativo ao alvo
#    â†’ O votante ataca alguÃ©m que o considera amigo. Alvo nem percebe o perigo.
#
# 4. ALIADOS MÃšTUOS â€” Ambos se dÃ£o â¤ï¸
#    â†’ ProteÃ§Ã£o esperada. Se votou contra, Ã© traiÃ§Ã£o grave.
#
# 5. HOSTILIDADE UNILATERAL â€” Votante dÃ¡ negativo, alvo tambÃ©m (mas nÃ£o mÃºtuo)
#    â†’ Voto coerente com a reaÃ§Ã£o dada no queridÃ´metro.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ultimo_paredao = paredoes[-1] if paredoes else None
tem_votos = ultimo_paredao and ultimo_paredao.get('votos_casa')

if tem_votos and all_matrices:
    paredao = ultimo_paredao
    votos = paredao['votos_casa']
    paredao_date = paredao['data']

    # Encontrar snapshot mais prÃ³ximo Ã  data do paredÃ£o
    closest_idx = 0
    for i, snap in enumerate(snapshots):
        if snap['date'] <= paredao_date:
            closest_idx = i
    matrix = all_matrices[closest_idx]
    snap_participants = snapshots[closest_idx]['participants']

    # Calcular sentimento e negatividade por participante
    sent_by_name = {}
    neg_count_by_name = {}
    for p in snap_participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        sent_by_name[name] = calc_sentiment(p)
        neg_count_by_name[name] = sum(
            r['amount'] for r in p.get('characteristics', {}).get('receivedReactions', [])
            if r['label'] != 'CoraÃ§Ã£o'
        )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CLASSIFICAR CADA VOTO POR TIPO DE RELACIONAMENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def classify_relationship(votante, alvo, matrix):
        """Classifica o relacionamento entre votante e alvo."""
        rxn_votante_to_alvo = matrix.get((votante, alvo), '')
        rxn_alvo_to_votante = matrix.get((alvo, votante), '')

        votante_positive = rxn_votante_to_alvo in POSITIVE
        alvo_positive = rxn_alvo_to_votante in POSITIVE
        votante_negative = rxn_votante_to_alvo in (MILD_NEGATIVE | STRONG_NEGATIVE)
        alvo_negative = rxn_alvo_to_votante in (MILD_NEGATIVE | STRONG_NEGATIVE)
        votante_strong_neg = rxn_votante_to_alvo in STRONG_NEGATIVE

        # Mutual hearts = Aliados
        if votante_positive and alvo_positive:
            return 'aliados_mutuos', 'ğŸ’” TraiÃ§Ã£o de Aliado', '#9b59b6'

        # Votante gave heart but voted against = Falso Amigo
        if votante_positive and not alvo_positive:
            return 'falso_amigo', 'ğŸ­ Falso Amigo', '#E6194B'

        # Mutual negativity = Declared enemies
        if votante_negative and alvo_negative:
            return 'inimigos_declarados', 'âš”ï¸ Hostilidade MÃºtua', '#3CB44B'

        # Alvo gave heart but votante gave negative = Blind spot for alvo
        if votante_negative and alvo_positive:
            return 'ponto_cego', 'ğŸ¯ Ponto Cego do Alvo', '#f39c12'

        # One-sided hostility (votante hostile, alvo neutral/mild)
        if votante_strong_neg:
            return 'hostilidade_forte', 'ğŸ Hostilidade Forte', '#3CB44B'

        if votante_negative:
            return 'hostilidade_leve', 'ğŸŒ± Hostilidade Leve', '#FF9800'

        return 'neutro', 'â“ Neutro', '#999'

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ANÃLISE TEMPORAL â€” COMO OS RELACIONAMENTOS EVOLUÃRAM AO LONGO DO TEMPO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def analyze_relationship_history(votante, alvo, daily_matrices, daily_snapshots, paredao_date):
        """
        Analisa a evoluÃ§Ã£o do relacionamento entre votante e alvo ao longo do tempo.

        Retorna um dict com:
        - history: lista de (date, rxn_votante_to_alvo, rxn_alvo_to_votante)
        - pattern: 'sempre_amigos', 'sempre_inimigos', 'ex_amigos', 'recÃ©m_inimigos', 'instÃ¡vel'
        - days_as_friends: quantos dias foram amigos mÃºtuos
        - days_as_enemies: quantos dias foram inimigos
        - change_date: data da Ãºltima mudanÃ§a significativa (se houver)
        - narrative: texto descritivo da evoluÃ§Ã£o
        """
        history = []
        days_positive = 0
        days_negative = 0
        days_mutual_positive = 0
        last_positive_date = None
        first_negative_date = None
        change_date = None
        prev_was_positive = None

        for i, mat in enumerate(daily_matrices):
            snap_date = daily_snapshots[i]['date']
            if snap_date > paredao_date:
                break  # Don't look past paredÃ£o date

            rxn_v = mat.get((votante, alvo), '')
            rxn_a = mat.get((alvo, votante), '')

            if not rxn_v:  # Participant might not exist yet
                continue

            v_pos = rxn_v in POSITIVE
            a_pos = rxn_a in POSITIVE
            v_neg = rxn_v in (MILD_NEGATIVE | STRONG_NEGATIVE)

            history.append((snap_date, rxn_v, rxn_a))

            if v_pos:
                days_positive += 1
                last_positive_date = snap_date
                if prev_was_positive == False:  # Changed from negative to positive
                    change_date = snap_date
            elif v_neg:
                days_negative += 1
                if first_negative_date is None:
                    first_negative_date = snap_date
                if prev_was_positive == True:  # Changed from positive to negative
                    change_date = snap_date

            if v_pos and a_pos:
                days_mutual_positive += 1

            prev_was_positive = v_pos

        # Determine pattern
        total_days = len(history)
        if total_days == 0:
            return {
                'history': [], 'pattern': 'sem_dados', 'days_as_friends': 0,
                'days_as_enemies': 0, 'days_mutual_friends': 0,
                'change_date': None, 'narrative': 'Sem dados histÃ³ricos'
            }

        # Current state (last entry)
        current_positive = history[-1][1] in POSITIVE if history else False

        # Classify the pattern
        if days_positive == total_days:
            pattern = 'sempre_amigos'
            narrative = f"Sempre deu â¤ï¸ ({days_positive} dias). Amizade consistente."
        elif days_negative == total_days:
            pattern = 'sempre_inimigos'
            narrative = f"Inimigos desde o inÃ­cio ({days_negative} dias)."
        elif days_positive > 0 and not current_positive and change_date:
            # Was positive but changed to negative
            days_since_change = sum(1 for d, _, _ in history if d >= change_date)
            if days_since_change <= 2:
                pattern = 'recem_inimigos'
                narrative = f"Eram amigos por {days_positive} dias, mudou hÃ¡ {days_since_change} dia(s)!"
            else:
                pattern = 'ex_amigos'
                narrative = f"Foram amigos por {days_positive} dias, romperam em {change_date}."
        elif days_negative > 0 and current_positive and change_date:
            pattern = 'reconciliados'
            narrative = f"Foram inimigos, reconciliaram em {change_date}."
        else:
            pattern = 'instavel'
            narrative = f"Relacionamento instÃ¡vel: {days_positive}d â¤ï¸, {days_negative}d negativo."

        return {
            'history': history,
            'pattern': pattern,
            'days_as_friends': days_positive,
            'days_as_enemies': days_negative,
            'days_mutual_friends': days_mutual_positive,
            'change_date': change_date,
            'last_positive_date': last_positive_date,
            'first_negative_date': first_negative_date,
            'narrative': narrative,
            'total_days': total_days
        }

    # Analyze each vote
    vote_analysis = []
    relationship_counts = Counter()
    betrayals = []
    blind_spots = []
    expected_votes = []
    temporal_insights = []  # For temporal analysis

    for votante, alvo in votos.items():
        rel_type, rel_label, rel_color = classify_relationship(votante, alvo, matrix)
        rxn_to_alvo = matrix.get((votante, alvo), '')
        rxn_from_alvo = matrix.get((alvo, votante), '')

        # Add temporal analysis
        hist = analyze_relationship_history(votante, alvo, daily_matrices, daily_snapshots, paredao_date)

        entry = {
            'votante': votante,
            'alvo': alvo,
            'tipo': rel_type,
            'label': rel_label,
            'cor': rel_color,
            'emoji_dado': REACTION_EMOJI.get(rxn_to_alvo, '?'),
            'emoji_recebido': REACTION_EMOJI.get(rxn_from_alvo, '?'),
            'grupo_votante': MEMBER_OF.get(votante, '?'),
            'grupo_alvo': MEMBER_OF.get(alvo, '?'),
            # Temporal data
            'hist_pattern': hist['pattern'],
            'hist_narrative': hist['narrative'],
            'days_as_friends': hist['days_as_friends'],
            'days_as_enemies': hist['days_as_enemies'],
            'days_mutual_friends': hist['days_mutual_friends'],
            'change_date': hist['change_date'],
            'total_days': hist['total_days'],
        }
        vote_analysis.append(entry)
        relationship_counts[rel_type] += 1

        # Track notable temporal patterns
        if hist['pattern'] in ('ex_amigos', 'recem_inimigos'):
            temporal_insights.append({
                'votante': votante,
                'alvo': alvo,
                'pattern': hist['pattern'],
                'narrative': hist['narrative'],
                'days_as_friends': hist['days_as_friends'],
                'change_date': hist['change_date'],
            })

        # Track notable votes
        if rel_type in ('falso_amigo', 'aliados_mutuos'):
            betrayals.append(entry)
        elif rel_type == 'ponto_cego':
            blind_spots.append(entry)
        elif rel_type == 'inimigos_declarados':
            expected_votes.append(entry)

    total_votes = len(votos)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NARRATIVA PRINCIPAL â€” O QUE ACONTECEU NESTE PAREDÃƒO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"## ğŸ“– A HistÃ³ria do {paredao['numero']}Âº ParedÃ£o\n")

    # Count key statistics
    n_traicoes = len(betrayals)
    n_pontos_cegos = len(blind_spots)
    n_esperados = len(expected_votes)
    vote_counts = Counter(votos.values())
    mais_votado, n_votos_mais = vote_counts.most_common(1)[0]

    # Opening narrative
    if n_traicoes >= 3:
        print(f"Este paredÃ£o foi marcado por **traiÃ§Ãµes**. Nada menos que **{n_traicoes} votos** "
              f"vieram de pessoas que davam â¤ï¸ ao alvo no queridÃ´metro.\n")
    elif n_pontos_cegos >= 3:
        print(f"Este paredÃ£o revelou **pontos cegos** perigosos. **{n_pontos_cegos} participantes** "
              f"foram votados por pessoas que consideravam amigas.\n")
    elif n_esperados >= total_votes * 0.5:
        print(f"Este paredÃ£o seguiu a lÃ³gica das **hostilidades mÃºtuas**. "
              f"A maioria dos votos ({n_esperados}/{total_votes}) veio de quem jÃ¡ dava reaÃ§Ãµes negativas ao alvo.\n")
    else:
        print(f"Este paredÃ£o foi **estratÃ©gico**. Os votos nÃ£o seguiram simplesmente as emoÃ§Ãµes do queridÃ´metro.\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GRÃFICO: DISTRIBUIÃ‡ÃƒO DOS VOTOS POR TIPO DE RELACIONAMENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("### Anatomia dos Votos\n")
    print("Como os votos se distribuem por tipo de relacionamento?\n")

    rel_order = ['inimigos_declarados', 'hostilidade_forte', 'hostilidade_leve', 'ponto_cego', 'falso_amigo', 'aliados_mutuos', 'neutro']
    rel_labels = {
        'inimigos_declarados': 'âš”ï¸ Hostilidade MÃºtua',
        'hostilidade_forte': 'ğŸ Hostilidade Forte',
        'hostilidade_leve': 'ğŸŒ± Hostilidade Leve',
        'ponto_cego': 'ğŸ¯ Ponto Cego',
        'falso_amigo': 'ğŸ­ Falso Amigo',
        'aliados_mutuos': 'ğŸ’” TraiÃ§Ã£o de Aliado',
        'neutro': 'â“ Neutro'
    }
    rel_colors = {
        'inimigos_declarados': '#3CB44B',
        'hostilidade_forte': '#3CB44B',
        'hostilidade_leve': '#FF9800',
        'ponto_cego': '#f39c12',
        'falso_amigo': '#E6194B',
        'aliados_mutuos': '#9b59b6',
        'neutro': '#999'
    }
    rel_descriptions = {
        'inimigos_declarados': 'Ambos se dÃ£o reaÃ§Ãµes negativas. Voto coerente.',
        'hostilidade_forte': 'Votante deu reaÃ§Ã£o muito negativa (ğŸğŸ¯ğŸ¤®ğŸ¤¥). Voto coerente.',
        'hostilidade_leve': 'Votante deu reaÃ§Ã£o negativa leve (ğŸŒ±ğŸ’¼ğŸªğŸ’”). Voto coerente.',
        'ponto_cego': 'Alvo deu â¤ï¸ ao votante, mas votante o detesta. Alvo nÃ£o viu o perigo.',
        'falso_amigo': 'Votante deu â¤ï¸ ao alvo, mas votou contra. TraiÃ§Ã£o.',
        'aliados_mutuos': 'Ambos trocavam â¤ï¸. TraiÃ§Ã£o grave.',
        'neutro': 'Sem reaÃ§Ã£o clara entre os dois.'
    }

    fig = go.Figure()

    for rel in rel_order:
        count = relationship_counts.get(rel, 0)
        if count > 0:
            pct = count / total_votes * 100
            fig.add_trace(go.Bar(
                y=[rel_labels.get(rel, rel)],
                x=[count],
                orientation='h',
                marker_color=rel_colors.get(rel, '#999'),
                text=f"{count} ({pct:.0f}%)",
                textposition='auto',
                hovertemplate=f'{rel_labels.get(rel, rel)}: {count} votos<br>{rel_descriptions.get(rel, "")}<extra></extra>',
                showlegend=False
            ))

    fig.update_layout(
        title=f"DistribuiÃ§Ã£o dos Votos por Tipo de Relacionamento<br><sup>{paredao['numero']}Âº ParedÃ£o â€” Total: {total_votes} votos</sup>",
        height=350,
        xaxis_title="NÃºmero de votos",
        yaxis_title="",
        margin=dict(l=200, r=30, t=80, b=50),
    )

    fig.show()

    # Interpretation
    coerentes = relationship_counts.get('inimigos_declarados', 0) + relationship_counts.get('hostilidade_forte', 0) + relationship_counts.get('hostilidade_leve', 0)
    incoerentes = relationship_counts.get('falso_amigo', 0) + relationship_counts.get('aliados_mutuos', 0)
    pct_coerente = coerentes / total_votes * 100 if total_votes else 0
    pct_incoerente = incoerentes / total_votes * 100 if total_votes else 0

    print(f"\n**Resumo:**\n")
    print(f"âœ… **{coerentes} votos coerentes** ({pct_coerente:.0f}%)<br>")
    print(f"Votaram em quem davam reaÃ§Ã£o negativa no queridÃ´metro\n")
    print(f"âŒ **{incoerentes} votos incoerentes** ({pct_incoerente:.0f}%)<br>")
    print(f"Votaram em quem davam â¤ï¸ publicamente\n")
    print(f"ğŸ¯ **{n_pontos_cegos} pontos cegos**<br>")
    print(f"Alvos que confiavam no votante (davam â¤ï¸) mas eram odiados por ele\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # AS TRAIÃ‡Ã•ES â€” FALSOS AMIGOS E ALIADOS QUE TRAÃRAM
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Helper function for Portuguese gender agreement
    def genero(nome):
        """Retorna 'f' para feminino, 'm' para masculino baseado no nome."""
        nome_lower = nome.lower().split()[0]  # First name

        # Explicit female names
        female_names = {'maxiane', 'marciele', 'milena', 'gabriela', 'jordana', 'samira',
                       'chaiany', 'solange', 'sarah', 'sol'}
        if nome_lower in female_names:
            return 'f'

        # Common female name endings in Portuguese
        if nome_lower.endswith('a') and not nome_lower.endswith('ba'):  # Babu exception
            return 'f'

        return 'm'

    def artigo(nome, definido=True):
        """Retorna artigo definido/indefinido baseado no gÃªnero."""
        if genero(nome) == 'f':
            return 'a' if definido else 'uma'
        return 'o' if definido else 'um'

    if betrayals:
        print("### ğŸ­ As TraiÃ§Ãµes\n")
        print(f"**{len(betrayals)} voto(s)** de pessoas que davam â¤ï¸ ao alvo â€” contradiÃ§Ã£o entre reaÃ§Ã£o e voto.\n")

        betrayal_targets = Counter([b['alvo'] for b in betrayals])
        if betrayal_targets:
            top_target, top_count = betrayal_targets.most_common(1)[0]
            gen = genero(top_target)
            traido = "traÃ­da" if gen == 'f' else "traÃ­do"
            art = "a" if gen == 'f' else "o"
            print(f"**Principal alvo:** {top_target} ({top_count} voto[s]) â€” {art} mais {traido}\n")

        print('<table class="table table-sm table-striped">')
        print('<thead><tr><th>Votante</th><th>Alvo</th><th>O votante dava</th><th>O alvo retribuÃ­a?</th></tr></thead>')
        print('<tbody>')
        for b in betrayals:
            reciproca = f"Sim, {b['emoji_recebido']}" if b['tipo'] == 'aliados_mutuos' else "NÃ£o"
            print(f'<tr><td>{avatar_html(b["votante"], 28)}</td><td>{avatar_html(b["alvo"], 28)}</td><td>{b["emoji_dado"]}</td><td>{reciproca}</td></tr>')
        print('</tbody></table>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # OS PONTOS CEGOS â€” QUEM NÃƒO PERCEBEU O PERIGO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if blind_spots:
        print("### ğŸ¯ Os Pontos Cegos\n")
        print(f"**{len(blind_spots)} voto(s)** de inimigos disfarÃ§ados â€” a vÃ­tima dava â¤ï¸ sem saber que era odiada.\n")

        blind_spot_victims = Counter([bs['alvo'] for bs in blind_spots])
        if blind_spot_victims:
            top_victim, top_count = blind_spot_victims.most_common(1)[0]
            gen_v = genero(top_victim)
            ele_ela = "ela" if gen_v == 'f' else "ele"
            amigas_os = "amigas" if gen_v == 'f' else "amigos"
            print(f"**Maior risco:** {top_victim} â€” {top_count} pessoas que {ele_ela} achava {amigas_os} votaram contra\n")

        print('<table class="table table-sm table-striped">')
        print('<thead><tr><th>VÃ­tima</th><th>Votante</th><th>A vÃ­tima dava</th><th>O votante dava</th></tr></thead>')
        print('<tbody>')
        for bs in blind_spots:
            print(f'<tr><td>{avatar_html(bs["alvo"], 28)}</td><td>{avatar_html(bs["votante"], 28)}</td><td>{bs["emoji_recebido"]} (confiava)</td><td>{bs["emoji_dado"]} (hostil)</td></tr>')
        print('</tbody></table>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EVOLUÃ‡ÃƒO TEMPORAL â€” COMO OS RELACIONAMENTOS MUDARAM
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Count temporal patterns
    ex_amigos = [v for v in vote_analysis if v['hist_pattern'] == 'ex_amigos']
    recem_inimigos = [v for v in vote_analysis if v['hist_pattern'] == 'recem_inimigos']
    sempre_amigos = [v for v in vote_analysis if v['hist_pattern'] == 'sempre_amigos']
    sempre_inimigos = [v for v in vote_analysis if v['hist_pattern'] == 'sempre_inimigos']
    amigos_longa_data = [v for v in vote_analysis if v['days_mutual_friends'] >= 5]

    has_temporal_insights = len(ex_amigos) > 0 or len(recem_inimigos) > 0 or len(sempre_amigos) > 0

    if has_temporal_insights and n_daily >= 3:
        print("### â³ EvoluÃ§Ã£o dos Relacionamentos\n")
        print(f"Analisando o **histÃ³rico de {n_daily} dias** para entender se os votos seguem padrÃµes antigos ou mudanÃ§as recentes.\n")

        # Recent enemies (suspicious timing!)
        if recem_inimigos:
            print("#### ğŸš¨ MudanÃ§a de Ãšltima Hora\n")
            print(f"**{len(recem_inimigos)} voto(s)** de quem mudou de opiniÃ£o nos Ãºltimos 2 dias â€” timing suspeito!\n")
            print('<table class="table table-sm table-striped">')
            print('<thead><tr><th>Votante</th><th>Alvo</th><th>SituaÃ§Ã£o</th></tr></thead>')
            print('<tbody>')
            for v in recem_inimigos:
                print(f'<tr><td>{avatar_html(v["votante"], 28)}</td><td>{avatar_html(v["alvo"], 28)}</td><td><small>{v["hist_narrative"]}</small></td></tr>')
            print('</tbody></table>\n')

        # Ex-friends who became enemies
        if ex_amigos:
            print("#### ğŸ’” Ex-Amigos\n")
            print(f"**{len(ex_amigos)} voto(s)** de quem jÃ¡ deu â¤ï¸ no passado mas depois se afastou:\n")
            print('<table class="table table-sm table-striped">')
            print('<thead><tr><th>Votante</th><th>Alvo</th><th>SituaÃ§Ã£o</th></tr></thead>')
            print('<tbody>')
            for v in ex_amigos:
                print(f'<tr><td>{avatar_html(v["votante"], 28)}</td><td>{avatar_html(v["alvo"], 28)}</td><td><small>{v["hist_narrative"]}</small></td></tr>')
            print('</tbody></table>\n')

        # Voted against consistent friends (big betrayal)
        always_friends_voted = [v for v in sempre_amigos if v['tipo'] in ('falso_amigo', 'aliados_mutuos')]
        if always_friends_voted:
            print("#### ğŸ—¡ï¸ TraiÃ§Ã£o de Amizade de Longa Data\n")
            print(f"**{len(always_friends_voted)} voto(s)** contra quem sempre recebeu â¤ï¸ â€” traiÃ§Ã£o grave:\n")
            print('<table class="table table-sm table-striped">')
            print('<thead><tr><th>Votante</th><th>Alvo</th><th>Dias de amizade</th></tr></thead>')
            print('<tbody>')
            for v in always_friends_voted:
                print(f'<tr><td>{avatar_html(v["votante"], 28)}</td><td>{avatar_html(v["alvo"], 28)}</td><td>{v["days_as_friends"]} dias de â¤ï¸</td></tr>')
            print('</tbody></table>\n')

        # Long-time enemies (expected votes)
        if sempre_inimigos:
            long_enemies = [v for v in sempre_inimigos if v['days_as_enemies'] >= 5]
            if long_enemies:
                print("#### âš”ï¸ Inimigos de Longa Data\n")
                print(f"**{len(long_enemies)} voto(s)** de rivalidades que jÃ¡ duram â‰¥5 dias â€” votos esperados:\n")
                print('<table class="table table-sm table-striped">')
                print('<thead><tr><th>Votante</th><th>Alvo</th><th>Tempo de rivalidade</th></tr></thead>')
                print('<tbody>')
                for v in long_enemies[:8]:
                    print(f'<tr><td>{avatar_html(v["votante"], 28)}</td><td>{avatar_html(v["alvo"], 28)}</td><td>{v["days_as_enemies"]} dias</td></tr>')
                print('</tbody></table>\n')

        # Summary statistics
        pattern_counts = Counter([v['hist_pattern'] for v in vote_analysis])

        print("\n#### ğŸ“Š Resumo Temporal\n")
        print("Classifica cada voto pelo **histÃ³rico do relacionamento** entre votante e alvo:\n")
        print("| PadrÃ£o | Votos | O que significa |")
        print("|--------|-------|-----------------|")
        if pattern_counts.get('sempre_amigos', 0):
            print(f"| ğŸ’š **Sempre amigos** | {pattern_counts['sempre_amigos']} | Votante sempre deu â¤ï¸ ao alvo â€” voto inesperado |")
        if pattern_counts.get('sempre_inimigos', 0):
            print(f"| ğŸ’€ **Sempre inimigos** | {pattern_counts['sempre_inimigos']} | Votante nunca deu â¤ï¸ ao alvo â€” voto esperado |")
        if pattern_counts.get('ex_amigos', 0):
            print(f"| ğŸ’” **Ex-amigos** | {pattern_counts['ex_amigos']} | Davam â¤ï¸ no passado, hoje nÃ£o mais |")
        if pattern_counts.get('recem_inimigos', 0):
            print(f"| âš¡ **MudanÃ§a recente** | {pattern_counts['recem_inimigos']} | Mudou de opiniÃ£o nos Ãºltimos 2 dias |")
        if pattern_counts.get('instavel', 0):
            print(f"| ğŸ­ **InstÃ¡veis** | {pattern_counts['instavel']} | RelaÃ§Ã£o oscilou muito ao longo do jogo |")
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # O MAIS VOTADO â€” ANÃLISE APROFUNDADA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"### ğŸ“Š O Caso {mais_votado}\n")

    mv_votos_detalhes = [v for v in vote_analysis if v['alvo'] == mais_votado]
    mv_sentiment = sent_by_name.get(mais_votado, 0)
    mv_neg = neg_count_by_name.get(mais_votado, 0)

    # Classify the votes received
    mv_from_enemies = len([v for v in mv_votos_detalhes if v['tipo'] in ('inimigos_declarados', 'hostilidade_forte', 'hostilidade_leve')])
    mv_from_traitors = len([v for v in mv_votos_detalhes if v['tipo'] in ('falso_amigo', 'aliados_mutuos')])
    mv_from_blind = len([v for v in mv_votos_detalhes if v['tipo'] == 'ponto_cego'])

    gen_mv = genero(mais_votado)
    votado_a = "votada" if gen_mv == 'f' else "votado"
    print(f"**{mais_votado}** foi {artigo(mais_votado)} mais {votado_a} pela casa com **{n_votos_mais} votos**.\n")
    print(f"| MÃ©trica | Valor |")
    print(f"|---------|-------|")
    print(f"| Sentimento total recebido | {mv_sentiment:+.1f} |")
    print(f"| ReaÃ§Ãµes negativas recebidas | {mv_neg} |")
    print(f"| Votos de quem dava negativo | {mv_from_enemies} |")
    print(f"| Votos de \"amigos\" (traiÃ§Ã£o) | {mv_from_traitors} |")
    print(f"| Pontos cegos (votantes hostis) | {mv_from_blind} |\n")

    if mv_from_traitors > n_votos_mais / 2:
        apunhalado_a = "apunhalada" if gen_mv == 'f' else "apunhalado"
        print(f"> ğŸ’” **{mais_votado} foi {apunhalado_a} pelas costas.** "
              f"Mais da metade dos votos ({mv_from_traitors}/{n_votos_mais}) veio de pessoas "
              f"que lhe davam â¤ï¸ no queridÃ´metro.\n")
    elif mv_from_enemies == n_votos_mais:
        print(f"> âš”ï¸ **{mais_votado} era um alvo Ã³bvio.** "
              f"Todos os {n_votos_mais} votos vieram de quem jÃ¡ dava reaÃ§Ã£o negativa.\n")
    elif mv_from_blind >= 2:
        print(f"> ğŸ¯ **{mais_votado} nÃ£o percebia seus inimigos.** "
              f"Dava â¤ï¸ para {mv_from_blind} pessoas que {'a' if gen_mv == 'f' else 'o'} detestavam e votaram contra {'ela' if gen_mv == 'f' else 'ele'}.\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INDICAÃ‡ÃƒO DO LÃDER
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Handle both old format (formacao as string) and new format (formacao as dict)
    formacao = paredao.get('formacao', {})
    if isinstance(formacao, dict):
        lider = formacao.get('lider')
        indicado = formacao.get('indicado_lider')
    else:
        # Old format - try top-level fields
        lider = paredao.get('lider')
        indicado = paredao.get('indicado_lider')

    if lider and indicado:
        rxn_lider = matrix.get((lider, indicado), '')
        rxn_indicado = matrix.get((indicado, lider), '')

        print(f"### ğŸ‘‘ IndicaÃ§Ã£o do LÃ­der\n")
        print(f"**{lider}** indicou **{indicado}** ao paredÃ£o.\n")

        rel_type, rel_label, _ = classify_relationship(lider, indicado, matrix)
        emoji_lider = REACTION_EMOJI.get(rxn_lider, '?')
        emoji_indicado = REACTION_EMOJI.get(rxn_indicado, '?')

        print('<table class="table table-sm">')
        print('<thead><tr><th>De</th><th>Para</th><th>ReaÃ§Ã£o</th></tr></thead>')
        print('<tbody>')
        print(f'<tr><td>{avatar_html(lider, 28)}</td><td>{avatar_html(indicado, 28)}</td><td>{emoji_lider}</td></tr>')
        print(f'<tr><td>{avatar_html(indicado, 28)}</td><td>{avatar_html(lider, 28)}</td><td>{emoji_indicado}</td></tr>')
        print('</tbody></table>\n')

        if rel_type == 'aliados_mutuos':
            print(f"> ğŸ’” **IndicaÃ§Ã£o surpreendente!** {lider} e {indicado} trocavam â¤ï¸ mÃºtuos. "
                  f"A indicaÃ§Ã£o foi uma traiÃ§Ã£o de alianÃ§a.\n")
        elif rel_type == 'falso_amigo':
            print(f"> ğŸ­ **IndicaÃ§Ã£o contraditÃ³ria.** {lider} dava â¤ï¸ para {indicado} no queridÃ´metro. "
                  f"A indicaÃ§Ã£o contradiz a reaÃ§Ã£o dada no queridÃ´metro.\n")
        elif rel_type == 'inimigos_declarados':
            print(f"> âš”ï¸ **IndicaÃ§Ã£o coerente.** {lider} e {indicado} tÃªm hostilidade mÃºtua no queridÃ´metro. "
                  f"O voto estÃ¡ alinhado com a reaÃ§Ã£o.\n")
        elif rel_type == 'ponto_cego':
            print(f"> ğŸ¯ **{indicado} nÃ£o viu a indicaÃ§Ã£o chegando.** "
                  f"Dava â¤ï¸ para {lider}, mas {lider} jÃ¡ mostrava hostilidade.\n")
        else:
            print(f"> O relacionamento entre {lider} e {indicado} era {rel_label.lower()}.\n")

        # Historical analysis of leader's relationship with nominee
        if n_daily >= 2:
            hist_indicado = analyze_relationship_history(lider, indicado, daily_matrices, daily_snapshots, paredao_date)

            # Only show history section if we have data
            if hist_indicado['pattern'] != 'sem_dados':
                print(f"#### ğŸ“… HistÃ³rico: {lider} â†’ {indicado}\n")

                if hist_indicado['pattern'] == 'sempre_inimigos':
                    print(f"**{lider}** nunca deu â¤ï¸ para {indicado} â€” inimizade desde o inÃ­cio ({hist_indicado['days_as_enemies']} dias).\n")
                elif hist_indicado['pattern'] == 'sempre_amigos':
                    print(f"**{lider}** sempre deu â¤ï¸ para {indicado} ({hist_indicado['days_as_friends']} dias). "
                          f"A indicaÃ§Ã£o contradiz o histÃ³rico!\n")
                elif hist_indicado['pattern'] == 'ex_amigos':
                    print(f"**{lider}** deu â¤ï¸ por {hist_indicado['days_as_friends']} dias, "
                          f"mas mudou em **{hist_indicado['change_date']}**. "
                          f"Desde entÃ£o, sÃ£o {hist_indicado['days_as_enemies']} dias de hostilidade.\n")
                elif hist_indicado['pattern'] == 'recem_inimigos':
                    print(f"âš ï¸ **MudanÃ§a recente!** {lider} dava â¤ï¸ por {hist_indicado['days_as_friends']} dias, "
                          f"mas virou inimigo hÃ¡ poucos dias (em {hist_indicado['change_date']}).\n")
                elif hist_indicado['pattern'] == 'instavel':
                    print(f"Relacionamento instÃ¡vel: {hist_indicado['days_as_friends']} dias de â¤ï¸ "
                          f"vs {hist_indicado['days_as_enemies']} dias de hostilidade.\n")
            else:
                # No reaction data for this leader
                print(f"> â„¹ï¸ **{lider}** nÃ£o tem histÃ³rico de reaÃ§Ãµes no queridÃ´metro â€” anÃ¡lise indisponÃ­vel.\n")

        # Check if leader nominated their worst-rated person
        worst_for_leader = None
        worst_w = float('inf')
        second_worst = None
        second_worst_w = float('inf')
        for other in neg_count_by_name:
            if other == lider:
                continue
            w = SENTIMENT_WEIGHTS.get(matrix.get((lider, other), ''), 0)
            if w < worst_w:
                second_worst = worst_for_leader
                second_worst_w = worst_w
                worst_w = w
                worst_for_leader = other
            elif w < second_worst_w:
                second_worst_w = w
                second_worst = other

        # Compare with alternative target (usually the worst enemy)
        # Only show comparison if leader has reaction data
        if worst_for_leader and worst_for_leader != indicado and worst_w < 0:
            emoji_worst = REACTION_EMOJI.get(matrix.get((lider, worst_for_leader), ''), '?')
            emoji_worst_back = REACTION_EMOJI.get(matrix.get((worst_for_leader, lider), ''), '?')

            print(f"#### ğŸ”„ Por que nÃ£o {worst_for_leader}?\n")
            print(f"A pessoa que **{lider}** mais detesta Ã© **{worst_for_leader}** ({emoji_worst}), nÃ£o {indicado}.\n")

            # Compare history with the alternative
            if n_daily >= 2 and hist_indicado['pattern'] != 'sem_dados':
                hist_worst = analyze_relationship_history(lider, worst_for_leader, daily_matrices, daily_snapshots, paredao_date)

                print('<table class="table table-sm">')
                print(f'<thead><tr><th>ComparaÃ§Ã£o</th><th>{avatar_html(indicado, 24)}</th><th>{avatar_html(worst_for_leader, 24)}</th></tr></thead>')
                print('<tbody>')
                print(f'<tr><td>ReaÃ§Ã£o do lÃ­der</td><td>{emoji_lider}</td><td>{emoji_worst}</td></tr>')
                print(f'<tr><td>ReaÃ§Ã£o de volta</td><td>{emoji_indicado}</td><td>{emoji_worst_back}</td></tr>')
                print(f'<tr><td>Dias de â¤ï¸</td><td>{hist_indicado["days_as_friends"]}</td><td>{hist_worst["days_as_friends"]}</td></tr>')
                print(f'<tr><td>Dias de hostilidade</td><td>{hist_indicado["days_as_enemies"]}</td><td>{hist_worst["days_as_enemies"]}</td></tr>')
                print('</tbody></table>\n')

                # Strategic interpretation
                if hist_worst['days_as_enemies'] > hist_indicado['days_as_enemies']:
                    print(f"> ğŸ§  **Escolha estratÃ©gica.** {worst_for_leader} Ã© inimigo hÃ¡ mais tempo ({hist_worst['days_as_enemies']} dias), "
                          f"mas {lider} escolheu {indicado}. PossÃ­veis razÃµes: evitar votos da torcida de {worst_for_leader}, "
                          f"ou calcular que {indicado} seria mais votado pela casa.\n")
                elif hist_indicado['pattern'] == 'recem_inimigos':
                    print(f"> âš¡ **Timing suspeito.** {lider} mudou de opiniÃ£o sobre {indicado} recentemente. "
                          f"Pode ter sido uma estratÃ©gia de Ãºltima hora.\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TABELA COMPLETA DE VOTOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("### ğŸ“‹ Tabela Completa de Votos\n")

    # Pattern emoji mapping
    pattern_emoji = {
        'sempre_amigos': 'ğŸ’š',      # Always friends
        'sempre_inimigos': 'ğŸ’€',    # Always enemies
        'ex_amigos': 'ğŸ’”',          # Ex-friends
        'recem_inimigos': 'âš¡',     # Recent change
        'reconciliados': 'ğŸ¤',      # Reconciled
        'instavel': 'ğŸ­',           # Unstable
        'sem_dados': 'â“',          # No data
    }

    # HTML table with avatars
    print('<table class="table table-sm table-striped">')
    print('<thead><tr>')
    print('<th>Votante</th><th>Votou em</th><th>Deu</th><th>Recebeu</th><th>Tipo</th><th>HistÃ³rico</th>')
    print('</tr></thead>')
    print('<tbody>')
    for v in vote_analysis:
        hist = f"{pattern_emoji.get(v['hist_pattern'], '?')} {v['days_as_friends']}dâ¤ï¸"
        print(f'<tr>')
        print(f'<td>{avatar_html(v["votante"], 28)}</td>')
        print(f'<td>{avatar_html(v["alvo"], 28)}</td>')
        print(f'<td>{v["emoji_dado"]}</td>')
        print(f'<td>{v["emoji_recebido"]}</td>')
        print(f'<td><small>{v["label"]}</small></td>')
        print(f'<td><small>{hist}</small></td>')
        print(f'</tr>')
    print('</tbody></table>')

    print("\n**Legenda histÃ³rico:** ğŸ’š Sempre amigos | ğŸ’€ Sempre inimigos | ğŸ’” Ex-amigos | âš¡ MudanÃ§a recente | ğŸ­ InstÃ¡vel\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SCATTER PLOT: NEGATIVIDADE VS VOTOS RECEBIDOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("\n### ğŸ“ˆ ReaÃ§Ãµes Negativas vs Votos Recebidos\n")

    vote_counts_all = Counter(votos.values())
    scatter_data = []
    for name in set(list(vote_counts_all.keys()) + list(neg_count_by_name.keys())):
        if name in neg_count_by_name:
            scatter_data.append({
                'nome': name,
                'neg_recebidas': neg_count_by_name.get(name, 0),
                'votos_recebidos': vote_counts_all.get(name, 0),
                'grupo': MEMBER_OF.get(name, '?'),
            })

    df_scatter = pd.DataFrame(scatter_data)

    if len(df_scatter) > 2:
        corr_val = df_scatter['neg_recebidas'].corr(df_scatter['votos_recebidos'])

        fig = px.scatter(
            df_scatter, x='neg_recebidas', y='votos_recebidos',
            text='nome', color='grupo', color_discrete_map=GROUP_COLORS,
            title=f"Quem Ã© mais detestado recebe mais votos? (r = {corr_val:.2f})",
            labels={'neg_recebidas': 'ReaÃ§Ãµes negativas recebidas', 'votos_recebidos': 'Votos na casa'}
        )
        fig.update_traces(textposition='top center', textfont_size=9, marker_size=12)
        fig.update_layout(height=500)

        if df_scatter['neg_recebidas'].std() > 0:
            z = np.polyfit(df_scatter['neg_recebidas'], df_scatter['votos_recebidos'], 1)
            x_line = np.linspace(df_scatter['neg_recebidas'].min(), df_scatter['neg_recebidas'].max(), 50)
            fig.add_trace(go.Scatter(x=x_line, y=np.polyval(z, x_line), mode='lines',
                                     line=dict(dash='dash', color='gray'), name='TendÃªncia'))

        fig.show()

        if abs(corr_val) < 0.3:
            print(f"> **CorrelaÃ§Ã£o fraca (r = {corr_val:.2f}):** Ser odiado no queridÃ´metro "
                  f"**nÃ£o significa** ser votado. Os votos seguem lÃ³gica estratÃ©gica.\n")
        elif corr_val > 0.5:
            print(f"> **CorrelaÃ§Ã£o forte (r = {corr_val:.2f}):** Quem Ã© mais detestado "
                  f"**tende a ser mais votado**. O jogo estÃ¡ honesto.\n")
        else:
            print(f"> **CorrelaÃ§Ã£o moderada (r = {corr_val:.2f}):** Existe alguma relaÃ§Ã£o "
                  f"entre ser odiado e ser votado, mas outros fatores pesam.\n")

else:
    print("*Aguardando votaÃ§Ã£o da casa para anÃ¡lise estratÃ©gica.*")
```

---

::: {.callout-note title="ğŸ“š Ver mais" appearance="simple"}
Quer ver os paredÃµes anteriores? Acesse o **[Arquivo de ParedÃµes](paredoes.html)** com votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o.
:::

::: {.callout-caution title="â„¹ï¸ Sobre os dados" appearance="minimal" collapse="true"}
Os resultados do ParedÃ£o sÃ£o atualizados apÃ³s cada eliminaÃ§Ã£o com base em informaÃ§Ãµes oficiais (GShow, transmissÃ£o ao vivo). A anÃ¡lise de votos usa os dados do queridÃ´metro mais prÃ³ximos da data do paredÃ£o.
:::

::: {.callout-tip title="ğŸ§­ NavegaÃ§Ã£o"}
- [ğŸ“Š Painel](index.html) â€” Estado atual das reaÃ§Ãµes
- [ğŸ“… O Que Mudou](mudancas.html) â€” MudanÃ§as do dia anterior
- [ğŸ“ˆ TrajetÃ³ria](trajetoria.html) â€” EvoluÃ§Ã£o ao longo da temporada
- [ğŸ“š Arquivo](paredoes.html) â€” HistÃ³rico de paredÃµes
:::
