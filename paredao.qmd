---
title: "BBB 26 â€” ParedÃ£o"
subtitle: "Acompanhe o paredÃ£o atual: formaÃ§Ã£o, votaÃ§Ã£o e anÃ¡lise de reaÃ§Ãµes"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import plotly.graph_objects as go
from pathlib import Path
from collections import Counter

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    load_snapshots_full, build_reaction_matrix,
    load_reaction_matrices, deserialize_matrix,
    require_clean_manual_events, calc_sentiment, setup_bbb_dark_theme,
    load_paredoes_transformed,
    load_votalhada_polls, get_poll_for_paredao, calculate_poll_accuracy,
    calculate_precision_weights, predict_precision_weighted,
    genero, artigo, get_nominee_badge,
    make_poll_timeseries,
    avatar_html, avatar_img,
    REACTION_EMOJI, SENTIMENT_WEIGHTS,
    POSITIVE, MILD_NEGATIVE, STRONG_NEGATIVE, GROUP_COLORS,
    ANALYSIS_DESCRIPTIONS,
)

require_clean_manual_events()
setup_bbb_dark_theme()

```

```{python}
#| label: load-data

snapshots, MEMBER_OF, AVATARS, daily_snapshots, late_entrants = load_snapshots_full()

# Load precomputed matrices (with fallback to runtime computation)
_precomp = load_reaction_matrices()
if _precomp and "by_date" in _precomp:
    all_matrices = []
    for s in snapshots:
        date_key = s.get("date", "")
        if date_key in _precomp["by_date"]:
            all_matrices.append(deserialize_matrix(_precomp["by_date"][date_key]))
        else:
            all_matrices.append(build_reaction_matrix(s["participants"]))
else:
    all_matrices = [build_reaction_matrix(s["participants"]) for s in snapshots]

latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Daily matrices (matching daily_snapshots indices)
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i
_daily_indices = sorted(_by_date.values())
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)
```

```{python}
#| label: data-freshness
#| output: asis

# Data freshness shown in header area
print(f'<p class="text-muted small mb-0">ğŸ“… Dados de <strong>{latest["label"]}</strong> Â· {n_daily} dias de histÃ³rico</p>')
```

```{python}
#| label: paredao-results
#| output: asis

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  CARREGAR DADOS DE PAREDÃƒO DO JSON                          â•‘
# â•‘  Fonte: data/paredoes.json (atualizado manualmente)         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

paredoes = load_paredoes_transformed(member_of=MEMBER_OF)

# Aviso se faltar data_formacao
missing_formacao = [p for p in paredoes if p.get('status') == 'finalizado' and not p.get('data_formacao')]
if missing_formacao:
    print("::: {.callout-warning title=\"âš ï¸ data_formacao ausente\" appearance=\"minimal\"}")
    print("Alguns paredÃµes finalizados nÃ£o possuem `data_formacao`. A anÃ¡lise de coerÃªncia pode usar a data do paredÃ£o e ficar menos precisa.")
    print("Preencha `data_formacao` em `data/paredoes.json`.")
    print(":::\n")
# â”€â”€ Carregar dados de enquetes do Votalhada â”€â”€
polls_data = load_votalhada_polls()

# â”€â”€ Detectar paredÃ£o em andamento da API â”€â”€
# Se hÃ¡ participantes com role "ParedÃ£o" na API E nÃ£o temos um paredÃ£o 'em_andamento'
# no manual, mostramos um aviso para adicionar dados
def get_api_paredao_participants():
    """Retorna lista de nomes com role 'ParedÃ£o' no snapshot mais recente."""
    paredao_names = []
    for p in latest['participants']:
        roles = p.get('characteristics', {}).get('roles', [])
        role_labels = [r.get('label') if isinstance(r, dict) else r for r in roles]
        if 'ParedÃ£o' in role_labels:
            paredao_names.append(p['name'])
    return paredao_names

api_paredao = get_api_paredao_participants()

# â”€â”€ Merge API participants into manual paredÃ£o data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Auto-add participants from API that aren't in the manual list
def merge_api_paredao(paredao_entry, api_names):
    """Merge API-detected paredÃ£o participants into manual entry."""
    if not paredao_entry or paredao_entry.get('status') == 'finalizado':
        return  # Don't modify finalized paredÃµes

    participantes = paredao_entry.get('participantes', [])
    manual_names = {p['nome'] for p in participantes}

    # Add API participants not in manual list
    for name in api_names:
        if name not in manual_names:
            # Get grupo from latest snapshot
            grupo = 'Pipoca'
            for p in latest['participants']:
                if p['name'] == name:
                    grupo = p.get('characteristics', {}).get('memberOf', 'Pipoca')
                    break
            participantes.append({
                'nome': name,
                'grupo': grupo,
                'como': 'API'  # Will be updated manually later
            })

    paredao_entry['participantes'] = participantes

# Apply merge to the latest paredÃ£o if it's em_andamento
if paredoes and paredoes[-1].get('status') == 'em_andamento':
    merge_api_paredao(paredoes[-1], api_paredao)

# â”€â”€ VisualizaÃ§Ãµes do ParedÃ£o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXIBIÃ‡ÃƒO DO PAREDÃƒO â€” LÃ³gica flexÃ­vel que adapta ao dado disponÃ­vel
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# O cÃ³digo detecta automaticamente o estado baseado nos dados presentes:
# - Se tem 'resultado' nos participantes â†’ finalizado (mostra resultados)
# - Se nÃ£o tem 'resultado' â†’ em andamento (mostra formaÃ§Ã£o)
# - Se participantes < 3 â†’ formaÃ§Ã£o parcial (mostra "aguardando")
# - Se nÃ£o tem 'votos_casa' â†’ aguardando votaÃ§Ã£o da casa
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ultimo = paredoes[-1] if paredoes else None

if ultimo:
    is_finalizado = ultimo.get('status') == 'finalizado'
    participantes = ultimo.get('participantes', [])
    tem_resultado = any(p.get('resultado') for p in participantes)
    tem_votos_casa = bool(ultimo.get('votos_casa'))
    n_indicados = len(participantes)
    esperado_indicados = ultimo.get('total_esperado', 3)  # PadrÃ£o: 3 indicados

    if is_finalizado or tem_resultado:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO FINALIZADO â€” Resultado conhecido
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        pass  # Handled below in the else block

    else:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO EM ANDAMENTO â€” Ainda nÃ£o temos resultado
        # Adapta a exibiÃ§Ã£o baseado no que temos disponÃ­vel
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        # Determinar tÃ­tulo e mensagem baseado no estado
        if n_indicados < esperado_indicados:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” FORMAÃ‡ÃƒO EM ANDAMENTO"
            cor_titulo = '#3498db'  # Azul para formaÃ§Ã£o
            if n_indicados == 0:
                subtitulo = "Aguardando indicaÃ§Ãµes..."
            else:
                falta = esperado_indicados - n_indicados
                subtitulo = f"{n_indicados} indicado(s) confirmado(s). Aguardando mais {falta}..."
        else:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” EM VOTAÃ‡ÃƒO"
            cor_titulo = '#f39c12'  # Amarelo para votaÃ§Ã£o
            subtitulo = "VotaÃ§Ã£o popular em andamento. Resultado na terÃ§a-feira Ã  noite."

        # Check for auto-detected participants (need manual info)
        auto_detected = [p for p in participantes if p.get('como') == 'API']
        needs_manual_info = len(auto_detected) > 0 or not tem_votos_casa

        # Header
        print(f"""
<div class="tc" style="margin-bottom: 2rem;">
<h2 style="color: {cor_titulo}; margin-bottom: 0.5rem;">ğŸ—³ï¸ {titulo}</h2>
<p style="color: #aaa; font-size: 1.1em;">{subtitulo}</p>
</div>
""")

        # Warning for incomplete data
        if needs_manual_info:
            missing = []
            if auto_detected:
                names = ', '.join([p['nome'] for p in auto_detected])
                missing.append(f"Como {names} foram indicados")
            if not tem_votos_casa and n_indicados >= esperado_indicados:
                missing.append("VotaÃ§Ã£o da casa")
            if not ultimo.get('lider'):
                missing.append("LÃ­der da semana")

            missing_text = ' Â· '.join(missing) if missing else "Detalhes da formaÃ§Ã£o"
            print(f"""
<div class="tc" style="background: rgba(243, 156, 18, 0.15); border: 1px solid rgba(243, 156, 18, 0.4); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
<span style="color: #f39c12;">âš ï¸ <strong>Dados parciais</strong></span>
<p class="text-light" style="margin: 0.5rem 0 0 0; font-size: 0.9em;">Participantes detectados da API. InformaÃ§Ãµes adicionais serÃ£o preenchidas manualmente.</p>
<p class="text-muted" style="margin: 0.3rem 0 0 0; font-size: 0.8em;">Pendente: {missing_text}</p>
</div>
""")

        # Cards dos indicados conhecidos
        if participantes:
            print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 2rem 0;">')
            for p in participantes:
                nome = p['nome']
                grupo = p.get('grupo', MEMBER_OF.get(nome, '?'))
                cor_grupo = GROUP_COLORS.get(grupo, '#666')
                avatar_url = AVATARS.get(nome, '')
                como_indicado = p.get('como', '')  # Ex: "DinÃ¢mica", "LÃ­der", "Casa", "API"
                is_auto = como_indicado == 'API'

                # Different border style for auto-detected
                border_style = f"2px dashed {cor_grupo}" if is_auto else f"2px solid {cor_grupo}"
                opacity = "0.85" if is_auto else "1"

                print(f'<div class="nominee-card" style="border: {border_style}; opacity: {opacity};">')
                if avatar_url:
                    print(f'<img src="{avatar_url}" alt="{nome}" class="nominee-avatar" style="border: 3px solid {cor_grupo};">')
                print(f'<h4 class="tc" style="margin: 0; color: #fff; font-size: 1.1em;">{nome}</h4>')
                print(f'<span class="group-badge" style="background: {cor_grupo};">{grupo}</span>')
                if como_indicado and not is_auto:
                    print(f'<div style="color: #aaa; font-size: 0.8em; margin-top: 0.5rem;">via {como_indicado}</div>')
                elif is_auto:
                    print(f'<div style="color: #f39c12; font-size: 0.75em; margin-top: 0.5rem;">â³ aguardando detalhes</div>')
                print('</div>')

            # Placeholder cards para indicados faltantes
            for i in range(esperado_indicados - n_indicados):
                print(f'<div class="nominee-card-placeholder">')
                print(f'<div style="width: 120px; height: 120px; border-radius: 50%; background: #333; margin: 0 auto 1rem auto; display: flex; align-items: center; justify-content: center; font-size: 2em; color: #555;">?</div>')
                print(f'<h4 class="tc" style="margin: 0; color: #666; font-size: 1.1em;">Aguardando...</h4>')
                print('</div>')

            print('</div>')

        # â”€â”€ Setup duelo data (used by Consensus Analysis and Sincerinho later) â”€â”€
        _formacao_raw = ultimo.get('formacao_raw', {})
        _duelo = _formacao_raw.get('duelo_de_risco') if isinstance(_formacao_raw, dict) else None

        # Resumo da formaÃ§Ã£o (formato compacto)
        print("\n### ğŸ§© Resumo da FormaÃ§Ã£o\n")

        if ultimo.get('formacao'):
            prefixo = "Como foi formado" if n_indicados >= esperado_indicados else "Como estÃ¡ sendo formado"
            print(f"- **{prefixo}:** {ultimo['formacao']}")

        if ultimo.get('lider'):
            print(f"- **LÃ­der:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
            elif n_indicados < esperado_indicados:
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** *Aguardando...*")

        if ultimo.get('anjo'):
            auto = " (autoimune)" if ultimo.get('anjo_autoimune') else ""
            print(f"- **Anjo:** {ultimo['anjo']}{auto}")

        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"- **ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")

        if ultimo.get('dinamica'):
            dinamica = ultimo['dinamica']
            print(f"- **DinÃ¢mica:** {dinamica.get('nome', 'DinÃ¢mica especial')}")
            if dinamica.get('indicaram') and dinamica.get('indicado'):
                ind_list = ', '.join(dinamica['indicaram'])
                print(f"  - Indicaram: {ind_list} â†’ **{dinamica['indicado']}**")
            efeitos = dinamica.get('efeitos', {})
            if efeitos:
                for pessoa, efeito in efeitos.items():
                    print(f"  - {pessoa}: {efeito}")

        if ultimo.get('big_fone'):
            bf = ultimo['big_fone']
            print(f"- **Big Fone:** {bf.get('atendeu', 'â€”')} indicou {bf.get('indicou', 'â€”')}")

        if ultimo.get('contragolpe'):
            cg = ultimo['contragolpe']
            print(f"- **Contragolpe:** {cg.get('de', 'â€”')} â†’ {cg.get('para', 'â€”')}")

        if ultimo.get('bate_volta') is None and n_indicados >= esperado_indicados:
            print("- **Bate e Volta:** nÃ£o haverÃ¡")
        elif ultimo.get('bate_volta'):
            bv = ultimo['bate_volta']
            bv_w = bv.get('vencedores') or ([bv['vencedor']] if bv.get('vencedor') else [])
            label = 'vencedores' if len(bv_w) > 1 else 'vencedor'
            print(f"- **Bate e Volta:** {', '.join(bv.get('participantes', []))} â€” {label}: {', '.join(bv_w) if bv_w else 'â€”'}")

        if ultimo.get('impedidos_votar'):
            print(f"- **Impedidos de votar:** {', '.join(ultimo['impedidos_votar'])}")

        if ultimo.get('votos_anulados'):
            print(f"- **Votos anulados:** {', '.join(ultimo['votos_anulados'])}")

        # VotaÃ§Ã£o da casa (formato mais legÃ­vel)
        if tem_votos_casa:
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"**Mais votado:** **{ranking[0][0]}** ({ranking[0][1]} votos)\n")

            print('<table class="table table-striped" style="font-size: 1.05rem;">')
            print('<thead><tr><th>Alvo</th><th class="tc">Votos</th><th>Votantes</th></tr></thead>')
            print('<tbody>')
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                votantes_html = ' '.join([avatar_img(v, AVATARS, 42) for v in votantes])
                print(f'<tr><td>{avatar_html(alvo, AVATARS, 42)}</td><td class="tc" style="font-weight:bold; font-size:1.1em;">{n}</td><td>{votantes_html}</td></tr>')
            print('</tbody></table>\n')
        elif n_indicados >= esperado_indicados:
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"*Aguardando divulgaÃ§Ã£o da votaÃ§Ã£o da casa...*")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # COERÃŠNCIA SOCIAL (votos + indicaÃ§Ãµes vs queridÃ´metro)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if tem_votos_casa:
            # Get formation-date snapshot matrix
            _formacao_date = ultimo.get('data_formacao') or ultimo.get('data') or latest['date']
            _formacao_snap_idx = None
            for _fi, _fs in enumerate(daily_snapshots):
                if _fs['date'] <= _formacao_date:
                    _formacao_snap_idx = _fi
            if _formacao_snap_idx is not None:
                matrix_p = daily_matrices[_formacao_snap_idx]
                snap_participants_cs = daily_snapshots[_formacao_snap_idx]['participants']
            else:
                matrix_p = daily_matrices[-1]
                snap_participants_cs = daily_snapshots[-1]['participants']

            votos = ultimo['votos_casa']

            def alignment_from_reaction(label):
                if label in (MILD_NEGATIVE | STRONG_NEGATIVE):
                    return "alinhado"
                if label in POSITIVE:
                    return "contraditorio"
                return "neutro"

            vote_align = Counter()
            for votante, alvo in votos.items():
                label = matrix_p.get((votante, alvo), '')
                vote_align[alignment_from_reaction(label)] += 1

            # Indication coherence
            indicacoes_cs = []
            if ultimo.get('lider') and ultimo.get('indicado_lider'):
                indicacoes_cs.append(('LÃ­der', ultimo.get('lider'), ultimo.get('indicado_lider')))
            if ultimo.get('big_fone'):
                bf = ultimo.get('big_fone')
                if bf.get('atendeu') and bf.get('indicou'):
                    indicacoes_cs.append(('Big Fone', bf.get('atendeu'), bf.get('indicou')))
            if ultimo.get('contragolpe'):
                cg = ultimo.get('contragolpe')
                if cg.get('de') and cg.get('para'):
                    indicacoes_cs.append(('Contragolpe', cg.get('de'), cg.get('para')))
            if ultimo.get('dinamica'):
                din = ultimo.get('dinamica')
                indicados_din = din.get('indicaram') or []
                alvo_din = din.get('indicado')
                for ator in indicados_din:
                    indicacoes_cs.append((din.get('nome', 'DinÃ¢mica'), ator, alvo_din))

            ind_align = Counter()
            for origem, ator, alvo in indicacoes_cs:
                label = matrix_p.get((ator, alvo), '')
                ind_align[alignment_from_reaction(label)] += 1

            total_votes_cs = max(1, len(votos))
            aligned_pct = vote_align["alinhado"] / total_votes_cs * 100
            contrad_pct = vote_align["contraditorio"] / total_votes_cs * 100

            print("\n### ğŸ§­ CoerÃªncia Social\n")
            print(f'<p style="font-size:0.98rem;">Votos: <strong>{aligned_pct:.0f}% alinhados</strong> vs <strong>{contrad_pct:.0f}% contraditÃ³rios</strong> com o queridÃ´metro da formaÃ§Ã£o.</p>')
            if indicacoes_cs:
                total_ind = len(indicacoes_cs)
                print(f'<p style="font-size:0.95rem;">IndicaÃ§Ãµes pÃºblicas coerentes: {ind_align["alinhado"]}/{total_ind}.</p>')

            # Badge vs realidade (contradiÃ§Ãµes)
            active_names_cs = [p['name'] for p in snap_participants_cs if not p.get('characteristics', {}).get('eliminated')]
            false_friends = {}
            for name in active_names_cs:
                ff = 0
                for other in active_names_cs:
                    if other == name:
                        continue
                    my = matrix_p.get((name, other), '')
                    their = matrix_p.get((other, name), '')
                    if my in POSITIVE and their and their not in POSITIVE:
                        ff += 1
                false_friends[name] = ff

            # Ineligible for house votes (already indicated)
            ineligible_cs = set()
            indicacoes_count = Counter()
            if ultimo.get('indicado_lider'):
                ineligible_cs.add(ultimo.get('indicado_lider'))
                indicacoes_count[ultimo.get('indicado_lider')] += 1
            if ultimo.get('big_fone'):
                bf = ultimo.get('big_fone')
                if bf.get('indicou'):
                    ineligible_cs.add(bf.get('indicou'))
                    indicacoes_count[bf.get('indicou')] += 1
            if ultimo.get('contragolpe'):
                cg = ultimo.get('contragolpe')
                if cg.get('para'):
                    ineligible_cs.add(cg.get('para'))
                    indicacoes_count[cg.get('para')] += 1
            if ultimo.get('dinamica'):
                din = ultimo.get('dinamica')
                alvo_din = din.get('indicado')
                if alvo_din:
                    ineligible_cs.add(alvo_din)
                    indicacoes_count[alvo_din] += 1
            if ultimo.get('imunizado'):
                im = ultimo.get('imunizado')
                if im.get('quem'):
                    ineligible_cs.add(im.get('quem'))

            vuln_no_votes = []
            prot_with_votes = []
            badge_details = {}  # name -> {ff_count, ff_names, voters}
            for name in active_names_cs:
                votes_count = sum(1 for v, a in votos.items() if a == name)
                voters_for = [v for v, a in votos.items() if a == name]
                ff = false_friends.get(name, 0)
                # Find who the false friends are (give â¤ï¸ but receive negative)
                ff_names = []
                for other in active_names_cs:
                    if other == name:
                        continue
                    my = matrix_p.get((name, other), '')
                    their = matrix_p.get((other, name), '')
                    if my in POSITIVE and their and their not in POSITIVE:
                        ff_names.append((other, REACTION_EMOJI.get(their, their)))
                badge_details[name] = {'ff_count': ff, 'ff_names': ff_names, 'voters': voters_for}

                if ff >= 5:
                    vuln = 'ğŸ”´ MUITO VULNERÃVEL'
                elif ff >= 3:
                    vuln = 'ğŸŸ  VULNERÃVEL'
                elif ff >= 1:
                    vuln = 'ğŸŸ¡ ATENÃ‡ÃƒO'
                else:
                    vuln = 'ğŸŸ¢ PROTEGIDO'

                eligible = name not in ineligible_cs
                if votes_count == 0 and indicacoes_count.get(name, 0) == 0 and eligible and vuln in ['ğŸŸ  VULNERÃVEL', 'ğŸ”´ MUITO VULNERÃVEL']:
                    vuln_no_votes.append((name, vuln, votes_count))
                if votes_count >= 3 and eligible and vuln in ['ğŸŸ¢ PROTEGIDO', 'ğŸŸ¡ ATENÃ‡ÃƒO']:
                    prot_with_votes.append((name, vuln, votes_count))

            if vuln_no_votes or prot_with_votes:
                print('<div style="margin-top:0.8rem; padding:0.8rem; border-radius:8px; background:rgba(255,255,255,0.03);">')
                print('<p style="font-size:0.95rem; margin-bottom:0.6rem;"><strong>ğŸ” ContradiÃ§Ãµes â€” Badge vs Realidade</strong></p>')
                print('<p class="text-muted" style="font-size:0.82rem; margin-bottom:0.8rem;">O badge mede <em>quantas pessoas dÃ£o â¤ï¸ a alguÃ©m que as rejeita</em> (\"amigos falsos\"). VulnerÃ¡vel = muitos amigos falsos (alvos fÃ¡ceis). Comparamos com os votos reais para ver se a previsÃ£o se confirmou.</p>')
                if vuln_no_votes:
                    print('<div style="margin-bottom:0.8rem; padding:0.6rem; border-left:3px solid #2ecc71; background:rgba(46,204,113,0.05); border-radius:0 6px 6px 0;">')
                    print('<p style="font-size:0.9rem; margin-bottom:0.4rem;"><strong>âœ… VulnerÃ¡veis que escaparam</strong> <span class="text-muted" style="font-size:0.8rem;">â€” tinham alvos nas costas, mas ninguÃ©m votou neles</span></p>')
                    for name, vuln, votes_count in vuln_no_votes:
                        det = badge_details[name]
                        ff_list = det['ff_names']
                        print(f'<div style="margin:0.4rem 0; padding:0.4rem 0.6rem; background:rgba(255,255,255,0.03); border-radius:6px;">')
                        print(f'<p style="margin:0;">{avatar_html(name, AVATARS, size=28)} <strong>{name}</strong> â€” <span style="color:#e67e22;">{vuln}</span> Â· 0 votos</p>')
                        if ff_list:
                            ff_str = ', '.join(f'{avatar_img(n, AVATARS, size=20)} {n} {emoji}' for n, emoji in ff_list[:5])
                            print(f'<p style="margin:0.2rem 0 0 0; font-size:0.82rem; color:#aaa;">DÃ¡ â¤ï¸ a quem o rejeita: {ff_str}</p>')
                        print(f'<p style="margin:0.2rem 0 0 0; font-size:0.82rem; color:#2ecc71;">â†’ Apesar de {det["ff_count"]} \"amigo(s) falso(s)\", ninguÃ©m escolheu {name.split()[0]} como alvo na votaÃ§Ã£o.</p>')
                        print('</div>')
                    print('</div>')
                if prot_with_votes:
                    print('<div style="padding:0.6rem; border-left:3px solid #e74c3c; background:rgba(231,76,60,0.05); border-radius:0 6px 6px 0;">')
                    print('<p style="font-size:0.9rem; margin-bottom:0.4rem;"><strong>âš ï¸ Protegidos que foram alvo</strong> <span class="text-muted" style="font-size:0.8rem;">â€” poucos inimigos no queridÃ´metro, mas muitos votos (voto de bloco)</span></p>')
                    for name, vuln, votes_count in prot_with_votes:
                        det = badge_details[name]
                        voters = det['voters']
                        total_eligible = len(votos)
                        pct = votes_count / total_eligible * 100 if total_eligible > 0 else 0
                        print(f'<div style="margin:0.4rem 0; padding:0.4rem 0.6rem; background:rgba(255,255,255,0.03); border-radius:6px;">')
                        print(f'<p style="margin:0;">{avatar_html(name, AVATARS, size=28)} <strong>{name}</strong> â€” <span style="color:#f1c40f;">{vuln}</span> Â· <strong>{votes_count} votos</strong> ({pct:.0f}%)</p>')
                        if det['ff_count'] == 0:
                            print(f'<p style="margin:0.2rem 0 0 0; font-size:0.82rem; color:#aaa;">Nenhum \"amigo falso\" no queridÃ´metro â€” ninguÃ©m que dÃ¡ â¤ï¸ recebe negativo de volta.</p>')
                        else:
                            print(f'<p style="margin:0.2rem 0 0 0; font-size:0.82rem; color:#aaa;">Apenas {det["ff_count"]} \"amigo(s) falso(s)\" â€” baixa hostilidade no queridÃ´metro.</p>')
                        if voters:
                            voter_str = ', '.join(f'{avatar_img(v, AVATARS, size=20)} {v}' for v in sorted(voters)[:8])
                            print(f'<p style="margin:0.2rem 0 0 0; font-size:0.82rem; color:#aaa;">Votaram em {name.split()[0]}: {voter_str}</p>')
                        print(f'<p style="margin:0.2rem 0 0 0; font-size:0.82rem; color:#e74c3c;">â†’ A votaÃ§Ã£o contra {name.split()[0]} nÃ£o veio do queridÃ´metro â€” sugere <strong>articulaÃ§Ã£o de grupo</strong> ou alvo estratÃ©gico.</p>')
                        print('</div>')
                    print('</div>')
                print('</div>')

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # BLOCOS DE VOTAÃ‡ÃƒO (visual)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if tem_votos_casa:
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()

            if len(ranking) >= 2:
                print("\n### ğŸ›ï¸ Blocos de VotaÃ§Ã£o\n")

                # Build bloc data
                blocs = []
                for alvo, n_votos in ranking:
                    votantes = sorted([v for v, a in votos.items() if a == alvo])
                    blocs.append({'alvo': alvo, 'n': n_votos, 'votantes': votantes})

                # Narrative
                if len(ranking) == 2:
                    print(f'A casa se dividiu em dois blocos claros: **{blocs[0]["n"]}** votaram em **{blocs[0]["alvo"]}**, **{blocs[1]["n"]}** votaram em **{blocs[1]["alvo"]}**.\n')
                else:
                    parts_bloc = [f'{b["n"]} em {b["alvo"]}' for b in blocs]
                    print(f'DivisÃ£o da casa: {", ".join(parts_bloc)}.\n')

                # Side-by-side visual boxes
                print('<div style="display:flex; flex-wrap:wrap; gap:1.5rem; justify-content:center; margin:1rem 0;">')
                for bloc in blocs:
                    alvo = bloc['alvo']
                    n_bl = bloc['n']
                    votantes = bloc['votantes']
                    cor_alvo = GROUP_COLORS.get(MEMBER_OF.get(alvo, '?'), '#888')
                    print(f'<div style="background:linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)); border:2px solid {cor_alvo}; border-radius:12px; padding:1rem; min-width:200px; flex:1; max-width:400px;">')
                    print(f'<div class="tc" style="margin-bottom:0.8rem;">')
                    print(f'{avatar_img(alvo, AVATARS, 48)}')
                    print(f'<div style="color:#fff; font-weight:bold; font-size:1.05em; margin-top:0.3rem;">{alvo}</div>')
                    print(f'<div style="color:{cor_alvo}; font-size:1.3em; font-weight:bold;">{n_bl} votos</div>')
                    print(f'</div>')
                    # Voter avatars with group colors
                    print(f'<div style="display:flex; flex-wrap:wrap; gap:0.4rem; justify-content:center;">')
                    for vot in votantes:
                        vot_grupo = MEMBER_OF.get(vot, '?')
                        vot_cor = GROUP_COLORS.get(vot_grupo, '#888')
                        print(f'<div class="tc">')
                        av_url = AVATARS.get(vot, '')
                        if av_url:
                            print(f'<img src="{av_url}" style="width:36px; height:36px; border-radius:50%; border:2px solid {vot_cor};" alt="{vot}" title="{vot}">')
                        else:
                            print(f'<div style="width:36px; height:36px; border-radius:50%; background:{vot_cor}; display:flex; align-items:center; justify-content:center; font-size:0.7em; color:#fff;">{vot[:2]}</div>')
                        print(f'<div style="font-size:0.6em; color:#aaa; max-width:50px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">{vot.split()[0]}</div>')
                        print(f'</div>')
                    print(f'</div>')
                    print(f'</div>')
                print('</div>')

                # Sincerinho cross-reference
                _formacao_raw_blocs = ultimo.get('formacao_raw', {})
                _duelo_blocs = _formacao_raw_blocs.get('duelo_de_risco') if isinstance(_formacao_raw_blocs, dict) else None
                if _duelo_blocs and _duelo_blocs.get('escolhas'):
                    _escolhas_blocs = _duelo_blocs['escolhas']
                    # Count how many voters in each bloc also targeted the same person in Sincerinho
                    for bloc in blocs:
                        alvo_bloc = bloc['alvo']
                        votantes_bloc = bloc['votantes']
                        sinc_match = sum(1 for v in votantes_bloc if v in _escolhas_blocs and _escolhas_blocs[v]['alvo'] == alvo_bloc)
                        if sinc_match > 0:
                            print(f'<p style="color:#aaa; font-size:0.88em; margin:0.5rem 0;">ğŸ”— {sinc_match} dos {len(votantes_bloc)} votantes em {alvo_bloc} tambÃ©m o escolheram no Sincerinho.</p>')
                    # Broader alignment: did voters target nominees from the SAME bloc?
                    _sinc_vote_aligned = 0
                    _sinc_total = 0
                    for votante in votos:
                        if votante in _escolhas_blocs:
                            _sinc_total += 1
                            sinc_target = _escolhas_blocs[votante]['alvo']
                            vote_target = votos[votante]
                            # Aligned = Sincerinho target is in the same "enemy" direction
                            if sinc_target == vote_target:
                                _sinc_vote_aligned += 1
                    if _sinc_total > 0 and _sinc_vote_aligned > 0:
                        print(f'<p style="color:#aaa; font-size:0.88em; margin:0.3rem 0;">ğŸ“Š {_sinc_vote_aligned}/{_sinc_total} participantes votaram no mesmo nome que escolheram no Sincerinho.</p>')
                    elif _sinc_total > 0 and _sinc_vote_aligned == 0:
                        print(f'<p style="color:#aaa; font-size:0.88em; margin:0.3rem 0;">ğŸ“Š Nenhum participante votou no mesmo nome que escolheu no Sincerinho â€” os alvos divergiram completamente.</p>')

                print()

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # RANKING DE SENTIMENTO (formaÃ§Ã£o)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if True:  # Always show when data available
            _formacao_date_sent = ultimo.get('data_formacao') or ultimo.get('data') or latest['date'] if ultimo else latest['date']
            _snap_sent_idx = None
            for _si, _ss in enumerate(daily_snapshots):
                if _ss['date'] <= _formacao_date_sent:
                    _snap_sent_idx = _si
            if _snap_sent_idx is not None:
                _snap_sent = daily_snapshots[_snap_sent_idx]
                _snap_sent_participants = _snap_sent['participants']
            else:
                _snap_sent = daily_snapshots[-1]
                _snap_sent_participants = _snap_sent['participants']

            sentiment_data = []
            nominee_names = {p['nome'] for p in ultimo.get('participantes', [])} if ultimo else set()
            for p in _snap_sent_participants:
                if p.get('characteristics', {}).get('eliminated'):
                    continue
                name = p['name']
                score = calc_sentiment(p)
                member_of = p.get('characteristics', {}).get('memberOf', '?')
                sentiment_data.append({'name': name, 'score': score, 'memberOf': member_of, 'is_nominee': name in nominee_names})

            if sentiment_data:
                df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

                print(f"\n### ğŸ“Š Ranking de Sentimento ({_snap_sent['date']})\n")

                fig_sent = go.Figure()
                fig_sent.add_trace(go.Bar(
                    y=df_sent['name'],
                    x=df_sent['score'],
                    orientation='h',
                    marker_color=[GROUP_COLORS.get(m, '#999') for m in df_sent['memberOf']],
                    text=[f"<b>{s:+.1f}</b>" if is_n else f"{s:+.1f}" for s, is_n in zip(df_sent['score'], df_sent['is_nominee'])],
                    textposition='outside',
                    hovertemplate='%{y}: %{x:+.1f}<extra></extra>',
                ))

                # Highlight nominees on y-axis
                fig_sent.update_layout(
                    xaxis_title="Score",
                    yaxis_title="",
                    height=max(400, len(df_sent) * 22),
                    margin=dict(l=120, t=30),
                    shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                                 line=dict(color='red', dash='dash', width=1))],
                )

                # Bold nominee names on y-axis
                tick_labels = []
                for _, row in df_sent.iterrows():
                    if row['is_nominee']:
                        tick_labels.append(f"<b>âš ï¸ {row['name']}</b>")
                    else:
                        tick_labels.append(row['name'])
                fig_sent.update_yaxes(
                    ticktext=tick_labels,
                    tickvals=list(df_sent['name']),
                )

                fig_sent.show()
                print()

        # â”€â”€ Enquetes do Votalhada (em andamento) â”€â”€
        poll = get_poll_for_paredao(polls_data, ultimo['numero'])
        if poll:
            participantes_poll = poll.get('participantes', [])
            consolidado = poll.get('consolidado', {})
            plataformas = poll.get('plataformas', {})

            print("\n## ğŸ“Š PrevisÃ£o das Enquetes\n")
            print(f'<p class="text-muted small">Dados agregados de <a href="https://votalhada.blogspot.com/" target="_blank">Votalhada</a> â€” coleta em {poll.get("data_coleta", "?")[:10]} {poll.get("data_coleta", "?")[11:16] if len(poll.get("data_coleta", "")) > 11 else ""}</p>\n')

            # Compute precision model prediction
            _prec = calculate_precision_weights(polls_data)
            _model_pred = predict_precision_weighted(poll, _prec) if _prec.get('sufficient') else None

            # Side-by-side prediction cards
            print(f'<div style="display:flex; flex-wrap:wrap; gap:1rem; margin-bottom:1.5rem;">')
            # Votalhada card
            _consol_elim = consolidado.get("predicao_eliminado", "â€”")
            _consol_pct = consolidado.get(_consol_elim, 0)
            print(f'<div style="flex:1; min-width:220px; border:2px solid #9b59b6; border-radius:12px; padding:1rem; background:rgba(155,89,182,0.1);">')
            print(f'<div style="font-size:0.8em; color:#9b59b6; font-weight:bold; margin-bottom:0.3rem;">ğŸ“Š VOTALHADA (CONSOLIDADO)</div>')
            print(f'<div style="font-size:1.3em; font-weight:bold;">{_consol_elim}</div>')
            print(f'<div class="text-muted">com {_consol_pct:.1f}% dos votos</div>')
            print(f'</div>')
            # Model card
            if _model_pred:
                _model_elim = _model_pred['predicao_eliminado']
                _model_pct = _model_pred['prediction'].get(_model_elim, 0)
                _agree = 'âœ… Concordam' if _model_elim == _consol_elim else 'âš ï¸ Divergem'
                print(f'<div style="flex:1; min-width:220px; border:2px solid #00bc8c; border-radius:12px; padding:1rem; background:rgba(0,188,140,0.1);">')
                print(f'<div style="font-size:0.8em; color:#00bc8c; font-weight:bold; margin-bottom:0.3rem;">ğŸ¯ MODELO PONDERADO</div>')
                print(f'<div style="font-size:1.3em; font-weight:bold;">{_model_elim}</div>')
                print(f'<div class="text-muted">com {_model_pct:.1f}% dos votos</div>')
                print(f'<div class="text-muted" style="margin-top:0.5rem; font-size:0.8em;">{_agree}</div>')
                print(f'</div>')
            print(f'</div>\n')

            # Platform breakdown table
            print('<table class="table table-striped" style="max-width: 100%; font-size: 1rem;">')
            print('<thead><tr><th>Plataforma</th>')
            for nome in participantes_poll:
                avatar = avatar_img(nome, AVATARS, 28)
                print(f'<th class="tc">{avatar}</th>')
            print('<th class="tc text-muted">Votos</th>')
            print('</tr></thead><tbody>')

            platform_order = ['sites', 'youtube', 'twitter', 'instagram']
            platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

            for plat in platform_order:
                if plat in plataformas:
                    pdata = plataformas[plat]
                    votos = pdata.get('votos', 0)
                    votos_str = f"{votos:,.0f}".replace(',', '.')
                    print(f'<tr><td>{platform_names.get(plat, plat)}</td>')
                    for nome in participantes_poll:
                        val = pdata.get(nome, 0)
                        is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                        style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                        print(f'<td class="tc" style="{style}">{val:.1f}%</td>')
                    print(f'<td class="tc text-muted" style="font-size:0.9em;">{votos_str}</td>')
                    print('</tr>')

            # Consolidado row
            total_votos = consolidado.get('total_votos', 0)
            total_str = f"{total_votos:,.0f}".replace(',', '.')
            print(f'<tr style="background:rgba(155,89,182,0.2);"><td style="font-weight:bold;">ğŸ“Š Consolidado</td>')
            for nome in participantes_poll:
                val = consolidado.get(nome, 0)
                is_max = val == max(consolidado.get(n, 0) for n in participantes_poll)
                style = 'font-weight:bold; color:#9b59b6;' if is_max else 'font-weight:bold;'
                print(f'<td class="tc" style="{style}">{val:.1f}%</td>')
            print(f'<td class="tc text-muted" style="font-size:0.9em;">{total_str}</td>')
            print('</tr>')

            # Model row
            if _model_pred:
                print(f'<tr style="background:rgba(0,188,140,0.2);"><td style="font-weight:bold;">ğŸ¯ Modelo Ponderado</td>')
                for nome in participantes_poll:
                    val = _model_pred['prediction'].get(nome, 0)
                    is_max = val == max(_model_pred['prediction'].get(n, 0) for n in participantes_poll)
                    style = 'font-weight:bold; color:#00bc8c;' if is_max else 'font-weight:bold;'
                    print(f'<td class="tc" style="{style}">{val:.1f}%</td>')
                print(f'<td class="tc text-muted" style="font-size:0.8em;">ponderado</td>')
                print('</tr>')

            print('</tbody></table>')

            # Weight breakdown note (expandable)
            if _model_pred:
                _wu = _model_pred['weights_used']
                _plat_labels = {'sites': 'Sites', 'youtube': 'YouTube', 'twitter': 'Twitter', 'instagram': 'Instagram'}
                _weight_parts = [f'{_plat_labels.get(p,p)} {w*100:.0f}%' for p, w in sorted(_wu.items(), key=lambda x: -x[1])]
                _rmse_info = _prec.get('rmse', {})
                print(f'<details style="margin-top:0.5rem; font-size:0.85em;">')
                print(f'<summary class="text-muted" style="cursor:pointer;">â„¹ï¸ Pesos do modelo: {" Â· ".join(_weight_parts)}</summary>')
                print(f'<div style="padding:0.8rem; margin-top:0.3rem; background:rgba(0,188,140,0.05); border-radius:8px; color:#aaa; font-size:0.95em;">')
                print(f'<p style="margin:0 0 0.5rem 0;"><strong>Por que esses pesos?</strong> O Votalhada pondera pelo volume de votos â€” Sites recebem ~70% do peso porque tÃªm os maiores veÃ­culos (UOL Splash, CNN). Mas Sites sÃ£o a plataforma <strong>menos precisa</strong> (RMSE {_rmse_info.get("sites", "?"):.1f} p.p.) porque sobre-representam fanbases organizadas.</p>')
                print(f'<p style="margin:0 0 0.5rem 0;"><strong>Nosso modelo</strong> usa o inverso do RMSEÂ² (peso = 1/RMSEÂ²). Plataformas mais precisas recebem exponencialmente mais peso:</p>')
                print(f'<table style="font-size:0.9em; margin:0.3rem 0;">')
                print(f'<tr><th>Plataforma</th><th class="tc">RMSE</th><th class="tc">Votalhada</th><th class="tc">Modelo</th></tr>')
                _vol_approx = {'twitter': 5, 'instagram': 14, 'youtube': 11, 'sites': 70}
                for p, w in sorted(_wu.items(), key=lambda x: -x[1]):
                    rmse_val = _rmse_info.get(p, 0)
                    print(f'<tr><td>{_plat_labels.get(p,p)}</td><td class="tc">{rmse_val:.1f} p.p.</td><td class="tc">{_vol_approx.get(p,0)}%</td><td class="tc" style="font-weight:bold;">{w*100:.0f}%</td></tr>')
                print(f'</table>')
                print(f'<p style="margin:0.5rem 0 0 0;">Validado com leave-one-out (erro cai de 9,8 â†’ 4,3 p.p.). Pesos recalculados a cada paredÃ£o finalizado.</p>')
                print(f'</div></details>')
            print()

            # Time series chart (em_andamento)
            if poll.get('serie_temporal'):
                fig_ts = make_poll_timeseries(poll)
                if fig_ts:
                    fig_ts.show()

        # â”€â”€ Duelo de Risco â€” Consensus Analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if _duelo and _duelo.get('indicado_consenso') and _duelo.get('resultado') == 'nos_indicamos':
            _consenso_target = _duelo['indicado_consenso']
            _sorteado = _duelo['sorteado']
            _oponente = _duelo['oponente']
            _duelo_date = _duelo.get('data_duelo', '')
            _resultado_detail = _duelo.get('resultado_detail', '')

            # Load relations scores for pre-duel analysis
            _dr_rel_path = Path("data/derived/relations_scores.json")
            _dr_relations = json.loads(_dr_rel_path.read_text(encoding="utf-8")) if _dr_rel_path.exists() else {}
            _dr_pairs = _dr_relations.get("pairs_daily", {})
            _dr_edges = _dr_relations.get("edges", [])

            # Load roles for VIP list
            _dr_rd = json.loads(Path("data/derived/roles_daily.json").read_text(encoding="utf-8"))
            _dr_rd_daily = _dr_rd.get("daily", [])
            _dr_rd_latest = _dr_rd_daily[-1] if _dr_rd_daily else {}
            _dr_vip = _dr_rd_latest.get("vip", [])
            _dr_lider = _dr_rd_latest.get("roles", {}).get("LÃ­der", [])
            _dr_lider_name = _dr_lider[0] if _dr_lider else None

            # Active participants
            _dr_pix = json.loads(Path("data/derived/participants_index.json").read_text(encoding="utf-8"))
            _dr_pix_list = _dr_pix.get("participants", _dr_pix) if isinstance(_dr_pix, dict) else _dr_pix
            _dr_active = {p["name"] for p in _dr_pix_list if p.get("active", True)}

            # Find indicaÃ§Ã£o edges to subtract (only for the consensus target on duelo date)
            _dr_ind_weight = {}
            for _e in _dr_edges:
                if (_e.get('event_type') == 'indicacao' and _e.get('target') == _consenso_target
                        and _e.get('date') == _duelo_date):
                    _dr_ind_weight[_e['actor']] = _e.get('weight', 0)

            # Build pre-duel scores for sorteado and oponente
            def _get_pre_duel_scores(actor_name):
                """Get scores toward all active targets, subtracting indicaÃ§Ã£o edge if present."""
                actor_scores = _dr_pairs.get(actor_name, {})
                result = {}
                for target, entry in actor_scores.items():
                    if target not in _dr_active or target == actor_name:
                        continue
                    # Skip LÃ­der and the two duelists as targets
                    if target == _dr_lider_name or target == _sorteado or target == _oponente:
                        continue
                    score = entry.get("score", 0)
                    comps = dict(entry.get("components", {}))
                    q_score = comps.get("queridometro", 0)
                    # Subtract indicaÃ§Ã£o edge for consensus target
                    if target == _consenso_target and actor_name in _dr_ind_weight:
                        ind_w = _dr_ind_weight[actor_name]
                        score -= ind_w
                        pe = comps.get("power_event", 0) - ind_w
                        if abs(pe) < 0.001:
                            del comps["power_event"]
                        else:
                            comps["power_event"] = pe
                    result[target] = {"score": score, "components": comps, "queridometro": q_score}
                return result

            _sol_pre = _get_pre_duel_scores(_sorteado)
            _jf_pre = _get_pre_duel_scores(_oponente)

            # All eligible targets (union of both sets)
            _dr_eligible = sorted(set(_sol_pre.keys()) | set(_jf_pre.keys()))

            print(f"\n## ğŸ² AnÃ¡lise â€” Por que {_consenso_target}?\n")
            print(f'<p style="color:#aaa; font-size:0.9em;">AnÃ¡lise dos dados que embasaram a decisÃ£o conjunta no Duelo de Risco. Scores prÃ©-duelo (excluindo a indicaÃ§Ã£o).</p>\n')

            # â”€â”€ 1. Result Card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            _av_s = AVATARS.get(_sorteado, '')
            _av_o = AVATARS.get(_oponente, '')
            _av_t = AVATARS.get(_consenso_target, '')
            print('<div style="display:flex; flex-wrap:wrap; align-items:center; justify-content:center; gap:1.2rem; margin:1.5rem 0; padding:1.5rem; background:linear-gradient(145deg,#1a1a2e,#16213e); border-radius:16px; border:1px solid rgba(155,89,182,0.4);">')
            # Sorteado
            print(f'<div class="tc">')
            if _av_s:
                print(f'<img src="{_av_s}" style="width:72px; height:72px; border-radius:50%; border:3px solid #9b59b6;" alt="{_sorteado}">')
            print(f'<div style="color:#fff; font-weight:bold; margin-top:0.4rem;">{_sorteado}</div>')
            print(f'<div style="background:#9b59b6; color:#fff; padding:0.15rem 0.6rem; border-radius:8px; font-size:0.75em; margin-top:0.2rem;">ğŸ² Sorteada</div>')
            print('</div>')
            # Arrow + decision
            print(f'<div class="tc" style="color:#9b59b6; font-size:1.5em; padding:0 0.5rem;">')
            print(f'<div>ğŸ¤</div>')
            print(f'<div style="font-size:0.5em; color:#ccc;">NÃ³s indicamos</div>')
            print(f'</div>')
            # Oponente
            print(f'<div class="tc">')
            if _av_o:
                print(f'<img src="{_av_o}" style="width:72px; height:72px; border-radius:50%; border:3px solid #e67e22;" alt="{_oponente}">')
            print(f'<div style="color:#fff; font-weight:bold; margin-top:0.4rem;">{_oponente}</div>')
            print(f'<div style="background:#e67e22; color:#fff; padding:0.15rem 0.6rem; border-radius:8px; font-size:0.75em; margin-top:0.2rem;">âš”ï¸ Oponente</div>')
            print('</div>')
            # Arrow to target
            print(f'<div class="tc" style="color:#e74c3c; font-size:1.5em; padding:0 0.5rem;">â†’</div>')
            # Target
            print(f'<div class="tc">')
            if _av_t:
                print(f'<img src="{_av_t}" style="width:72px; height:72px; border-radius:50%; border:3px solid #e74c3c;" alt="{_consenso_target}">')
            print(f'<div style="color:#fff; font-weight:bold; margin-top:0.4rem;">{_consenso_target}</div>')
            print(f'<div style="background:#e74c3c; color:#fff; padding:0.15rem 0.6rem; border-radius:8px; font-size:0.75em; margin-top:0.2rem;">ğŸ“Œ Emparedada</div>')
            print('</div>')
            print('</div>')
            if _resultado_detail:
                print(f'<p class="tc" style="color:#aaa; font-size:0.85em; margin-top:0.5rem;">{_resultado_detail}</p>\n')

            # â”€â”€ 1b. Game theory â€” possible outcomes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            _escolha_s = _duelo.get(f'escolha_{_sorteado.lower().replace(" ", "_")}', '')
            _escolha_o = _duelo.get(f'escolha_{_oponente.lower().replace(" ", "_")}', '')

            _outcome_map = {
                ('nos_indicamos', 'nos_indicamos'): ('ğŸ¤ Consenso', 'Ambos indicam alguÃ©m em acordo', '#9b59b6'),
                ('nos_indicamos', 'eu_encaro'): ('âš”ï¸ DivergÃªncia', f'{_oponente.split()[0]} vai ao ParedÃ£o sozinho', '#e67e22'),
                ('eu_encaro', 'nos_indicamos'): ('âš”ï¸ DivergÃªncia', f'{_sorteado.split()[0]} vai ao ParedÃ£o sozinho', '#e67e22'),
                ('eu_encaro', 'eu_encaro'): ('ğŸ’¥ Duelo direto', 'Ambos vÃ£o ao ParedÃ£o', '#e74c3c'),
            }

            print('<div style="margin:1rem 0;">')
            print('<details style="background:rgba(255,255,255,0.03); border:1px solid #444; border-radius:10px; padding:0.8rem;">')
            print('<summary style="cursor:pointer; color:#ccc; font-size:0.9em;">ğŸ“ <strong>Matriz de decisÃµes possÃ­veis</strong> â€” o que cada combinaÃ§Ã£o de escolhas produzia</summary>')
            print('<div style="padding:0.8rem 0;">')
            print(f'<p style="color:#aaa; font-size:0.82em;">No Duelo de Risco, cada duelista escolhe secretamente: <strong>"NÃ³s indicamos"</strong> (juntos indicam um terceiro) ou <strong>"Eu encaro"</strong> (vai ao ParedÃ£o sozinho). O resultado depende da combinaÃ§Ã£o.</p>')
            print('<table class="table" style="max-width:500px; font-size:0.85rem; margin:0.5rem auto;">')
            print(f'<thead><tr><th></th><th class="tc">ğŸŸ£ {_oponente.split()[0]}<br><span style="font-size:0.8em; color:#888;">"NÃ³s indicamos"</span></th><th class="tc">ğŸŸ  {_oponente.split()[0]}<br><span style="font-size:0.8em; color:#888;">"Eu encaro"</span></th></tr></thead>')
            print('<tbody>')
            for s_choice, s_label in [('nos_indicamos', 'NÃ³s indicamos'), ('eu_encaro', 'Eu encaro')]:
                print(f'<tr><td style="vertical-align:middle;"><strong>ğŸŸ£ {_sorteado.split()[0]}</strong><br><span style="font-size:0.8em; color:#888;">"{s_label}"</span></td>')
                for o_choice in ['nos_indicamos', 'eu_encaro']:
                    _title, _desc, _color = _outcome_map.get((s_choice, o_choice), ('?', '?', '#888'))
                    _is_actual = (s_choice == _escolha_s and o_choice == _escolha_o)
                    _border = f'border:2px solid {_color}; background:rgba(155,89,182,0.15);' if _is_actual else ''
                    _check = ' âœ…' if _is_actual else ''
                    print(f'<td class="tc" style="{_border} border-radius:6px; padding:0.5rem;"><span style="color:{_color}; font-weight:bold;">{_title}</span>{_check}<br><span style="font-size:0.8em; color:#aaa;">{_desc}</span></td>')
                print('</tr>')
            print('</tbody></table>')
            print('</div></details></div>\n')

            # â”€â”€ 2. Pre-Duel Score Table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            print(f"### ğŸ“Š OpÃ§Ãµes prÃ©-duelo â€” Viabilidade de consenso\n")
            print(f'<p style="color:#aaa; font-size:0.85em;">Ranking por <strong>gargalo de consenso</strong>: o score do duelista <em>mais favorÃ¡vel</em> ao alvo (max). Para indicar juntos, ambos precisam aceitar â€” quem gosta mais do alvo Ã© quem trava a decisÃ£o. Scores <strong>antes</strong> da indicaÃ§Ã£o.</p>\n')

            # Build combined ranking
            _combined = []
            for t in _dr_eligible:
                s_entry = _sol_pre.get(t, {"score": 0, "queridometro": 0})
                j_entry = _jf_pre.get(t, {"score": 0, "queridometro": 0})
                _s_score = s_entry["score"]
                _j_score = j_entry["score"]
                _bottleneck = max(_s_score, _j_score)  # who blocks consensus
                _combined.append({
                    "name": t,
                    "sol_score": _s_score,
                    "jf_score": _j_score,
                    "bottleneck": _bottleneck,
                    "sol_q": s_entry["queridometro"],
                    "jf_q": j_entry["queridometro"],
                    "is_vip": t in _dr_vip,
                    "both_neg": _s_score < 0 and _j_score < 0,
                })
            _combined.sort(key=lambda x: x["bottleneck"])

            print('<table class="table table-striped" style="max-width:100%; font-size:0.9rem;">')
            print(f'<thead><tr><th>#</th><th>Alvo</th><th class="tc">{_sorteado.split()[0]}</th><th class="tc">{_oponente.split()[0]}</th><th class="tc">Gargalo</th><th class="tc">Q {_sorteado.split()[0]}</th><th class="tc">Q {_oponente.split()[0]}</th><th></th></tr></thead>')
            print('<tbody>')
            for _i, _c in enumerate(_combined):
                _is_target = _c["name"] == _consenso_target
                _row_style = 'background:rgba(231,76,60,0.15); border-left:3px solid #e74c3c;' if _is_target else ''
                _sc = lambda v: f'<span style="color:{"#e74c3c" if v < -2 else "#e67e22" if v < 0 else "#2ecc71"}; font-weight:bold;">{v:+.2f}</span>'
                _q_c = lambda v: f'<span style="color:{"#e74c3c" if v < 0 else "#2ecc71"};">{v:+.2f}</span>'
                _vip_badge = ' <span style="background:#f39c12; color:#000; padding:0.1rem 0.3rem; border-radius:6px; font-size:0.7em;">VIP</span>' if _c["is_vip"] else ''
                _target_badge = ' <span style="background:#e74c3c; color:#fff; padding:0.1rem 0.3rem; border-radius:6px; font-size:0.7em;">ğŸ“Œ ESCOLHIDA</span>' if _is_target else ''
                _consensus_icon = 'ğŸ”´' if _c["both_neg"] else 'ğŸŸ¡'
                _av_c = AVATARS.get(_c["name"], '')
                _img_c = f'<img src="{_av_c}" style="width:24px; height:24px; border-radius:50%; vertical-align:middle; margin-right:4px;">' if _av_c else ''
                print(f'<tr style="{_row_style}"><td class="text-muted">{_i+1}</td><td>{_img_c}<strong>{_c["name"]}</strong>{_target_badge}</td><td class="tc">{_sc(_c["sol_score"])}</td><td class="tc">{_sc(_c["jf_score"])}</td><td class="tc">{_consensus_icon} {_sc(_c["bottleneck"])}</td><td class="tc">{_q_c(_c["sol_q"])}</td><td class="tc">{_q_c(_c["jf_q"])}</td><td>{_vip_badge}</td></tr>')
            print('</tbody></table>')
            print(f'<p class="text-muted table-sm" style="margin-top:0.3rem;">ğŸ”´ = ambos negativos (consenso natural) Â· ğŸŸ¡ = um positivo (alguÃ©m cede)</p>\n')

            # Position insight
            _target_pos = next((_i+1 for _i, _c in enumerate(_combined) if _c["name"] == _consenso_target), None)
            _target_entry = next((_c for _c in _combined if _c["name"] == _consenso_target), None)
            if _target_pos and _target_entry:
                _insight_color = '#e74c3c' if _target_pos <= 3 else '#f39c12' if _target_pos <= 6 else '#2ecc71'
                _n_both_neg = sum(1 for _c in _combined if _c["both_neg"])
                print(f'<div style="background:rgba(155,89,182,0.1); border:1px solid rgba(155,89,182,0.3); border-radius:8px; padding:0.8rem; margin:0.5rem 0;">')
                print(f'<strong style="color:#9b59b6;">ğŸ’¡ PosiÃ§Ã£o:</strong> <span style="color:{_insight_color};">{_consenso_target} era o <strong>#{_target_pos}</strong> alvo por viabilidade de consenso</span> (gargalo: {_target_entry["bottleneck"]:+.2f}).')
                if _n_both_neg > 0:
                    _both_neg_names = [_c["name"] for _c in _combined if _c["both_neg"]]
                    print(f' Havia {_n_both_neg} alvo(s) com ambos negativos ({", ".join(_both_neg_names)}), mas {_consenso_target} tinha o menor gargalo entre os demais.')
                if _target_entry["sol_q"] >= 0 and _target_entry["jf_q"] < 0:
                    print(f' O queridÃ´metro de {_sorteado.split()[0]} era <span style="color:#2ecc71;">positivo ({_target_entry["sol_q"]:+.2f})</span> enquanto {_oponente.split()[0]} era <span style="color:#e74c3c;">negativo ({_target_entry["jf_q"]:+.2f})</span> â€” {_sorteado.split()[0]} cedeu para fechar o consenso.')
                print('</div>\n')

            # â”€â”€ 3. Overlap de Hostilidade â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            print(f"### ğŸ”€ Overlap de hostilidade\n")
            print(f'<p style="color:#aaa; font-size:0.85em;">ClassificaÃ§Ã£o dos alvos por onde {_sorteado.split()[0]} e {_oponente.split()[0]} concordam/discordam (baseado no score prÃ©-duelo).</p>\n')

            _both_neg = []
            _sol_only = []
            _jf_only = []
            _both_pos = []
            for _c in _combined:
                s_neg = _c["sol_score"] < 0
                j_neg = _c["jf_score"] < 0
                if s_neg and j_neg:
                    _both_neg.append(_c)
                elif s_neg and not j_neg:
                    _sol_only.append(_c)
                elif not s_neg and j_neg:
                    _jf_only.append(_c)
                else:
                    _both_pos.append(_c)

            def _render_overlap_box(title, color, rgba_bg, items, emoji):
                if not items:
                    return
                print(f'<div style="background:{rgba_bg}; border:1px solid {color}; border-radius:10px; padding:0.8rem; margin:0.6rem 0;">')
                print(f'<h5 style="color:{color}; margin-top:0;">{emoji} {title} ({len(items)})</h5>')
                print('<div style="display:flex; flex-wrap:wrap; gap:0.5rem;">')
                for _it in items:
                    _av_it = AVATARS.get(_it["name"], '')
                    _img_it = f'<img src="{_av_it}" style="width:28px; height:28px; border-radius:50%; vertical-align:middle; margin-right:3px; border:2px solid {color};">' if _av_it else ''
                    _mark = ' â­' if _it["name"] == _consenso_target else ''
                    print(f'<span style="background:rgba(0,0,0,0.3); padding:0.3rem 0.6rem; border-radius:8px; font-size:0.85em;">{_img_it}<strong>{_it["name"]}</strong>{_mark} <span style="color:#888;">({_it["bottleneck"]:+.2f})</span></span>')
                print('</div></div>')

            _render_overlap_box(f"Ambos negativos â€” consenso natural", "#e74c3c", "rgba(231,76,60,0.08)", _both_neg, "ğŸ”´")
            _render_overlap_box(f"SÃ³ {_sorteado.split()[0]} negativ{artigo(_sorteado).replace('o','a') if artigo(_sorteado)=='a' else 'o'}", "#e67e22", "rgba(230,126,34,0.08)", _sol_only, "ğŸŸ ")
            _render_overlap_box(f"SÃ³ {_oponente.split()[0]} negativo", "#f1c40f", "rgba(241,196,15,0.08)", _jf_only, "ğŸŸ¡")
            _render_overlap_box(f"Ambos positivos â€” seguro", "#2ecc71", "rgba(46,204,113,0.08)", _both_pos, "ğŸŸ¢")

            # Highlight contradiction if target is not in both_neg
            _target_in_both_neg = any(_c["name"] == _consenso_target for _c in _both_neg)
            if not _target_in_both_neg:
                _target_cat = "sÃ³ negativo para " + _oponente.split()[0] if any(_c["name"] == _consenso_target for _c in _jf_only) else "sÃ³ negativo para " + _sorteado.split()[0] if any(_c["name"] == _consenso_target for _c in _sol_only) else "positivo para ambos"
                print(f'\n<div style="background:rgba(241,196,15,0.1); border:1px solid rgba(241,196,15,0.3); border-radius:8px; padding:0.8rem; margin:0.8rem 0;">')
                print(f'<strong style="color:#f1c40f;">âš ï¸ Nota:</strong> {_consenso_target} estava na categoria <em>"{_target_cat}"</em> prÃ©-duelo â€” nÃ£o era um alvo de consenso natural. Havia {len(_both_neg)} alvo(s) que ambos tinham score negativo.')
                print(f'</div>\n')

            # â”€â”€ 4. QueridÃ´metro Ãºltimos 14 dias â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            print(f"### ğŸ“… QueridÃ´metro â€” Ãšltimos 14 dias\n")
            print(f'<p style="color:#aaa; font-size:0.85em;">ReaÃ§Ãµes diÃ¡rias entre os duelistas e {_consenso_target}. Cada emoji mostra o que o participante deu naquele dia.</p>\n')

            # Get 14 daily snapshots up to and including the duelo date
            _dr_snaps = [(s, m) for s, m in zip(daily_snapshots, daily_matrices) if s["date"] <= _duelo_date]
            _last14 = _dr_snaps[-14:] if len(_dr_snaps) >= 14 else _dr_snaps

            _q_pairs = [
                (_sorteado, _consenso_target, f"{_sorteado.split()[0]} â†’ {_consenso_target}"),
                (_oponente, _consenso_target, f"{_oponente.split()[0]} â†’ {_consenso_target}"),
                (_consenso_target, _sorteado, f"{_consenso_target} â†’ {_sorteado.split()[0]}"),
                (_consenso_target, _oponente, f"{_consenso_target} â†’ {_oponente.split()[0]}"),
            ]

            print('<table class="table" style="max-width:100%; font-size:0.85rem; white-space:nowrap;">')
            print('<thead><tr><th>Par</th>')
            for _snap, _mat in _last14:
                _d = _snap["date"]
                _d_short = _d[5:]  # MM-DD
                print(f'<th class="tc text-muted" style="font-size:0.75em; padding:0.2rem;">{_d_short}</th>')
            print('</tr></thead><tbody>')

            for _actor, _target_q, _label in _q_pairs:
                _av_a = AVATARS.get(_actor, '')
                _img_a = f'<img src="{_av_a}" style="width:18px; height:18px; border-radius:50%; vertical-align:middle; margin-right:2px;">' if _av_a else ''
                print(f'<tr><td style="white-space:nowrap;">{_img_a}{_label}</td>')
                for _snap, _mat in _last14:
                    _reaction = _mat.get((_actor, _target_q), '')
                    if _reaction:
                        _emoji = REACTION_EMOJI.get(_reaction, _reaction)
                        _is_pos = _reaction in POSITIVE
                        _is_strong_neg = _reaction in STRONG_NEGATIVE
                        _bg = 'rgba(46,204,113,0.15)' if _is_pos else 'rgba(231,76,60,0.2)' if _is_strong_neg else 'rgba(241,196,15,0.1)'
                        print(f'<td class="tc" style="background:{_bg}; padding:0.2rem;" title="{_reaction}">{_emoji}</td>')
                    else:
                        print(f'<td class="tc" style="color:#444; padding:0.2rem;">Â·</td>')
                print('</tr>')
            print('</tbody></table>\n')

            # Highlight contradiction if Sol gave hearts but nominated
            _sol_hearts_to_target = sum(1 for _snap, _mat in _last14
                                         if _mat.get((_sorteado, _consenso_target), '') in POSITIVE)
            _sol_total_days = sum(1 for _snap, _mat in _last14
                                  if _mat.get((_sorteado, _consenso_target), ''))
            if _sol_hearts_to_target > 0 and _sol_total_days > 0:
                _pct_hearts = _sol_hearts_to_target / _sol_total_days * 100
                if _pct_hearts >= 30:
                    print(f'<div style="background:rgba(241,196,15,0.1); border:1px solid rgba(241,196,15,0.3); border-radius:8px; padding:0.8rem; margin:0.5rem 0;">')
                    print(f'<strong style="color:#f1c40f;">âš ï¸ ContradiÃ§Ã£o:</strong> {_sorteado.split()[0]} deu â¤ï¸ para {_consenso_target} em {_sol_hearts_to_target} de {_sol_total_days} dias ({_pct_hearts:.0f}%) nos Ãºltimos 14 dias, mas a indicou no Duelo de Risco.')
                    print(f'</div>\n')

            # â”€â”€ 5. Perfil de rejeiÃ§Ã£o (incoming scores) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            print(f"### ğŸ¯ Perfil de rejeiÃ§Ã£o â€” Quem mais rejeita {_consenso_target}?\n")
            print(f'<p style="color:#aaa; font-size:0.85em;">Scores de todos os participantes em direÃ§Ã£o a {_consenso_target} (prÃ©-duelo). Contextualiza se {_consenso_target} era amplamente rejeitad{artigo(_consenso_target)} ou um alvo estratÃ©gico isolado.</p>\n')

            # Gather all incoming scores toward the target
            _incoming = []
            for _actor_name in _dr_active:
                if _actor_name == _consenso_target:
                    continue
                _a_entry = _dr_pairs.get(_actor_name, {}).get(_consenso_target, {})
                if not _a_entry:
                    continue
                _a_score = _a_entry.get("score", 0)
                # Subtract indicaÃ§Ã£o edge if this actor has one
                if _actor_name in _dr_ind_weight:
                    _a_score -= _dr_ind_weight[_actor_name]
                _incoming.append({"name": _actor_name, "score": _a_score})
            _incoming.sort(key=lambda x: x["score"])

            if _incoming:
                _max_abs = max(abs(_inc["score"]) for _inc in _incoming) or 1
                print('<div style="max-width:600px;">')
                for _inc in _incoming:
                    _bar_pct = abs(_inc["score"]) / _max_abs * 100
                    _bar_color = '#e74c3c' if _inc["score"] < -2 else '#e67e22' if _inc["score"] < 0 else '#2ecc71'
                    _is_duelist = _inc["name"] in (_sorteado, _oponente)
                    _mark = ' âš”ï¸' if _is_duelist else ''
                    _av_inc = AVATARS.get(_inc["name"], '')
                    _img_inc = f'<img src="{_av_inc}" style="width:20px; height:20px; border-radius:50%; vertical-align:middle; margin-right:3px;">' if _av_inc else ''
                    print(f'<div style="display:flex; align-items:center; margin:0.25rem 0; font-size:0.85em;">')
                    print(f'<span style="width:150px; text-align:right; padding-right:0.5rem; white-space:nowrap;">{_img_inc}{_inc["name"]}{_mark}</span>')
                    if _inc["score"] < 0:
                        print(f'<div style="width:{_bar_pct:.0f}%; height:16px; background:{_bar_color}; border-radius:3px; margin-right:0.3rem;"></div>')
                    else:
                        print(f'<div style="width:{_bar_pct:.0f}%; height:16px; background:{_bar_color}; border-radius:3px; margin-right:0.3rem;"></div>')
                    print(f'<span style="color:{_bar_color}; font-weight:bold;">{_inc["score"]:+.2f}</span>')
                    print(f'</div>')
                print('</div>\n')

                _n_neg = sum(1 for _inc in _incoming if _inc["score"] < 0)
                _n_total = len(_incoming)
                print(f'<div style="background:rgba(155,89,182,0.1); border:1px solid rgba(155,89,182,0.3); border-radius:8px; padding:0.8rem; margin:0.5rem 0;">')
                print(f'<strong style="color:#9b59b6;">ğŸ“Š Resumo:</strong> {_n_neg} de {_n_total} participantes tinham score negativo em direÃ§Ã£o a {_consenso_target} prÃ©-duelo.')
                if _n_neg <= 3:
                    print(f' RejeiÃ§Ã£o concentrada em poucos â€” <strong>alvo mais estratÃ©gico que consensual</strong>.')
                elif _n_neg >= _n_total * 0.5:
                    print(f' RejeiÃ§Ã£o ampla â€” <strong>alvo de consenso natural</strong>.')
                print(f'</div>\n')

        # â”€â”€ Sincerinho â€” Duelo de Risco (raw choices, reference table) â”€â”€
        if _duelo and _duelo.get('escolhas'):
            _escolhas = _duelo['escolhas']
            _alvos = _duelo.get('alvos_mais_citados', [])
            _nao_citados = _duelo.get('nao_citados', [])

            print("\n## âš”ï¸ Sincerinho â€” Duelo de Risco\n")
            print(f'<p style="color:#aaa; font-size:0.9em;">Cada participante escolheu quem quer enfrentar no ParedÃ£o.</p>\n')

            # â”€â”€ Most targeted summary â”€â”€
            if _alvos:
                print('<div style="display: flex; flex-wrap: wrap; gap: 0.8rem; justify-content: center; margin: 1.2rem 0;">')
                for _a in _alvos:
                    _nome = _a['nome']
                    _vezes = _a['vezes']
                    _av = AVATARS.get(_nome, '')
                    _cor = '#e74c3c' if _vezes >= 3 else '#f39c12' if _vezes >= 2 else '#888'
                    print(f'<div class="tc" style="background: rgba(255,255,255,0.05); border: 1px solid {_cor}; border-radius: 10px; padding: 0.6rem 1rem; min-width: 100px;">')
                    if _av:
                        print(f'<img src="{_av}" style="width:36px; height:36px; border-radius:50%; border:2px solid {_cor}; margin-bottom:0.3rem;" alt="{_nome}">')
                    print(f'<div style="color:#fff; font-size:0.9em; font-weight:bold;">{_nome}</div>')
                    print(f'<div style="color:{_cor}; font-size:1.2em; font-weight:bold;">ğŸ¯ {_vezes}Ã—</div>')
                    _por = ', '.join(_a.get('por', []))
                    print(f'<div class="text-muted" style="font-size:0.7em;">{_por}</div>')
                    print('</div>')
                print('</div>\n')

            # â”€â”€ Full table â”€â”€
            print('<table class="table table-striped" style="max-width:100%; font-size:0.9rem;">')
            print('<thead><tr><th>Participante</th><th>Quer enfrentar</th><th>Adjetivo</th></tr></thead>')
            print('<tbody>')
            _target_count = {}
            for _v in _escolhas.values():
                _t = _v['alvo']
                _target_count[_t] = _target_count.get(_t, 0) + 1
            _sorted_escolhas = sorted(_escolhas.items(), key=lambda x: (-_target_count.get(x[1]['alvo'], 0), x[0]))
            for _nome, _info in _sorted_escolhas:
                _alvo = _info['alvo']
                _adj = _info['adjetivo']
                _cnt = _target_count.get(_alvo, 0)
                _badge = f' <span style="background:#e74c3c; color:#fff; padding:0.1rem 0.4rem; border-radius:8px; font-size:0.75em;">{_cnt}Ã—</span>' if _cnt >= 2 else ''
                _av_actor = AVATARS.get(_nome, '')
                _av_target = AVATARS.get(_alvo, '')
                _av_html_a = f'<img src="{_av_actor}" style="width:22px; height:22px; border-radius:50%; vertical-align:middle; margin-right:4px;">' if _av_actor else ''
                _av_html_t = f'<img src="{_av_target}" style="width:22px; height:22px; border-radius:50%; vertical-align:middle; margin-right:4px;">' if _av_target else ''
                print(f'<tr><td>{_av_html_a}{_nome}</td><td>{_av_html_t}{_alvo}{_badge}</td><td style="color:#e74c3c; font-style:italic;">{_adj}</td></tr>')
            print('</tbody></table>\n')

            # â”€â”€ Mutual hostility pairs â”€â”€
            _mutuals = []
            for _n1, _i1 in _escolhas.items():
                _t1 = _i1['alvo']
                if _t1 in _escolhas and _escolhas[_t1]['alvo'] == _n1 and _n1 < _t1:
                    _mutuals.append((_n1, _i1['adjetivo'], _t1, _escolhas[_t1]['adjetivo']))
            if _mutuals:
                print('<div style="background: rgba(231,76,60,0.1); border: 1px solid rgba(231,76,60,0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">')
                print('<h4 style="color:#e74c3c; margin-top:0;">âš”ï¸ Hostilidade mÃºtua â€” ambos se escolheram</h4>')
                for _m in _mutuals:
                    _av1 = AVATARS.get(_m[0], '')
                    _av2 = AVATARS.get(_m[2], '')
                    _img1 = f'<img src="{_av1}" style="width:24px; height:24px; border-radius:50%; vertical-align:middle; margin-right:3px;">' if _av1 else ''
                    _img2 = f'<img src="{_av2}" style="width:24px; height:24px; border-radius:50%; vertical-align:middle; margin-right:3px;">' if _av2 else ''
                    print(f'<div style="margin:0.4rem 0; font-size:0.95em;">{_img1}<strong>{_m[0]}</strong> <span style="color:#e74c3c;">"{_m[1]}"</span> â†” {_img2}<strong>{_m[2]}</strong> <span style="color:#e74c3c;">"{_m[3]}"</span></div>')
                print('</div>\n')

            # â”€â”€ Not targeted â”€â”€
            if _nao_citados:
                print(f'<div style="background: rgba(46,204,113,0.1); border: 1px solid rgba(46,204,113,0.3); border-radius: 8px; padding: 0.8rem; margin: 1rem 0;">')
                print(f'<h4 style="color:#2ecc71; margin-top:0;">ğŸ’š NinguÃ©m escolheu enfrentar ({len(_nao_citados)})</h4>')
                _names_html = []
                for _nc in _nao_citados:
                    _av_nc = AVATARS.get(_nc, '')
                    _img_nc = f'<img src="{_av_nc}" style="width:20px; height:20px; border-radius:50%; vertical-align:middle; margin-right:2px;">' if _av_nc else ''
                    _names_html.append(f'{_img_nc}{_nc}')
                print(f'<div class="text-light" style="font-size:0.9em;">{" Â· ".join(_names_html)}</div>')
                print('</div>\n')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PAREDÃƒO FINALIZADO â€” Exibir se tem resultado
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if ultimo and (ultimo.get('status') == 'finalizado' or any(p.get('resultado') for p in ultimo.get('participantes', []))):
        df_p = pd.DataFrame(ultimo['participantes'])
        has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

        # â”€â”€ Visual: Cards com fotos e resultado â”€â”€
        print(f'<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 1.5rem 0 2rem 0;">')
        for _, row in df_p.iterrows():
            nome = row['nome']
            grupo = row.get('grupo', MEMBER_OF.get(nome, '?'))
            resultado = row.get('resultado', '')
            voto_total = row.get('voto_total', 0)
            avatar_url = AVATARS.get(nome, '')
            cor_grupo = GROUP_COLORS.get(grupo, '#666')

            # Card styling based on result
            if resultado == 'ELIMINADA':
                border_color = '#E6194B'
                badge_bg = '#E6194B'
                badge_text = 'ELIMINADO(A)'
                img_filter = 'grayscale(100%)'  # B&W for eliminated
            else:
                border_color = '#3CB44B'
                badge_bg = '#3CB44B'
                badge_text = 'SALVO(A)'
                img_filter = 'none'

            print(f'<div class="nominee-card" style="width: 160px; border: 3px solid {border_color};">')
            if avatar_url:
                print(f'<img src="{avatar_url}" alt="{nome}" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid {border_color}; margin-bottom: 0.75rem; filter: {img_filter};">')
            print(f'<h4 class="tc" style="margin: 0 0 0.25rem 0; color: #fff; font-size: 1em;">{nome}</h4>')
            print(f'<span style="display: block; color: {cor_grupo}; font-size: 0.8em; margin-bottom: 0.5rem;">{grupo}</span>')
            print(f'<span style="display: inline-block; padding: 0.25rem 0.6rem; background: {badge_bg}; color: #fff; border-radius: 10px; font-size: 0.75em; font-weight: bold;">{badge_text}</span>')
            print(f'<div style="color: #fff; font-size: 1.3em; font-weight: bold; margin-top: 0.5rem;">{voto_total:.1f}%</div>')
            print('</div>')
        print('</div>')

        fig = go.Figure()

        if has_breakdown:
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_unico'],
                text=[f"{v:.1f}%" for v in df_p['voto_unico']],
                textposition='outside', name='Voto Ãšnico (70%)',
                marker_color='#1976D2',
                hovertemplate='%{x}: %{y:.1f}% (Voto Ãšnico)<extra></extra>',
            ))
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_torcida'],
                text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
                textposition='outside', name='Voto Torcida (30%)',
                marker_color='#FF9800',
                hovertemplate='%{x}: %{y:.1f}% (Voto Torcida)<extra></extra>',
            ))

        colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_total'],
            text=[f"{v:.1f}%" for v in df_p['voto_total']],
            textposition='outside', name='MÃ©dia Final',
            marker_color=colors_total,
            hovertemplate='%{x}: %{y:.1f}% (Final)<extra></extra>',
        ))

        fig.update_layout(
            title=dict(text=ultimo['titulo'], y=0.95, x=0.5, xanchor='center'),
            xaxis_title="", yaxis_title="Votos (%)",
            yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
            barmode='group',
            height=500,
            margin=dict(t=100),
            legend=dict(orientation='h', yanchor='bottom', y=1.08, xanchor='center', x=0.5),
            annotations=[dict(
                text="FÃ³rmula: (Voto Ãšnico Ã— 0,70) + (Voto Torcida Ã— 0,30) = MÃ©dia Final",
                xref="paper", yref="paper", x=0.5, y=-0.12, showarrow=False,
                font=dict(size=11, color='gray')
            )]
        )

        fig.show()

        # â”€â”€ Enquetes vs Resultado (finalizado) â”€â”€
        poll = get_poll_for_paredao(polls_data, ultimo['numero'])
        if poll and poll.get('resultado_real'):
            participantes_poll = poll.get('participantes', [])
            consolidado = poll.get('consolidado', {})
            plataformas = poll.get('plataformas', {})
            resultado = poll['resultado_real']
            accuracy = calculate_poll_accuracy(poll)

            # Model prediction (using all finalized data for display)
            _prec_fin = calculate_precision_weights(polls_data)
            _model_pred_fin = predict_precision_weighted(poll, _prec_fin) if _prec_fin.get('sufficient') else None
            _model_mae_fin = None
            _model_correct_fin = None
            if _model_pred_fin:
                _model_mae_fin = sum(abs(_model_pred_fin['prediction'].get(n, 0) - resultado.get(n, 0)) for n in participantes_poll) / len(participantes_poll)
                _model_correct_fin = _model_pred_fin['predicao_eliminado'] == resultado.get('eliminado')

            print("\n## ğŸ“Š Enquetes vs Resultado\n")
            print(f'<p class="text-muted small">Dados agregados de <a href="https://votalhada.blogspot.com/" target="_blank">Votalhada</a> â€” coleta em {poll.get("data_coleta", "?")[:10]}</p>\n')

            # Status badges â€” Votalhada + Model side by side
            if accuracy and accuracy['predicao_correta']:
                status_html = '<span style="background:#3CB44B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âœ… Votalhada correta</span>'
            else:
                status_html = '<span style="background:#E6194B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âŒ Votalhada errada</span>'

            erro_medio = accuracy['erro_medio'] if accuracy else 0
            print(f'<div class="tc" style="margin-bottom:1.5rem;">')
            print(f'{status_html}')
            print(f'<span class="text-muted" style="margin-left:0.5rem;">Erro: <strong>{erro_medio:.1f}</strong> p.p.</span>')

            if _model_pred_fin and _model_mae_fin is not None:
                if _model_correct_fin:
                    model_badge = '<span style="background:#00bc8c; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âœ… Modelo correto</span>'
                else:
                    model_badge = '<span style="background:#E6194B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âŒ Modelo errado</span>'
                print(f'<span style="margin-left:1rem;">{model_badge}</span>')
                print(f'<span class="text-muted" style="margin-left:0.5rem;">Erro: <strong>{_model_mae_fin:.1f}</strong> p.p.</span>')
            print(f'</div>\n')

            # Grouped bar chart: Enquetes vs Resultado Real
            fig_poll = go.Figure()
            enquete_vals = [consolidado.get(n, 0) for n in participantes_poll]
            fig_poll.add_trace(go.Bar(
                x=participantes_poll, y=enquete_vals,
                text=[f"{v:.1f}%" for v in enquete_vals],
                textposition='outside', name='Enquete (Consolidado)',
                marker_color='#9b59b6',
                hovertemplate='%{x}: %{y:.1f}% (Enquete)<extra></extra>',
            ))
            # Model bar (between Enquete and Resultado)
            if _model_pred_fin:
                model_vals = [_model_pred_fin['prediction'].get(n, 0) for n in participantes_poll]
                fig_poll.add_trace(go.Bar(
                    x=participantes_poll, y=model_vals,
                    text=[f"{v:.1f}%" for v in model_vals],
                    textposition='outside', name='Modelo Ponderado',
                    marker_color='#00bc8c',
                    hovertemplate='%{x}: %{y:.1f}% (Modelo)<extra></extra>',
                ))

            resultado_vals = [resultado.get(n, 0) for n in participantes_poll]
            colors_real = ['#E6194B' if n == resultado.get('eliminado') else '#3CB44B' for n in participantes_poll]
            fig_poll.add_trace(go.Bar(
                x=participantes_poll, y=resultado_vals,
                text=[f"{v:.1f}%" for v in resultado_vals],
                textposition='outside', name='Resultado Real',
                marker_color=colors_real,
                hovertemplate='%{x}: %{y:.1f}% (Real)<extra></extra>',
            ))
            fig_poll.update_layout(
                title=dict(text='Enquetes Agregadas vs Resultado Real', y=0.95, x=0.5, xanchor='center'),
                xaxis_title="", yaxis_title="Votos (%)",
                yaxis_range=[0, max(max(enquete_vals), max(resultado_vals)) * 1.25],
                barmode='group',
                height=400,
                margin=dict(t=80, b=60),
                legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
            )
            fig_poll.show()

            # Time series chart (finalizado)
            if poll.get('serie_temporal'):
                fig_ts = make_poll_timeseries(poll, resultado_real=resultado)
                if fig_ts:
                    fig_ts.show()

            # Platform breakdown table
            print("\n### ğŸ“± Por Plataforma\n")
            print('<table class="table table-striped table-hover" style="max-width: 100%; font-size: 1rem;">')
            print('<thead><tr><th>Plataforma</th>')
            for nome in participantes_poll:
                avatar = avatar_img(nome, AVATARS, 28)
                print(f'<th class="tc">{avatar}</th>')
            print('<th class="tc text-muted">Votos</th>')
            print('</tr></thead><tbody>')

            platform_order = ['sites', 'youtube', 'twitter', 'instagram']
            platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}
            platform_colors = {'sites': '#3498db', 'youtube': '#e74c3c', 'twitter': '#1da1f2', 'instagram': '#e1306c'}

            for plat in platform_order:
                if plat in plataformas:
                    pdata = plataformas[plat]
                    votos = pdata.get('votos', 0)
                    votos_str = f"{votos:,.0f}".replace(',', '.')
                    print(f'<tr><td style="font-weight:bold; color:{platform_colors.get(plat, "#fff")}">{platform_names.get(plat, plat)}</td>')
                    for nome in participantes_poll:
                        val = pdata.get(nome, 0)
                        is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                        style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                        print(f'<td class="tc" style="{style}">{val:.1f}%</td>')
                    print(f'<td class="tc text-muted" style="font-size:0.9em;">{votos_str}</td>')
                    print('</tr>')

            total_votos = consolidado.get('total_votos', 0)
            total_str = f"{total_votos:,.0f}".replace(',', '.')
            print(f'<tr style="background:rgba(155,89,182,0.2);"><td style="font-weight:bold;">ğŸ“Š Consolidado</td>')
            for nome in participantes_poll:
                val = consolidado.get(nome, 0)
                is_max = val == max(consolidado.get(n, 0) for n in participantes_poll)
                style = 'font-weight:bold; color:#9b59b6;' if is_max else 'font-weight:bold;'
                print(f'<td class="tc" style="{style}">{val:.1f}%</td>')
            print(f'<td class="tc text-muted" style="font-size:0.9em;">{total_str}</td>')
            print('</tr>')

            # Model row
            if _model_pred_fin:
                print(f'<tr style="background:rgba(0,188,140,0.2);"><td style="font-weight:bold;">ğŸ¯ Modelo</td>')
                for nome in participantes_poll:
                    val = _model_pred_fin['prediction'].get(nome, 0)
                    is_max = val == max(_model_pred_fin['prediction'].get(n, 0) for n in participantes_poll)
                    style = 'font-weight:bold; color:#00bc8c;' if is_max else 'font-weight:bold;'
                    print(f'<td class="tc" style="{style}">{val:.1f}%</td>')
                print(f'<td class="tc text-muted" style="font-size:0.8em;">ponderado</td>')
                print('</tr>')

            print(f'<tr style="background:rgba(52,152,219,0.2);"><td style="font-weight:bold;">ğŸ† Resultado Real</td>')
            for nome in participantes_poll:
                val = resultado.get(nome, 0)
                is_elim = nome == resultado.get('eliminado')
                style = 'font-weight:bold; color:#E6194B;' if is_elim else 'font-weight:bold; color:#3CB44B;'
                print(f'<td class="tc" style="{style}">{val:.1f}%</td>')
            print('<td class="tc text-muted">â€”</td>')
            print('</tr>')
            print('</tbody></table>\n')

            # â”€â”€ AnÃ¡lise de PrecisÃ£o: Enquetes vs Tipos de Voto â”€â”€
            # Get vote breakdown from paredoes.json for this paredÃ£o
            paredao_votos = {}
            for p in ultimo.get('participantes', []):
                nome = p.get('nome')
                if nome and 'voto_total' in p:
                    paredao_votos[nome] = {
                        'voto_unico': p.get('voto_unico', 0),
                        'voto_torcida': p.get('voto_torcida', 0),
                        'voto_total': p.get('voto_total', 0),
                    }

            if paredao_votos:
                eliminado_nome = resultado.get('eliminado')

                # Calculate errors for eliminated person against each vote type
                poll_elim = consolidado.get(eliminado_nome, 0)
                voto_unico_elim = paredao_votos.get(eliminado_nome, {}).get('voto_unico', 0)
                voto_torcida_elim = paredao_votos.get(eliminado_nome, {}).get('voto_torcida', 0)
                voto_total_elim = paredao_votos.get(eliminado_nome, {}).get('voto_total', 0)

                erro_vs_unico = poll_elim - voto_unico_elim
                erro_vs_torcida = poll_elim - voto_torcida_elim
                erro_vs_total = poll_elim - voto_total_elim

                print("\n### ğŸ¯ PrecisÃ£o das Enquetes\n")
                print(f"**{eliminado_nome}** (eliminado): enquete previa **{poll_elim:.1f}%**, resultado real **{voto_total_elim:.1f}%**\n")

                # Table: Poll vs Vote Types
                print('<table class="table table-sm" style="max-width: 600px;">')
                print('<thead><tr><th>ComparaÃ§Ã£o</th><th class="tc">Enquete</th><th class="tc">VotaÃ§Ã£o</th><th class="tc">Erro</th></tr></thead>')
                print('<tbody>')

                vote_types = [
                    ('Voto Ãšnico (70%)', voto_unico_elim, erro_vs_unico),
                    ('Voto Torcida (30%)', voto_torcida_elim, erro_vs_torcida),
                    ('MÃ©dia Final', voto_total_elim, erro_vs_total),
                ]

                # Find which vote type poll was closest to
                closest_type = min(vote_types, key=lambda x: abs(x[2]))

                for vtype, vval, verr in vote_types:
                    is_closest = vtype == closest_type[0]
                    row_style = 'background:rgba(60,180,75,0.2);' if is_closest else ''
                    badge = ' ğŸ¯' if is_closest else ''
                    err_color = '#E6194B' if verr < -5 else '#3CB44B' if abs(verr) < 5 else '#f39c12'
                    print(f'<tr style="{row_style}"><td>{vtype}{badge}</td>')
                    print(f'<td class="tc">{poll_elim:.1f}%</td>')
                    print(f'<td class="tc">{vval:.1f}%</td>')
                    print(f'<td class="tc" style="color:{err_color}; font-weight:bold;">{verr:+.1f} p.p.</td>')
                    print('</tr>')

                print('</tbody></table>\n')

                # Platform accuracy for eliminated person
                print("### ğŸ“± Qual plataforma acertou mais?\n")
                platform_errors = []
                for plat in ['sites', 'youtube', 'twitter', 'instagram']:
                    if plat in plataformas:
                        plat_val = plataformas[plat].get(eliminado_nome, 0)
                        plat_err = abs(plat_val - voto_total_elim)
                        platform_errors.append((plat, plat_val, plat_err))

                # Sort by error (ascending)
                platform_errors.sort(key=lambda x: x[2])

                platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

                print(f'<p>Para <strong>{eliminado_nome}</strong> (resultado: {voto_total_elim:.1f}%):</p>')
                print('<table class="table table-sm" style="max-width: 500px;">')
                print('<thead><tr><th>#</th><th>Plataforma</th><th class="tc">PrevisÃ£o</th><th class="tc">Erro</th></tr></thead>')
                print('<tbody>')
                for rank, (plat, pval, perr) in enumerate(platform_errors, 1):
                    medal = 'ğŸ¥‡' if rank == 1 else 'ğŸ¥ˆ' if rank == 2 else 'ğŸ¥‰' if rank == 3 else '4Âº'
                    row_style = 'background:rgba(60,180,75,0.2);' if rank == 1 else ''
                    print(f'<tr style="{row_style}"><td>{medal}</td><td>{platform_names.get(plat, plat)}</td>')
                    print(f'<td class="tc">{pval:.1f}%</td>')
                    print(f'<td class="tc">{perr:.1f} p.p.</td>')
                    print('</tr>')
                print('</tbody></table>\n')

                # â”€â”€ Historical comparison across all paredÃµes â”€â”€
                all_polls = polls_data.get('paredoes', [])
                finalized_polls = [p for p in all_polls if p.get('resultado_real')]

                if len(finalized_polls) >= 2:
                    print("### ğŸ“Š PadrÃµes Observados (todos os paredÃµes)\n")

                    total_correct = sum(1 for p in finalized_polls if p['resultado_real'].get('predicao_correta'))
                    total_polls = len(finalized_polls)

                    # Calculate average underestimation of eliminated person
                    underest_sum = 0
                    for p in finalized_polls:
                        elim = p['resultado_real'].get('eliminado')
                        poll_val = p['consolidado'].get(elim, 0)
                        real_val = p['resultado_real'].get(elim, 0)
                        underest_sum += (poll_val - real_val)
                    avg_underest = underest_sum / total_polls

                    # Find best platform across all paredÃµes
                    platform_total_err = {'sites': 0, 'youtube': 0, 'twitter': 0, 'instagram': 0}
                    for p in finalized_polls:
                        elim = p['resultado_real'].get('eliminado')
                        real_val = p['resultado_real'].get(elim, 0)
                        for plat in platform_total_err:
                            if plat in p.get('plataformas', {}):
                                plat_val = p['plataformas'][plat].get(elim, 0)
                                platform_total_err[plat] += abs(plat_val - real_val)

                    best_platform = min(platform_total_err, key=platform_total_err.get)

                    print(f'<div style="background:rgba(52,152,219,0.1); border-radius:12px; padding:1rem; margin:1rem 0;">')
                    print(f'<p style="margin:0;"><strong>âœ… Taxa de acerto:</strong> {total_correct}/{total_polls} paredÃµes ({100*total_correct/total_polls:.0f}%)</p>')
                    print(f'<p style="margin:0.5rem 0 0 0;"><strong>ğŸ“‰ PadrÃ£o:</strong> Enquetes subestimam o eliminado em <strong>{abs(avg_underest):.1f} p.p.</strong> em mÃ©dia</p>')
                    print(f'<p style="margin:0.5rem 0 0 0;"><strong>ğŸ† Plataforma mais precisa:</strong> {platform_names.get(best_platform, best_platform)} (erro mÃ©dio: {platform_total_err[best_platform]/total_polls:.1f} p.p.)</p>')
                    print(f'</div>\n')

        # Resumo da formaÃ§Ã£o (finalizado)
        print("\n### ğŸ§© Resumo da FormaÃ§Ã£o\n")
        if ultimo.get('formacao'):
            print(f"- **Como foi formado:** {ultimo['formacao']}")
        if ultimo.get('lider'):
            print(f"- **LÃ­der:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
        if ultimo.get('anjo'):
            auto = " (autoimune)" if ultimo.get('anjo_autoimune') else ""
            print(f"- **Anjo:** {ultimo['anjo']}{auto}")
        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"- **ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")
        if ultimo.get('dinamica'):
            dinamica = ultimo['dinamica']
            print(f"- **DinÃ¢mica:** {dinamica.get('nome', 'DinÃ¢mica especial')}")
            if dinamica.get('indicaram') and dinamica.get('indicado'):
                ind_list = ', '.join(dinamica['indicaram'])
                print(f"  - Indicaram: {ind_list} â†’ **{dinamica['indicado']}**")
            efeitos = dinamica.get('efeitos', {})
            if efeitos:
                for pessoa, efeito in efeitos.items():
                    print(f"  - {pessoa}: {efeito}")
        if ultimo.get('big_fone'):
            bf = ultimo['big_fone']
            print(f"- **Big Fone:** {bf.get('atendeu', 'â€”')} indicou {bf.get('indicou', 'â€”')}")
        if ultimo.get('contragolpe'):
            cg = ultimo['contragolpe']
            print(f"- **Contragolpe:** {cg.get('de', 'â€”')} â†’ {cg.get('para', 'â€”')}")
        if ultimo.get('bate_volta'):
            bv = ultimo['bate_volta']
            bv_w = bv.get('vencedores') or ([bv['vencedor']] if bv.get('vencedor') else [])
            label = 'vencedores' if len(bv_w) > 1 else 'vencedor'
            print(f"- **Bate e Volta:** {', '.join(bv.get('participantes', []))} â€” {label}: {', '.join(bv_w) if bv_w else 'â€”'}")

        # VotaÃ§Ã£o da casa (finalizado)
        if ultimo.get('votos_casa'):
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"**Mais votado:** **{ranking[0][0]}** ({ranking[0][1]} votos)\n")

            print('<table class="table table-striped" style="font-size: 1.05rem;">')
            print('<thead><tr><th>Alvo</th><th class="tc">Votos</th><th>Votantes</th></tr></thead>')
            print('<tbody>')
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                votantes_html = ' '.join([avatar_img(v, AVATARS, 42) for v in votantes])
                print(f'<tr><td>{avatar_html(alvo, AVATARS, 42)}</td><td class="tc" style="font-weight:bold; font-size:1.1em;">{n}</td><td>{votantes_html}</td></tr>')
            print('</tbody></table>\n')

```

```{python}
#| label: paredao-perfeito
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SINCERINHO + DUELO DE RISCO
# Bar chart, key insights, and outcome chain.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_me_path = Path("data/manual_events.json")
_pp_data = None
if _me_path.exists():
    _me = json.loads(_me_path.read_text(encoding="utf-8"))
    for _we in _me.get("weekly_events", []):
        _sinc = _we.get("sincerao")
        if _sinc and isinstance(_sinc, dict) and "paredao_perfeito" in _sinc:
            _pp_data = _sinc
            break

if _pp_data:
    _pp = _pp_data["paredao_perfeito"]
    _stats = _pp_data.get("stats", {})
    _not_nom = _stats.get("not_nominated", [])
    _mutuals = _stats.get("mutual_nominations", [])

    from collections import Counter as _PPCounter, defaultdict as _PPDefaultdict
    _received = _PPCounter()
    _received_from = _PPDefaultdict(list)
    for _actor, _targets in _pp.items():
        for _t in _targets:
            _received[_t] += 1
            _received_from[_t].append(_actor)

    print("\n## ğŸ—£ï¸ Sincerinho â€” ParedÃ£o Perfeito\n")
    print('<p class="text-muted" style="font-size:0.85rem;">Cada participante montou sua berlinda ideal com 3 nomes. Resultado alimentou o Big Fone e o Duelo de Risco.</p>\n')

    # â”€â”€ Bar chart â”€â”€
    _sorted_names = sorted(_received.keys(), key=lambda x: -_received[x])
    _max_count = max(_received.values()) if _received else 1

    _html = '<h4 style="margin-top:1.2rem;">ğŸ“Š IndicaÃ§Ãµes Recebidas</h4>\n'
    _html += '<div style="max-width:700px;">\n'
    for _name in _sorted_names:
        _count = _received[_name]
        _pct = (_count / _max_count) * 100
        _color = "#E6194B" if _count >= 6 else "#FF8C00" if _count >= 3 else "#3CB44B"
        _av = avatar_img(_name, AVATARS, 32)
        _html += f'<div style="display:flex; align-items:center; margin-bottom:4px;">'
        _html += f'<div style="width:180px; display:flex; align-items:center; gap:6px;">{_av} <span style="font-size:0.85rem;">{_name}</span></div>'
        _html += f'<div style="flex:1; background:#333; border-radius:4px; height:22px; position:relative;">'
        _html += f'<div style="width:{_pct}%; background:{_color}; height:100%; border-radius:4px; display:flex; align-items:center; justify-content:flex-end; padding-right:6px;">'
        _html += f'<span style="color:#fff; font-weight:bold; font-size:0.8rem;">{_count}Ã—</span>'
        _html += '</div></div></div>\n'
    if _not_nom:
        _not_html = " ".join([f'{avatar_img(n, AVATARS, 32)} {n}' for n in _not_nom])
        _html += f'<div style="margin-top:8px; padding:6px 10px; background:#1a3a1a; border:1px solid #3CB44B; border-radius:6px; font-size:0.85rem;">'
        _html += f'ğŸ›¡ï¸ <strong>NÃ£o indicados:</strong> {_not_html}</div>\n'
    _html += '</div>\n'
    print(_html)

    # â”€â”€ Faction insight â”€â”€
    _jonas_nom = set(_received_from.get('Jonas Sulzbach', []))
    _alberto_nom = set(_received_from.get('Alberto Cowboy', []))
    _both = _jonas_nom & _alberto_nom
    if len(_both) >= 5:
        _both_html = " ".join([avatar_img(n, AVATARS, 28) for n in sorted(_both)])
        _fhtml = '<div style="margin-top:0.8rem; padding:10px 14px; background:#1a1a2a; border:1px solid #4363d8; border-radius:8px;">'
        _fhtml += f'<strong>ğŸ›ï¸ Bloco Anti-Jonas/Alberto</strong> â€” {len(_both)} pessoas nomearam ambos:<br/>'
        _fhtml += f'<div style="margin-top:6px;">{_both_html}</div></div>\n'
        print(_fhtml)

    # â”€â”€ Who picked whom + mutuals (expandable) â”€â”€
    _dhtml = '<details style="margin-top:1rem;">\n'
    _dhtml += '<summary style="cursor:pointer; font-weight:bold; font-size:1rem;">ğŸ” Quem indicou quem + indicaÃ§Ãµes mÃºtuas</summary>\n\n'
    _dhtml += '<table class="table table-striped" style="font-size:0.9rem; margin-top:0.5rem;">'
    _dhtml += '<thead><tr><th>Participante</th><th>ParedÃ£o Perfeito (3 nomes)</th></tr></thead><tbody>'
    for _actor in sorted(_pp.keys()):
        _targets = _pp[_actor]
        _targets_html = " ".join([f'{avatar_img(t, AVATARS, 32)}' for t in _targets])
        _av = avatar_img(_actor, AVATARS, 32)
        _dhtml += f'<tr><td>{_av} {_actor}</td><td>{_targets_html} <span style="font-size:0.8rem; color:#aaa;">{", ".join(_targets)}</span></td></tr>'
    _dhtml += '</tbody></table>'
    if _mutuals:
        _dhtml += '<div style="margin-top:0.8rem;"><strong>âš”ï¸ IndicaÃ§Ãµes mÃºtuas:</strong> '
        _dhtml += " ".join([f'<span style="background:#2a1a1a; border:1px solid #E6194B; border-radius:6px; padding:2px 8px; font-size:0.82rem;">{avatar_img(p[0], AVATARS, 22)} â†” {avatar_img(p[1], AVATARS, 22)}</span>' for p in _mutuals])
        _dhtml += '</div>'
    _dhtml += '</details>\n'
    print(_dhtml)

    # â”€â”€ Duelo de Risco outcome chain â”€â”€
    # Check if paredÃ£o has duelo data
    _duelo = None
    with open('data/paredoes.json') as _pf:
        _pdata = json.loads(_pf.read())
    for _p in _pdata['paredoes']:
        if _p.get('numero') == 6:
            _duelo = _p.get('formacao', {}).get('duelo_de_risco')
            break

    if _duelo:
        _duel_html = '<h4 style="margin-top:1.5rem;">âš”ï¸ Duelo de Risco â€” Resultado</h4>\n'
        _duel_html += '<div style="display:flex; flex-wrap:wrap; gap:12px; margin-top:0.5rem;">'

        # Step 1: Big Fone
        _bf_who = _duelo.get('big_fone_atendeu', '?')
        _bf_tipo = _duelo.get('big_fone_tipo', '')
        _duel_html += f'<div class="tc" style="background:#1a1a2a; border:1px solid #4363d8; border-radius:8px; padding:10px 14px; min-width:140px;">'
        _duel_html += f'<div class="text-muted" style="font-size:0.75rem;">ğŸ“ Big Fone</div>'
        _duel_html += f'{avatar_img(_bf_who, AVATARS, 40)}<br/>'
        _duel_html += f'<strong>{_bf_who}</strong><br/>'
        _duel_html += f'<span style="font-size:0.75rem; color:#aaa;">{_bf_tipo}</span></div>'

        # Step 2: Choice
        _escolhida = _duelo.get('escolhida', '?')
        _chaiany_picks = _pp.get(_bf_who, [])
        _duel_html += f'<div class="text-muted" style="display:flex; align-items:center; font-size:1.5rem;">â†’</div>'
        _duel_html += f'<div class="tc" style="background:#2a2a1a; border:1px solid #ffe119; border-radius:8px; padding:10px 14px; min-width:140px;">'
        _duel_html += f'<div class="text-muted" style="font-size:0.75rem;">ğŸ¯ Escolheu</div>'
        _duel_html += f'{avatar_img(_escolhida, AVATARS, 40)}<br/>'
        _duel_html += f'<strong>{_escolhida}</strong><br/>'
        _others = [n for n in _chaiany_picks if n != _escolhida]
        _duel_html += f'<span style="font-size:0.72rem; color:#aaa;">De: {", ".join(_chaiany_picks)}</span></div>'

        # Step 3: Result
        _emparedado = _duelo.get('emparedado', '?')
        _imune = _duelo.get('imune', '?')
        _duel_html += f'<div class="text-muted" style="display:flex; align-items:center; font-size:1.5rem;">â†’</div>'
        _duel_html += f'<div class="tc" style="background:#2a1a1a; border:1px solid #E6194B; border-radius:8px; padding:10px 14px; min-width:120px;">'
        _duel_html += f'<div class="text-muted" style="font-size:0.75rem;">ğŸ”¥ ParedÃ£o</div>'
        _duel_html += f'{avatar_img(_emparedado, AVATARS, 40)}<br/>'
        _duel_html += f'<strong style="color:#E6194B;">{_emparedado}</strong></div>'

        _duel_html += f'<div class="tc" style="background:#1a2a1a; border:1px solid #3CB44B; border-radius:8px; padding:10px 14px; min-width:120px;">'
        _duel_html += f'<div class="text-muted" style="font-size:0.75rem;">ğŸ›¡ï¸ Imune</div>'
        _duel_html += f'{avatar_img(_imune, AVATARS, 40)}<br/>'
        _duel_html += f'<strong style="color:#3CB44B;">{_imune}</strong></div>'

        _duel_html += '</div>\n'

        # Irony callout
        _duel_html += '<div style="margin-top:0.8rem; padding:8px 12px; background:#2a1a2a; border:1px solid #9b59b6; border-radius:6px; font-size:0.82rem;">'
        _duel_html += f'ğŸ­ <strong>Ironia:</strong> Chaiany Ã© o <strong>Anjo</strong> da semana â€” pode imunizar um aliado mas nÃ£o a si mesma. '
        _duel_html += f'Indicou Jordana no Sincerinho (7Ã— indicaÃ§Ãµes) e no Big Fone, mas Jordana saiu <strong>imune</strong>. '
        _duel_html += f'Contragolpe de Chaiany deve mirar Marciele ou Maxiane (seus outros 2 alvos do Sincerinho).</div>\n'
        print(_duel_html)

```

```{python}
#| label: paredao-prediction
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PREVISÃƒO DE INDICAÃ‡ÃƒO DO LÃDER
# Shown when: no active paredÃ£o, or formation still incomplete.
# Hidden when: formation complete (â‰¥ expected nominees) or finalized.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_show_prediction = False
if ultimo is None:
    _show_prediction = True
elif ultimo.get('status') == 'finalizado':
    _show_prediction = True  # Between paredÃµes
elif ultimo.get('status') == 'em_andamento':
    _n_ind = len(ultimo.get('participantes', []))
    _esp = ultimo.get('total_esperado', 3)
    _show_prediction = _n_ind < _esp  # Formation still incomplete

if _show_prediction:
    # â”€â”€ Load relations scores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _rel_path = Path("data/derived/relations_scores.json")
    _relations = json.loads(_rel_path.read_text(encoding="utf-8")) if _rel_path.exists() else {}
    _pairs_daily = _relations.get("pairs_daily", {}) or _relations.get("pairs", {})
    _rel_edges = _relations.get("edges", [])
    _rel_meta = _relations.get("_metadata", {})
    _display_week = _rel_meta.get("effective_week_daily") or _rel_meta.get("week") or "?"

    # â”€â”€ Detect current LÃ­der + Anjo from roles_daily.json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _rd = json.loads(Path("data/derived/roles_daily.json").read_text(encoding="utf-8"))
    _rd_daily = _rd.get("daily", [])
    _rd_latest = _rd_daily[-1] if _rd_daily else {}
    _lider_list = _rd_latest.get("roles", {}).get("LÃ­der", [])
    _anjo_list = _rd_latest.get("roles", {}).get("Anjo", [])
    _vip_list = _rd_latest.get("vip", [])
    _lider_name = _lider_list[0] if _lider_list else None

    # â”€â”€ Active participant set â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _pix = json.loads(Path("data/derived/participants_index.json").read_text(encoding="utf-8"))
    _pix_list = _pix.get("participants", _pix) if isinstance(_pix, dict) else _pix
    _active_names = {p["name"] for p in _pix_list if p.get("active", True)}

    html_pred = ""

    if not _lider_name:
        html_pred += '<div class="tc" style="background:#1a1a2e; border:1px solid #444; border-radius:10px; '
        html_pred += 'padding:1.5rem; margin:1rem 0; color:#aaa; font-size:1.1em;">'
        html_pred += 'ğŸ  <strong>Sem lÃ­der ativo</strong> â€” previsÃ£o de indicaÃ§Ã£o indisponÃ­vel.</div>'
    else:
        # â”€â”€ LÃ­der's scores toward all participants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _lider_scores = _pairs_daily.get(_lider_name, {})

        # Eligible targets: active participants minus the LÃ­der and already-nominated
        _already_nominated = set()
        if ultimo and ultimo.get('status') == 'em_andamento':
            _already_nominated = {p['nome'] for p in ultimo.get('participantes', [])}
        _eligible = {name: entry for name, entry in _lider_scores.items()
                     if name in _active_names and name != _lider_name
                     and name not in _already_nominated}

        # Rank by score ascending (most negative = most likely target)
        _ranked = sorted(_eligible.items(), key=lambda x: x[1].get("score", 0))

        # â”€â”€ Anjo immunity info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _anjo_name = _anjo_list[0] if _anjo_list else None
        _imunizado_nome = None
        if ultimo and ultimo.get('status') == 'em_andamento':
            _imun = ultimo.get('imunizado', {})
            _imunizado_nome = _imun.get('quem') if _imun else None

        # â”€â”€ Component emoji mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _comp_meta = {
            "queridometro": ("ğŸ", "#e74c3c", "#2ecc71"),
            "power_event": ("âš”ï¸", "#e74c3c", "#2ecc71"),
            "sincerao":    ("ğŸ“¢", "#e67e22", "#3498db"),
            "vote":        ("ğŸ—³ï¸", "#e74c3c", "#2ecc71"),
            "vip":         ("ğŸ ", "#3498db", "#3498db"),
            "anjo":        ("ğŸ˜‡", "#3498db", "#3498db"),
        }
        _edge_display = {
            "power_event": ("âš”ï¸", "Power Event"),
            "sincerao": ("ğŸ“¢", "SincerÃ£o"),
            "vote": ("ğŸ—³ï¸", "Voto"),
            "vip": ("ğŸ ", "VIP"),
            "anjo": ("ğŸ˜‡", "Anjo"),
        }

        # â”€â”€ Build queridÃ´metro history (reuse already-loaded snapshots) â”€â”€
        _emoji_map = {
            "CoraÃ§Ã£o": "â¤ï¸", "Planta": "ğŸŒ±", "Cobra": "ğŸ", "Mala": "ğŸ’¼",
            "Biscoito": "ğŸª", "CoraÃ§Ã£o partido": "ğŸ’”", "Alvo": "ğŸ¯",
            "VÃ´mito": "ğŸ¤®", "Mentiroso": "ğŸ¤¥",
        }
        _querido_history = {}
        for _i_snap, _snap_d in enumerate(daily_snapshots):
            _mat = daily_matrices[_i_snap]
            _dt = _snap_d['date']
            for (g, r), lbl in _mat.items():
                if g == _lider_name or r == _lider_name:
                    _querido_history.setdefault((g, r), []).append((_dt, lbl))

        # â”€â”€ Section header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _art = artigo(_lider_name)

        html_pred += '<h2 id="previsao-indicacao">ğŸ¯ PrevisÃ£o â€” IndicaÃ§Ã£o do LÃ­der</h2>'

        html_pred += '<div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); '
        html_pred += 'border:2px solid #e74c3c; border-radius:12px; padding:1.2rem 1.5rem; margin:1rem 0;">'
        html_pred += f'<div style="font-size:1.2em; margin-bottom:0.8rem;">'
        html_pred += f'ğŸ¯ <strong style="color:#e74c3c;">PrevisÃ£o de IndicaÃ§Ã£o d{_art} LÃ­der</strong></div>'

        html_pred += f'<div style="display:flex; align-items:center; gap:0.8rem; margin-bottom:1rem;">'
        html_pred += f'{avatar_img(_lider_name, AVATARS, size=40)}'
        html_pred += f'<span style="font-size:1.1em; color:#eee;"><strong>{_lider_name}</strong> '
        html_pred += f'<span class="text-muted">â€” LÃ­der da Semana {_display_week}</span></span></div>'

        # â”€â”€ Top 3 summary cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _top3 = _ranked[:3]
        html_pred += '<div style="display:flex; gap:0.8rem; flex-wrap:wrap; margin-bottom:0.8rem;">'
        for _i, (_tname, _tentry) in enumerate(_top3):
            _sc = _tentry.get("score", 0)
            _color = "#e74c3c" if _sc < -2 else "#e67e22" if _sc < 0 else "#2ecc71"
            _vip_tag = ' <span style="color:#3498db; font-size:0.75em;">VIP</span>' if _tname in _vip_list else ""
            html_pred += f'<div style="background:#111; border:1px solid {_color}; border-radius:8px; '
            html_pred += f'padding:0.6rem 0.8rem; min-width:140px; flex:1;">'
            html_pred += f'<div class="text-muted" style="font-size:0.75em;">#{_i+1} mais provÃ¡vel</div>'
            html_pred += f'<div style="display:flex; align-items:center; gap:0.4rem; margin:0.3rem 0;">'
            html_pred += f'{avatar_img(_tname, AVATARS, size=24)} '
            html_pred += f'<strong style="color:#eee;">{_tname}</strong>{_vip_tag}</div>'
            html_pred += f'<div style="color:{_color}; font-size:1.1em; font-weight:bold;">{_sc:+.2f}</div>'
            html_pred += '</div>'
        html_pred += '</div>'

        # Anjo note
        if _anjo_name:
            html_pred += f'<div style="color:#3498db; font-size:0.9em;">ğŸ˜‡ Anjo: <strong>{_anjo_name}</strong>'
            if _imunizado_nome:
                html_pred += f' â€” imunizou <strong>{_imunizado_nome}</strong> (bloqueado como alvo)'
            html_pred += '</div>'
        else:
            html_pred += '<div class="text-muted" style="font-size:0.9em;">ğŸ˜‡ Anjo ainda nÃ£o definido esta semana</div>'

        html_pred += '</div>'

        # â”€â”€ Full ranking table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        html_pred += '<div class="scroll-x" style="margin-top:1.2rem;">'
        html_pred += '<table class="table-full" style="font-size:0.85em;">'
        html_pred += '<thead><tr style="border-bottom:2px solid #444;">'
        for _hdr in ["#", "Participante", "Score", "Barra", "Componentes", "Reciprocidade", "Streak", "VIP"]:
            html_pred += f'<th style="padding:0.5rem 0.4rem; text-align:left; color:#aaa; white-space:nowrap;">{_hdr}</th>'
        html_pred += '</tr></thead><tbody>'

        _max_abs = max((abs(e.get("score", 0)) for _, e in _ranked), default=1) or 1

        for _rank, (_tname, _tentry) in enumerate(_ranked, 1):
            _sc = _tentry.get("score", 0)
            _comps = _tentry.get("components", {})
            _streak_len = _tentry.get("streak_len", 0)
            _has_break = _tentry.get("break", False)

            _sc_color = "#e74c3c" if _sc < -2 else "#e67e22" if _sc < 0 else "#2ecc71"
            _row_bg = "background:rgba(231,76,60,0.08);" if _rank <= 3 else ""

            _is_immune = (_tname == _imunizado_nome)
            _immune_tag = ' <span style="background:#3498db; color:#fff; font-size:0.7em; padding:1px 4px; border-radius:3px;">IMUNE</span>' if _is_immune else ""

            html_pred += f'<tr class="sep-bottom" style="{_row_bg}">'
            html_pred += f'<td class="cell-compact tc text-muted">{_rank}</td>'
            html_pred += f'<td class="cell-compact" style="white-space:nowrap;">{avatar_img(_tname, AVATARS, size=22)}'
            html_pred += f'<strong style="color:#eee;">{_tname}</strong>{_immune_tag}</td>'
            html_pred += f'<td class="cell-compact" style="color:{_sc_color}; font-weight:bold; font-family:monospace;">{_sc:+.2f}</td>'

            # Score bar
            _bar_pct = min(abs(_sc) / _max_abs * 100, 100)
            _bar_color = "#e74c3c" if _sc < 0 else "#2ecc71"
            _bar_dir = "right" if _sc < 0 else "left"
            html_pred += f'<td class="cell-compact" style="min-width:80px;">'
            html_pred += f'<div style="width:100%; background:#222; border-radius:3px; height:12px; position:relative;">'
            html_pred += f'<div style="width:{_bar_pct:.0f}%; background:{_bar_color}; height:100%; border-radius:3px; '
            html_pred += f'float:{_bar_dir};"></div></div></td>'

            # Components
            html_pred += f'<td class="cell-compact">'
            _chips = []
            for _ck, (_ce, _cneg, _cpos) in _comp_meta.items():
                _cv = _comps.get(_ck, 0.0)
                if abs(_cv) < 0.01:
                    continue
                _cc = _cneg if _cv < 0 else _cpos
                _chips.append(
                    f'<span style="background:{_cc}22; color:{_cc}; border:1px solid {_cc}44; '
                    f'border-radius:3px; padding:0px 4px; font-size:0.78em; white-space:nowrap;">'
                    f'{_ce} {_cv:+.2f}</span>'
                )
            html_pred += " ".join(_chips) if _chips else '<span style="color:#555;">â€”</span>'
            html_pred += '</td>'

            # Reciprocity
            _recip_entry = _pairs_daily.get(_tname, {}).get(_lider_name, {})
            _recip_score = _recip_entry.get("score", 0) if _recip_entry else 0

            if _sc < 0 and _recip_score < 0:
                _rl, _rc = "âš”ï¸ MÃºtua", "#e74c3c"
            elif _sc < 0 and _recip_score >= 0:
                _rl, _rc = "ğŸ” Alvo cego", "#e67e22"
            elif _sc >= 0 and _recip_score < 0:
                _rl, _rc = "âš ï¸ Risco oculto", "#e67e22"
            else:
                _rl, _rc = "ğŸ’š Aliados", "#2ecc71"

            html_pred += f'<td class="cell-compact" style="white-space:nowrap;">'
            html_pred += f'<span style="color:{_rc}; font-size:0.85em;">{_rl}</span> '
            html_pred += f'<span class="text-muted" style="font-size:0.78em;">({_recip_score:+.2f})</span></td>'

            # Streak
            _si = "ğŸ”´" if _has_break else ("ğŸŸ¢" if _streak_len >= 5 else "âšª")
            _bt = ' <span style="color:#e74c3c; font-size:0.75em;">BREAK</span>' if _has_break else ""
            html_pred += f'<td class="cell-compact tc" style="white-space:nowrap;">{_si} {_streak_len}d{_bt}</td>'

            # VIP
            if _tname in _vip_list:
                html_pred += '<td class="cell-compact tc">'
                html_pred += '<span style="background:#3498db33; color:#3498db; border:1px solid #3498db55; '
                html_pred += 'border-radius:3px; padding:1px 5px; font-size:0.78em;">VIP</span></td>'
            else:
                html_pred += '<td class="cell-compact tc" style="color:#555;">â€”</td>'

            html_pred += '</tr>'

            # â”€â”€ Expandable detail row: edges + queridÃ´metro history â”€â”€â”€â”€
            _pair_edges = [e for e in _rel_edges if
                (e.get("actor") == _lider_name and e.get("target") == _tname) or
                (e.get("actor") == _tname and e.get("target") == _lider_name)]
            _pair_edges.sort(key=lambda e: e.get("date", ""))

            _hist_fwd = _querido_history.get((_lider_name, _tname), [])
            _hist_rev = _querido_history.get((_tname, _lider_name), [])

            if _pair_edges or _hist_fwd:
                html_pred += f'<tr style="{_row_bg}"><td colspan="8" style="padding:0;">'
                html_pred += '<details style="margin:0 0.4rem 0.4rem 1.8rem;">'
                html_pred += '<summary class="text-muted" style="cursor:pointer; font-size:0.78em; '
                html_pred += f'padding:0.2rem 0;">ğŸ“‹ {len(_pair_edges)} evento(s) Â· '
                html_pred += f'{len(_hist_fwd)} dia(s) de queridÃ´metro</summary>'
                html_pred += '<div style="display:flex; gap:1rem; flex-wrap:wrap; margin-top:0.4rem;">'

                # Edges sub-table
                if _pair_edges:
                    html_pred += '<div style="flex:1; min-width:280px;">'
                    html_pred += '<div style="color:#aaa; font-size:0.78em; margin-bottom:0.3rem;"><strong>Eventos & Edges</strong></div>'
                    html_pred += '<table class="table-full table-sm">'
                    html_pred += '<thead><tr class="sep-bottom">'
                    html_pred += '<th class="text-dim tl" style="padding:2px 4px;">Data</th>'
                    html_pred += '<th class="text-dim tl" style="padding:2px 4px;">Tipo</th>'
                    html_pred += '<th class="text-dim tl" style="padding:2px 4px;">DireÃ§Ã£o</th>'
                    html_pred += '<th class="text-dim tr" style="padding:2px 4px;">Peso</th>'
                    html_pred += '<th class="text-dim tl" style="padding:2px 4px;">Detalhe</th>'
                    html_pred += '</tr></thead><tbody>'
                    for _edge in _pair_edges:
                        _e_type = _edge.get("type", "?")
                        _e_actor = _edge.get("actor", "")
                        _e_weight = _edge.get("weight", 0)
                        _e_date = _edge.get("date", "?")
                        _e_emoji, _e_label = _edge_display.get(_e_type, ("â“", _e_type))
                        _e_wcolor = "#e74c3c" if _e_weight < 0 else "#2ecc71"
                        _is_backlash = _edge.get("backlash", False)
                        _arrow = f'{_e_actor.split()[0]} â†’ {(_tname if _e_actor == _lider_name else _lider_name).split()[0]}'
                        _detail_parts = []
                        if _edge.get("event_type"):
                            _detail_parts.append(_edge["event_type"])
                        if _edge.get("vote_kind"):
                            _detail_parts.append(_edge["vote_kind"])
                        if _is_backlash:
                            _detail_parts.append('<span style="color:#e67e22;">backlash</span>')
                        _detail_str = " Â· ".join(_detail_parts) if _detail_parts else "â€”"
                        html_pred += f'<tr style="border-bottom:1px solid #222;">'
                        html_pred += f'<td class="text-muted" style="padding:2px 4px; white-space:nowrap;">{_e_date}</td>'
                        html_pred += f'<td style="padding:2px 4px; white-space:nowrap;">{_e_emoji} {_e_label}</td>'
                        html_pred += f'<td style="padding:2px 4px; color:#aaa; font-size:0.9em;">{_arrow}</td>'
                        html_pred += f'<td class="tr" style="padding:2px 4px; color:{_e_wcolor}; font-family:monospace;">{_e_weight:+.2f}</td>'
                        html_pred += f'<td class="text-muted" style="padding:2px 4px;">{_detail_str}</td>'
                        html_pred += '</tr>'
                    html_pred += '</tbody></table></div>'

                # QueridÃ´metro timeline
                if _hist_fwd:
                    _all_dates = sorted(set(d for d, _ in _hist_fwd) | set(d for d, _ in _hist_rev))
                    _fwd_by_date = {d: lbl for d, lbl in _hist_fwd}
                    _rev_by_date = {d: lbl for d, lbl in _hist_rev}
                    _show_dates = _all_dates[-14:]

                    html_pred += '<div style="flex:1; min-width:240px;">'
                    html_pred += '<div style="color:#aaa; font-size:0.78em; margin-bottom:0.3rem;">'
                    html_pred += f'<strong>QueridÃ´metro</strong> (Ãºltimos {len(_show_dates)} dias)</div>'
                    html_pred += '<table class="table-full table-sm">'
                    html_pred += '<thead><tr class="sep-bottom">'
                    html_pred += f'<th class="text-dim tl" style="padding:2px 4px;">Data</th>'
                    html_pred += f'<th class="text-dim tc" style="padding:2px 4px;">{_lider_name.split()[0]}â†’</th>'
                    html_pred += f'<th class="text-dim tc" style="padding:2px 4px;">â†’{_lider_name.split()[0]}</th>'
                    html_pred += '</tr></thead><tbody>'
                    for _dt in _show_dates:
                        _fwd_lbl = _fwd_by_date.get(_dt, "")
                        _rev_lbl = _rev_by_date.get(_dt, "")
                        _fwd_e = _emoji_map.get(_fwd_lbl, "")
                        _rev_e = _emoji_map.get(_rev_lbl, "")
                        _fwd_sent = SENTIMENT_WEIGHTS.get(_fwd_lbl, 0)
                        _rev_sent = SENTIMENT_WEIGHTS.get(_rev_lbl, 0)
                        _fwd_c = "#2ecc71" if _fwd_sent > 0 else "#e74c3c" if _fwd_sent < -0.5 else "#e67e22" if _fwd_sent < 0 else "#555"
                        _rev_c = "#2ecc71" if _rev_sent > 0 else "#e74c3c" if _rev_sent < -0.5 else "#e67e22" if _rev_sent < 0 else "#555"
                        html_pred += f'<tr style="border-bottom:1px solid #222;">'
                        html_pred += f'<td class="text-muted" style="padding:1px 4px; font-size:0.9em;">{_dt[5:]}</td>'
                        html_pred += f'<td class="tc" style="padding:1px 4px; color:{_fwd_c};">{_fwd_e}</td>'
                        html_pred += f'<td class="tc" style="padding:1px 4px; color:{_rev_c};">{_rev_e}</td>'
                        html_pred += '</tr>'
                    html_pred += '</tbody></table></div>'

                html_pred += '</div></details></td></tr>'

        html_pred += '</tbody></table></div>'

        # â”€â”€ Methodology note â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        html_pred += '<div class="text-muted" style="background:#111; border:1px solid #333; border-radius:8px; '
        html_pred += 'padding:0.8rem 1rem; margin:1rem 0; font-size:0.82em;">'
        html_pred += '<strong style="color:#aaa;">ğŸ“ Metodologia</strong><br>'
        html_pred += 'A previsÃ£o Ã© baseada no <strong>score acumulado do LÃ­der â†’ cada participante</strong>, '
        html_pred += 'calculado pelo sistema de Sentiment Index (queridÃ´metro com memÃ³ria de streak + '
        html_pred += 'eventos de poder, SincerÃ£o, votos e VIP). O participante com o score mais negativo '
        html_pred += 'Ã© o alvo mais provÃ¡vel de indicaÃ§Ã£o. '
        html_pred += 'Membros do VIP foram escolhidos pelo LÃ­der, indicando alianÃ§a â€” sÃ£o alvos improvÃ¡veis. '
        html_pred += '<strong>Isto nÃ£o Ã© um modelo preditivo dedicado</strong> â€” Ã© uma leitura dos dados '
        html_pred += 'de relacionamento acumulados atÃ© o momento.'
        html_pred += '</div>'

    print(html_pred)
```

---

```{python}
#| label: paredao-per-nominee
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PER-NOMINEE ANALYSIS â€” Structured storytelling per nominee
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Uses precomputed data from paredao_analysis.json (built by build_derived_data.py).
# Each nominee gets their own section with context, votes, betrayals, blind spots.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

paredao_analysis_data = {}
_pa_path = Path("data/derived/paredao_analysis.json")
if _pa_path.exists():
    with open(_pa_path) as f:
        paredao_analysis_data = json.load(f)

# Load vote prediction data
_vp_path = Path("data/derived/vote_prediction.json")
vote_pred = json.loads(_vp_path.read_text(encoding="utf-8")) if _vp_path.exists() else {}

if ultimo and ultimo.get('participantes'):
    indicados_list = [p['nome'] for p in ultimo['participantes']]
    par_numero = str(ultimo.get('numero', ''))
    is_finalizado = ultimo.get('status') == 'finalizado'
    analysis_date = ultimo.get('data_formacao') or ultimo.get('data') or latest['date']

    # Load precomputed analysis
    pa_entry = paredao_analysis_data.get("by_paredao", {}).get(par_numero, {})
    qi = pa_entry.get("quick_insights", {})
    va = pa_entry.get("vote_analysis", [])
    vagg = pa_entry.get("vote_aggregates", {})
    per_nominee_data = pa_entry.get("per_nominee", {})
    indicator_reactions = pa_entry.get("indicator_reactions", [])
    rh = pa_entry.get("relationship_history", {})
    indicados_stats = qi.get("indicados_stats", [])

    # Vote prediction data
    vp_entry = vote_pred.get("by_paredao", {}).get(par_numero, {})
    vp_predictions = vp_entry.get("predictions", {})
    vp_aggregate = vp_entry.get("aggregate", {})
    vp_retro = vp_entry.get("retrospective", {})

    votos = ultimo.get('votos_casa', {}) or {}

    # Classify votes into lists
    betrayals = [v for v in va if v["tipo"] in ("falso_amigo", "aliados_mutuos")]
    blind_spots = [v for v in va if v["tipo"] == "ponto_cego"]

    n_traicoes = vagg.get("n_traicoes", 0)
    n_pontos_cegos = vagg.get("n_pontos_cegos", 0)
    n_esperados = vagg.get("n_esperados", 0)
    total_votes = vagg.get("total_votes", 0)
    rel_counts = vagg.get("relationship_counts", {})

    if is_finalizado:
        analysis_date_label = f"ğŸ“… Dados de **{qi.get('analysis_date', analysis_date)}** (dia da formaÃ§Ã£o)"
    else:
        analysis_date_label = f"ğŸ“… Dados de **{latest['label']}** (atual)"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SECTION 1: A HistÃ³ria do NÂº ParedÃ£o (global brief narrative)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print(f"## ğŸ“– A HistÃ³ria do {ultimo['numero']}Âº ParedÃ£o\n")

    if is_finalizado:
        print(f'<div class="alert alert-secondary" style="font-size: 0.9rem;">')
        print(f'{analysis_date_label} â€” anÃ¡lise histÃ³rica congelada no momento da formaÃ§Ã£o.')
        print(f'</div>\n')

    # Opening narrative
    if total_votes > 0:
        if n_traicoes >= 3:
            print(f"Um paredÃ£o marcado por **{n_traicoes} traiÃ§Ãµes** â€” votos de quem dava â¤ï¸ ao alvo no queridÃ´metro. ")
            print(f"A dissimulaÃ§Ã£o dominou a votaÃ§Ã£o da casa.\n")
        elif n_pontos_cegos >= 3:
            print(f"Um paredÃ£o de **pontos cegos** â€” {n_pontos_cegos} votos de pessoas que o alvo considerava aliadas, ")
            print(f"mas que secretamente davam reaÃ§Ãµes negativas.\n")
        elif n_esperados >= total_votes * 0.5:
            print(f"Uma votaÃ§Ã£o **previsÃ­vel**: {n_esperados} de {total_votes} votos ({n_esperados*100//total_votes}%) ")
            print(f"vieram de quem jÃ¡ dava reaÃ§Ãµes negativas no queridÃ´metro.\n")
        else:
            print(f"Uma votaÃ§Ã£o **estratÃ©gica** â€” a mistura de traiÃ§Ãµes ({n_traicoes}), pontos cegos ({n_pontos_cegos}) ")
            print(f"e votos esperados ({n_esperados}) revela um jogo complexo.\n")

        # Coherence one-liner
        n_aligned = sum(1 for v in va if v["tipo"] in ("inimigos_declarados", "hostilidade_forte", "hostilidade_leve"))
        pct_aligned = (n_aligned / total_votes * 100) if total_votes else 0
        print(f"**CoerÃªncia social:** {n_aligned}/{total_votes} votos ({pct_aligned:.0f}%) estavam alinhados com o queridÃ´metro.\n")

        # Model accuracy summary
        if vp_retro and is_finalizado:
            vp_ind = vp_retro.get("individual", {})
            vp_hc = vp_retro.get("high_confidence", {})
            if vp_ind.get("total", 0) > 0:
                print(f"ğŸ¤– **PrevisÃ£o do modelo:** acertou {vp_ind['correct']}/{vp_ind['total']} votos ({vp_ind['pct']:.1f}%)", end="")
                if vp_hc.get("total", 0) > 0:
                    print(f" Â· Alta confianÃ§a: {vp_hc['correct']}/{vp_hc['total']} ({vp_hc['pct']:.1f}%)")
                else:
                    print()
                print()

                # Side-by-side predicted vs actual vote concentration (compact HTML bars)
                vote_concentration = vp_aggregate.get("vote_concentration", {})
                actual_votes = Counter(votos.values()) if votos else {}
                all_targets = sorted(set(list(vote_concentration.keys()) + list(actual_votes.keys())),
                                     key=lambda n: -(vote_concentration.get(n, 0) + actual_votes.get(n, 0)))
                if all_targets and actual_votes:
                    max_count = max(max(vote_concentration.values(), default=1), max(actual_votes.values(), default=1))
                    print('<div style="display:flex; gap:2rem; flex-wrap:wrap; margin-bottom:1rem;">')
                    # Predicted
                    print('<div style="flex:1; min-width:250px;">')
                    print('<div class="text-muted" style="font-size:0.85em; margin-bottom:4px;">ğŸ“Š PrevisÃ£o do modelo</div>')
                    for tgt in all_targets[:6]:
                        cnt = vote_concentration.get(tgt, 0)
                        pct_bar = (cnt / max_count * 100) if max_count else 0
                        print(f'<div style="display:flex; align-items:center; gap:6px; margin:2px 0;">')
                        print(f'<span style="width:80px; font-size:0.8em; text-align:right;">{tgt.split()[0]}</span>')
                        print(f'<div style="flex:1; background:#333; border-radius:3px; height:14px;">')
                        print(f'<div style="width:{pct_bar}%; background:#9b59b6; height:100%; border-radius:3px;"></div></div>')
                        print(f'<span style="font-size:0.8em; width:20px;">{cnt}</span></div>')
                    print('</div>')
                    # Actual
                    print('<div style="flex:1; min-width:250px;">')
                    print('<div class="text-muted" style="font-size:0.85em; margin-bottom:4px;">ğŸ—³ï¸ VotaÃ§Ã£o real</div>')
                    for tgt in all_targets[:6]:
                        cnt = actual_votes.get(tgt, 0)
                        pct_bar = (cnt / max_count * 100) if max_count else 0
                        print(f'<div style="display:flex; align-items:center; gap:6px; margin:2px 0;">')
                        print(f'<span style="width:80px; font-size:0.8em; text-align:right;">{tgt.split()[0]}</span>')
                        print(f'<div style="flex:1; background:#333; border-radius:3px; height:14px;">')
                        print(f'<div style="width:{pct_bar}%; background:#3498db; height:100%; border-radius:3px;"></div></div>')
                        print(f'<span style="font-size:0.8em; width:20px;">{cnt}</span></div>')
                    print('</div>')
                    print('</div>\n')
        # Scatter insight as narrative
        if pct_aligned >= 60:
            print(f"Os votos **seguiram** as reaÃ§Ãµes â€” a maioria votou conforme o queridÃ´metro sugeria.\n")
        elif pct_aligned <= 30:
            print(f"Os votos **nÃ£o seguiram** as reaÃ§Ãµes â€” muita divergÃªncia entre queridÃ´metro e urna.\n")
        else:
            print(f"Resultado misto: parte dos votos seguiu o queridÃ´metro, parte foi por estratÃ©gia.\n")
    else:
        print("Aguardando votaÃ§Ã£o da casa para anÃ¡lise completa.\n")

        # em_andamento: show predictions even before house votes
        if vp_predictions and not is_finalizado:
            vote_concentration = vp_aggregate.get("vote_concentration", {})
            if vote_concentration:
                top_predicted = max(vote_concentration, key=vote_concentration.get)
                print(f"ğŸ¤– **PrevisÃ£o do modelo:** {vote_concentration[top_predicted]} votos previstos para {top_predicted}.\n")

    # â”€â”€ Fatos Interessantes (data-driven insights) â”€â”€
    if total_votes > 0 and votos:
        facts = []

        # Get formation-date snapshot for queridÃ´metro analysis
        _fi_date = ultimo.get('data_formacao') or ultimo.get('data') or latest['date']
        _fi_snap_idx = None
        for _fii, _fis in enumerate(daily_snapshots):
            if _fis['date'] <= _fi_date:
                _fi_snap_idx = _fii
        _fi_matrix = daily_matrices[_fi_snap_idx] if _fi_snap_idx is not None else daily_matrices[-1]

        # Fact 1: Bloc coordination â€” check if voting bloc has >70% same group
        contagem_fi = Counter(votos.values())
        for alvo_fi, n_votos_fi in contagem_fi.most_common():
            votantes_fi = [v for v, a in votos.items() if a == alvo_fi]
            if len(votantes_fi) >= 3:
                grupo_counts = Counter(MEMBER_OF.get(v, '?') for v in votantes_fi)
                top_grupo, top_count = grupo_counts.most_common(1)[0]
                if top_count / len(votantes_fi) > 0.7 and top_count >= 3:
                    facts.append(f"ğŸ“Œ **Bloco coordenado:** {top_count} dos {len(votantes_fi)} votos em {alvo_fi} vieram do grupo **{top_grupo}**.")

        # Fact 2: Sincerinho vs Vote alignment
        _formacao_raw_fi = ultimo.get('formacao_raw', {})
        _duelo_fi = _formacao_raw_fi.get('duelo_de_risco') if isinstance(_formacao_raw_fi, dict) else None
        if _duelo_fi and _duelo_fi.get('escolhas'):
            _esc_fi = _duelo_fi['escolhas']
            sinc_vote_same = sum(1 for v in votos if v in _esc_fi and _esc_fi[v]['alvo'] == votos[v])
            sinc_total_fi = sum(1 for v in votos if v in _esc_fi)
            if sinc_total_fi > 0 and sinc_vote_same >= 2:
                facts.append(f"ğŸ”— **Sincerinho â†’ Voto:** {sinc_vote_same} participantes votaram no mesmo adversÃ¡rio que jÃ¡ haviam escolhido no Sincerinho.")

        # Fact 3: Longest betrayal â€” who gave â¤ï¸ the longest before voting against
        longest_betrayal = None
        longest_days = 0
        for v_item in va:
            if v_item.get('tipo') in ('falso_amigo', 'aliados_mutuos') and v_item.get('days_as_friends', 0) > 5:
                if v_item['days_as_friends'] > longest_days:
                    longest_days = v_item['days_as_friends']
                    longest_betrayal = v_item
        if longest_betrayal:
            facts.append(f"ğŸ—¡ï¸ **Maior traiÃ§Ã£o:** {longest_betrayal['votante']} dava â¤ï¸ por **{longest_days} dias consecutivos** antes de votar contra {longest_betrayal['alvo']}.")

        # Fact 4: Contragolpe reaction analysis
        if ultimo.get('contragolpe'):
            cg_fi = ultimo['contragolpe']
            cg_de = cg_fi.get('de', '')
            cg_para = cg_fi.get('para', '')
            if cg_de and cg_para:
                r_fwd = _fi_matrix.get((cg_de, cg_para), '')
                r_rev = _fi_matrix.get((cg_para, cg_de), '')
                emoji_fwd = REACTION_EMOJI.get(r_fwd, '?') if r_fwd else '?'
                emoji_rev = REACTION_EMOJI.get(r_rev, '?') if r_rev else '?'
                if r_fwd and r_rev:
                    both_neg = (r_fwd in (MILD_NEGATIVE | STRONG_NEGATIVE)) and (r_rev in (MILD_NEGATIVE | STRONG_NEGATIVE))
                    both_pos = (r_fwd in POSITIVE) and (r_rev in POSITIVE)
                    if both_neg:
                        facts.append(f"ğŸŒ€ **Contragolpe:** {cg_de} contragolpeou {cg_para} â€” ambos davam {emoji_fwd}/{emoji_rev} um ao outro (hostilidade mÃºtua).")
                    elif both_pos:
                        facts.append(f"ğŸ’” **Contragolpe surpresa:** {cg_de} contragolpeou {cg_para} â€” ambos davam â¤ï¸ um ao outro. TraiÃ§Ã£o inesperada.")
                    else:
                        facts.append(f"ğŸŒ€ **Contragolpe:** {cg_de} ({emoji_fwd}) contragolpeou {cg_para} ({emoji_rev}).")

        # Fact 5: Bate e Volta irony
        bv_fi = ultimo.get('bate_volta') or ultimo.get('formacao_raw', {}).get('bate_volta')
        if bv_fi and bv_fi.get('vencedor'):
            bv_winner = bv_fi['vencedor']
            # Check if the BV winner was specifically targeted via dinÃ¢mica/duelo
            _duelo_target = None
            if _duelo_fi and _duelo_fi.get('indicado_consenso'):
                _duelo_target = _duelo_fi['indicado_consenso']
            if _duelo_target and bv_winner == _duelo_target:
                facts.append(f"ğŸƒ **Bate e Volta:** {bv_winner}, indicad{'a' if genero(bv_winner) == 'f' else 'o'} por consenso no Duelo de Risco, **escapou** na Bate e Volta â€” o duelo nÃ£o funcionou como planejado.")

        if facts:
            print("\n### ğŸ’¡ Fatos Interessantes\n")
            print('<div style="background:linear-gradient(145deg, rgba(52,152,219,0.08), rgba(155,89,182,0.08)); border:1px solid rgba(52,152,219,0.3); border-radius:10px; padding:1rem; margin:1rem 0;">')
            for fact in facts:
                print(f'<p style="margin:0.5rem 0; font-size:0.95rem;">{fact}</p>')
            print('</div>\n')

    # â”€â”€ Anatomia dos Votos chart (keep) â”€â”€
    if total_votes > 0 and rel_counts:
        print("### Anatomia dos Votos\n")
        rel_order = [
            ('aliados_mutuos', 'ğŸ’” TraiÃ§Ã£o de Aliado', '#9b59b6'),
            ('falso_amigo', 'ğŸ­ Falso Amigo', '#E6194B'),
            ('ponto_cego', 'ğŸ¯ Ponto Cego', '#f39c12'),
            ('inimigos_declarados', 'âš”ï¸ Hostilidade MÃºtua', '#3CB44B'),
            ('hostilidade_forte', 'ğŸ Hostilidade Forte', '#3CB44B'),
            ('hostilidade_leve', 'ğŸŒ± Hostilidade Leve', '#FF9800'),
            ('neutro', 'â“ Neutro', '#999'),
        ]
        labels_chart = []
        values_chart = []
        colors_chart = []
        for tipo, label, cor in rel_order:
            count = rel_counts.get(tipo, 0)
            if count > 0:
                labels_chart.append(label)
                values_chart.append(count)
                colors_chart.append(cor)

        if labels_chart:
            fig_anat = go.Figure(go.Bar(
                y=labels_chart[::-1], x=values_chart[::-1],
                orientation='h',
                marker_color=colors_chart[::-1],
                text=[str(v) for v in values_chart[::-1]],
                textposition='auto',
                textfont=dict(size=14, color='white'),
            ))
            fig_anat.update_layout(
                title="DistribuiÃ§Ã£o dos Votos por Tipo de Relacionamento",
                xaxis_title="NÃºmero de Votos", yaxis_title="",
                height=max(250, 60 * len(labels_chart)),
                margin=dict(l=200),
                showlegend=False,
            )
            fig_anat.show()
            print()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SECTION 2: Per-Nominee Loop
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Build the complete nominees list including BV survivors
    all_nominees = list(ultimo.get('participantes', []))
    bv = ultimo.get('bate_volta') or {}
    bv_survivors = set()
    bv_winners = bv.get('vencedores') or ([bv['vencedor']] if bv.get('vencedor') else [])
    if bv_winners:
        bv_survivors = set(bv_winners)
        existing_names = {p['nome'] for p in all_nominees}
        for bv_name in bv_winners:
            if bv_name not in existing_names:
                all_nominees.append({
                    'nome': bv_name,
                    'grupo': MEMBER_OF.get(bv_name, '?'),
                    'como': 'Bate e Volta (escapou)',
                    '_bv_escapee': True,
                })

    # Sort: eliminado first â†’ by house votes desc â†’ BV survivors last
    resultado = ultimo.get('resultado', {}) if is_finalizado else {}
    eliminado_nome = resultado.get('eliminado', '') if resultado else ''

    def _nominee_sort_key(p):
        nome = p['nome']
        if nome == eliminado_nome:
            return (0, 0, nome)
        if p.get('_bv_escapee'):
            return (2, 0, nome)
        pn = per_nominee_data.get(nome, {})
        return (1, -pn.get('n_votes', 0), nome)

    all_nominees.sort(key=_nominee_sort_key)

    for nominee in all_nominees:
        nome = nominee['nome']
        grupo = nominee.get('grupo', MEMBER_OF.get(nome, '?'))
        como = nominee.get('como', '')
        is_bv_escapee = nominee.get('_bv_escapee', False)
        pn = per_nominee_data.get(nome, {})

        # â”€â”€ A. Header + Context â”€â”€
        badge_text, badge_color, badge_emoji = get_nominee_badge(nome, ultimo, bv_survivors)
        grupo_color = GROUP_COLORS.get(grupo, '#888')

        print(f"\n### {badge_emoji} O Caso {nome}\n")
        print(f'<div style="display:flex; align-items:center; gap:16px; margin-bottom:12px;">')
        print(f'{avatar_img(nome, AVATARS, 64)}')
        print(f'<div>')
        print(f'<span style="background:{badge_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.95em;">{badge_text}</span>')
        print(f' <span style="color:{grupo_color}; font-weight:500; margin-left:8px;">{grupo}</span>')
        print(f'</div></div>\n')

        # How they got there
        if como:
            print(f"**Como chegou ao paredÃ£o:** {como}\n")

        # Vote percentages (if finalized)
        if is_finalizado and not is_bv_escapee:
            votos_part = resultado.get('votos', {}).get(nome, {})
            if votos_part:
                vu = votos_part.get('voto_unico', 0)
                vt = votos_part.get('voto_torcida', 0)
                vtotal = votos_part.get('voto_total', 0)
                print(f"**Resultado:** Voto Ãšnico {vu:.2f}% Â· Torcida {vt:.2f}% Â· **MÃ©dia Final {vtotal:.2f}%**\n")

        # â”€â”€ B. IndicaÃ§Ã£o Analysis (only for power-indicated nominees) â”€â”€
        # Detect indicator type from 'como' field
        nominee_indicators = [ir for ir in indicator_reactions if ir['target'] == nome]

        if nominee_indicators:
            for ir in nominee_indicators:
                actor = ir['actor']
                ind_type = ir['type']
                type_labels = {'lider': 'ğŸ‘‘ IndicaÃ§Ã£o do LÃ­der', 'contragolpe': 'ğŸŒ€ Contragolpe',
                               'big_fone': 'ğŸ“ Big Fone', 'dinamica': 'ğŸ² DinÃ¢mica'}
                type_label = type_labels.get(ind_type, ind_type.replace('_', ' ').title())

                print(f"#### {type_label}\n")
                print(f"**{actor}** indicou **{nome}**.\n")

                # Bidirectional reaction table
                a2t = ir.get('actor_to_target', '?')
                t2a = ir.get('target_to_actor', '?')
                print('<table class="table" style="max-width:500px; font-size:1.05rem;">')
                print(f'<thead><tr><th>DireÃ§Ã£o</th><th class="tc">ReaÃ§Ã£o</th></tr></thead>')
                print(f'<tbody>')
                print(f'<tr><td>{avatar_html(actor, AVATARS, 28)} â†’ {nome}</td><td class="tc" style="font-size:1.3em;">{a2t}</td></tr>')
                print(f'<tr><td>{avatar_html(nome, AVATARS, 28)} â†’ {actor}</td><td class="tc" style="font-size:1.3em;">{t2a}</td></tr>')
                print(f'</tbody></table>\n')

                # Relationship classification
                a2t_raw = ir.get('actor_to_target_raw', '')
                t2a_raw = ir.get('target_to_actor_raw', '')
                a_pos = a2t_raw in POSITIVE
                t_pos = t2a_raw in POSITIVE
                a_neg = a2t_raw in (MILD_NEGATIVE | STRONG_NEGATIVE)
                t_neg = t2a_raw in (MILD_NEGATIVE | STRONG_NEGATIVE)

                if a_pos and t_pos:
                    print(f"ğŸ’” **Aliados mÃºtuos** â€” ambos davam â¤ï¸. IndicaÃ§Ã£o surpreendente.\n")
                elif a_neg and t_neg:
                    print(f"âš”ï¸ **Hostilidade mÃºtua** â€” ambos davam negativo. IndicaÃ§Ã£o esperada.\n")
                elif a_neg and t_pos:
                    print(f"ğŸ¯ **Ponto cego** â€” {nome} dava â¤ï¸ a {actor}, que secretamente dava negativo. {nome} nÃ£o via vir.\n")
                elif a_pos and t_neg:
                    print(f"ğŸ­ **Falso amigo** â€” {actor} dava â¤ï¸ a {nome} mas indicou mesmo assim. TraiÃ§Ã£o.\n")
                elif a_neg:
                    print(f"ğŸ **Hostilidade unilateral** â€” {actor} dava negativo. IndicaÃ§Ã£o coerente com o queridÃ´metro.\n")
                else:
                    print(f"â“ RelaÃ§Ã£o neutra ou sem dados claros no queridÃ´metro.\n")

                # Historical pattern
                key_fwd = f"{actor}â†’{nome}"
                hist = rh.get(key_fwd, {})
                if hist.get('pattern') and hist['pattern'] != 'sem_dados':
                    print(f"**HistÃ³rico:** {hist.get('narrative', '')}\n")

        # â”€â”€ C. QueridÃ´metro Snapshot â”€â”€
        stat = next((s for s in indicados_stats if s['nome'] == nome), None)
        if stat:
            print(f"#### ğŸ“Š QueridÃ´metro\n")
            sent_val = stat['sentimento']
            sent_color = '#4CAF50' if sent_val >= 0 else '#E6194B'
            delta = stat.get('delta_3d', 'â€”')
            delta_color = '#4CAF50' if 'â–²' in str(delta) or '+' in str(delta) else ('#E6194B' if 'â–¼' in str(delta) else '#888')

            print('<table class="table" style="max-width:600px; font-size:1.0rem;">')
            print('<thead><tr><th>Sentimento</th><th>Rank</th><th>Î” 3 dias</th><th>Top 5</th><th>Bottom 5</th><th>Dias neg.</th></tr></thead>')
            print(f'<tbody><tr>')
            print(f'<td style="color:{sent_color}; font-weight:bold; font-size:1.1em;">{sent_val:+.1f}</td>')
            print(f'<td>{stat.get("rank", "â€”")}</td>')
            print(f'<td style="color:{delta_color}; font-weight:500;">{delta}</td>')
            print(f'<td>{stat.get("dias_top5", 0)}</td>')
            print(f'<td>{stat.get("dias_bottom5", 0)}</td>')
            print(f'<td>{stat.get("dias_negativos", "â€”")}</td>')
            print(f'</tr></tbody></table>\n')

        # â”€â”€ D. Quem Votou em [Name]? â”€â”€
        votes_for_nominee = [v for v in va if v['alvo'] == nome]
        n_votes = pn.get('n_votes', len(votes_for_nominee))
        n_enemies = pn.get('from_enemies', 0)
        n_traitors = pn.get('from_traitors', 0)
        n_blind = pn.get('from_blind', 0)

        # Pre-compute prediction metrics (used in summary + conclusion)
        vp_predicted_votes_for = vp_aggregate.get("vote_concentration", {}).get(nome, 0) if vp_predictions else 0
        vp_correct_for_nominee = sum(
            1 for v in votes_for_nominee
            if vp_predictions.get(v['votante'], {}).get('predicted') == nome
        ) if vp_predictions else 0
        vp_surprise_votes = n_votes - vp_correct_for_nominee

        if n_votes > 0:

            print(f"#### ğŸ—³ï¸ Quem Votou em {nome}?\n")
            print(f"**{n_votes} votos** recebidos", end="")
            parts = []
            if n_enemies:
                parts.append(f"{n_enemies} de inimigos")
            if n_traitors:
                parts.append(f"{n_traitors} traiÃ§Ãµes")
            if n_blind:
                parts.append(f"{n_blind} pontos cegos")
            if parts:
                print(f" â€” {', '.join(parts)}.", end="")
            print("\n")

            # Per-nominee prediction summary
            if vp_predictions and is_finalizado and (vp_predicted_votes_for > 0 or vp_correct_for_nominee > 0):
                if vp_predicted_votes_for == n_votes:
                    print(f"O modelo previa {vp_predicted_votes_for} votos para {nome} (real: {n_votes}) â€” acertou {vp_correct_for_nominee} dos {n_votes} votantes.\n")
                elif vp_predicted_votes_for > n_votes:
                    print(f"O modelo previa {vp_predicted_votes_for} votos para {nome} (real: {n_votes}) â€” superestimou a rejeiÃ§Ã£o.\n")
                else:
                    if vp_surprise_votes > 0:
                        print(f"O modelo previa {vp_predicted_votes_for} votos para {nome} (real: {n_votes}) â€” {vp_surprise_votes} voto(s) surpresa.\n")
                    else:
                        print(f"O modelo previa {vp_predicted_votes_for} votos para {nome} (real: {n_votes}).\n")

            # Voter table
            has_vp = bool(vp_predictions)
            print('<table class="table table-striped" style="max-width:850px; font-size:1.0rem;">')
            print('<thead><tr><th>Votante</th><th class="tc">Deu</th><th class="tc">Recebeu</th><th>Tipo</th><th>HistÃ³rico</th>', end="")
            if has_vp:
                print('<th class="tc">Prev.</th>', end="")
            print('</tr></thead>')
            print('<tbody>')

            pattern_emoji = {
                'sempre_amigos': 'ğŸ’š', 'sempre_inimigos': 'ğŸ’€', 'ex_amigos': 'ğŸ’”',
                'recem_inimigos': 'âš¡', 'reconciliados': 'ğŸ•Šï¸', 'instavel': 'ğŸ”„', 'sem_dados': 'â€”',
            }

            for v in votes_for_nominee:
                votante = v['votante']
                emoji_dado = v.get('emoji_dado', '?')
                emoji_recebido = v.get('emoji_recebido', '?')
                tipo_label = v.get('label', '?')
                hist_pat = v.get('hist_pattern', 'sem_dados')
                hist_emoji = pattern_emoji.get(hist_pat, 'â€”')
                hist_narr = v.get('hist_narrative', '')
                print(f'<tr>')
                print(f'<td>{avatar_html(votante, AVATARS, 28)}</td>')
                print(f'<td class="tc" style="font-size:1.2em;">{emoji_dado}</td>')
                print(f'<td class="tc" style="font-size:1.2em;">{emoji_recebido}</td>')
                print(f'<td style="font-size:0.9em;">{tipo_label}</td>')
                print(f'<td style="font-size:0.85em;" title="{hist_narr}">{hist_emoji} {hist_narr}</td>')
                if has_vp:
                    pred = vp_predictions.get(votante, {})
                    if not pred:
                        print(f'<td class="tc text-dim">â€”</td>')
                    elif pred.get('predicted') == nome:
                        conf = pred.get('confidence', '')
                        print(f'<td class="tc" style="color:#3CB44B; font-size:0.85em;">âœ… {conf}</td>')
                    else:
                        pred_target = pred.get('predicted', '?')
                        short_name = pred_target.split()[0]
                        print(f'<td class="tc" style="color:#E6194B; font-size:0.85em;">âŒâ†’{short_name}</td>')
                print(f'</tr>')
            print('</tbody></table>\n')
        elif not is_bv_escapee:
            print(f"*{nome} nÃ£o recebeu votos da casa â€” chegou ao paredÃ£o por indicaÃ§Ã£o direta.*\n")

        # â”€â”€ E. Destaques (conditional) â”€â”€
        nominee_betrayals = [v for v in betrayals if v['alvo'] == nome]
        nominee_blind = [v for v in blind_spots if v['alvo'] == nome]
        # Temporal insights: ex-amigos/recem-inimigos NOT already in betrayals/blind_spots
        betrayal_voters = {v['votante'] for v in nominee_betrayals}
        blind_voters = {v['votante'] for v in nominee_blind}
        nominee_temporal = [v for v in votes_for_nominee
                           if v.get('hist_pattern') in ('ex_amigos', 'recem_inimigos')
                           and v['votante'] not in betrayal_voters
                           and v['votante'] not in blind_voters]

        has_highlights = nominee_betrayals or nominee_blind or nominee_temporal
        if has_highlights:
            print(f"#### Destaques\n")
            for b in nominee_betrayals:
                pat = b.get('hist_pattern', '')
                votante = b['votante']
                cd = b.get('change_date') or ''
                if pat == 'sempre_amigos':
                    print(f"- ğŸ—¡ï¸ **TraiÃ§Ã£o de longa data:** {votante} dava â¤ï¸ por {b.get('days_as_friends', '?')} dias e mesmo assim votou contra")
                elif pat == 'ex_amigos' and cd:
                    print(f"- ğŸ’” **Ex-amigos:** {votante} e {nome} eram aliados, romperam em {cd}")
                else:
                    print(f"- ğŸ’” **TraiÃ§Ã£o:** {votante} dava â¤ï¸ a {nome} mas votou contra")
            for bs in nominee_blind:
                print(f"- ğŸ¯ **Ponto cego:** {nome} dava â¤ï¸ a {bs['votante']}, que secretamente dava {bs.get('emoji_dado', '?')}")
            # Temporal: summarize if many (>3), list individually if few
            if len(nominee_temporal) > 3:
                ex_names = [t['votante'] for t in nominee_temporal if t.get('hist_pattern') == 'ex_amigos']
                rec_names = [t['votante'] for t in nominee_temporal if t.get('hist_pattern') == 'recem_inimigos']
                if ex_names:
                    print(f"- ğŸ’” **{len(ex_names)} ex-amigos** votaram contra: {', '.join(ex_names)}")
                if rec_names:
                    print(f"- âš¡ **{len(rec_names)} mudanÃ§as recentes**: {', '.join(rec_names)}")
            else:
                for t in nominee_temporal:
                    cd = t.get('change_date') or ''
                    if t.get('hist_pattern') == 'recem_inimigos':
                        print(f"- âš¡ **MudanÃ§a recente:** {t['votante']} mudou de â¤ï¸ para negativo hÃ¡ pouco tempo")
                    elif t.get('hist_pattern') == 'ex_amigos' and cd:
                        print(f"- ğŸ’” **Ex-amigos:** {t['votante']} rompeu com {nome} em {cd}")
                    elif t.get('hist_pattern') == 'ex_amigos':
                        print(f"- ğŸ’” **Ex-amigos:** {t['votante']} e {nome} se afastaram")
            print()

        # â”€â”€ F. Narrative Conclusion â”€â”€
        if n_votes > 0:
            if n_traitors >= n_votes * 0.5 and n_traitors >= 2:
                sufixo = 'a' if genero(nome) == 'f' else 'o'
                print(f"**ConclusÃ£o:** {nome} foi **apunhalad{sufixo} pelas costas** â€” mais da metade dos votos veio de quem dava â¤ï¸ no queridÃ´metro.\n")
            elif n_blind >= 2:
                print(f"**ConclusÃ£o:** {nome} **nÃ£o viu seus inimigos chegando** â€” {n_blind} votos de pessoas que {artigo(nome)} considerava aliadas.\n")
            elif n_enemies >= n_votes * 0.7:
                print(f"**ConclusÃ£o:** {nome} foi **alvo previsÃ­vel** â€” a maioria dos votos veio de quem jÃ¡ dava negativo no queridÃ´metro.\n")
            else:
                print(f"**ConclusÃ£o:** VotaÃ§Ã£o mista para {nome} â€” combinaÃ§Ã£o de inimizades, estratÃ©gia e contradiÃ§Ãµes.\n")

            # Prediction context in conclusion
            if vp_predictions and is_finalizado:
                if vp_correct_for_nominee >= n_votes * 0.8:
                    print(f"*ğŸ¤– O modelo previu com precisÃ£o a maioria dos votos â€” resultado coerente com o queridÃ´metro.*\n")
                elif vp_surprise_votes >= 3:
                    print(f"*ğŸ¤– {vp_surprise_votes} votos nÃ£o previstos pelo modelo sugerem coordenaÃ§Ã£o estratÃ©gica ou alianÃ§as nÃ£o capturadas pelo queridÃ´metro.*\n")
                elif vp_predicted_votes_for > n_votes + 2:
                    over = vp_predicted_votes_for - n_votes
                    print(f"*ğŸ¤– O modelo superestimou a rejeiÃ§Ã£o â€” {over} votantes que pareciam inimigos pelo queridÃ´metro votaram em outro alvo.*\n")
        elif is_bv_escapee:
            sufixo = 'a' if genero(nome) == 'f' else 'o'
            print(f"**ConclusÃ£o:** {nome} **escapou pelo Bate e Volta** â€” foi indicad{sufixo} mas venceu a prova e saiu do paredÃ£o.\n")
        else:
            sufixo = 'a' if genero(nome) == 'f' else 'o'
            print(f"**ConclusÃ£o:** {nome} chegou ao paredÃ£o **apenas por indicaÃ§Ã£o direta** â€” sem votos da casa.\n")

else:
    print("*Aguardando dados do paredÃ£o para anÃ¡lise.*")

```

---

::: {.callout-note title="ğŸ“š Ver mais" appearance="simple"}
Quer ver os paredÃµes anteriores? Acesse o **[Arquivo de ParedÃµes](paredoes.html)** com votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o.
:::

::: {.callout-caution title="â„¹ï¸ Sobre os dados (limitaÃ§Ãµes e melhorias)" appearance="minimal" collapse="true"}
- **Data de formaÃ§Ã£o**: a anÃ¡lise usa o queridÃ´metro do **dia da formaÃ§Ã£o** (`data_formacao`). Se faltou snapshot do dia, usamos o mais prÃ³ximo anterior.
- **QueridÃ´metro Ã© privado**: contradiÃ§Ãµes nÃ£o significam falsidade â€” podem ser **estratÃ©gia** (consenso, alvo fÃ¡cil, proteÃ§Ã£o de aliados).
- **Emojis leves** (ğŸŒ±ğŸ’¼ğŸªğŸ’”) sÃ£o negativos mas nÃ£o equivalem a hostilidade forte.  
  **Melhoria prevista**: ponderar mais forte ğŸğŸ¯ğŸ¤®ğŸ¤¥ e reduzir peso de negativos leves nas leituras de coerÃªncia.
- **Timing do jogo**: entre eliminaÃ§Ã£o e nova lideranÃ§a, as relaÃ§Ãµes podem mudar rÃ¡pido.  
  **Melhoria prevista**: permitir â€œmÃ©dia mÃ³velâ€ de 2â€“3 dias na semana da formaÃ§Ã£o.
:::

::: {.callout-tip title="ğŸ§­ NavegaÃ§Ã£o"}
- [ğŸ“Š Painel](index.html) â€” Estado atual das reaÃ§Ãµes
- [ğŸ“ˆ EvoluÃ§Ã£o](evolucao.html) â€” Rankings, sentimento e pulso diÃ¡rio
- [ğŸ¤ RelaÃ§Ãµes](relacoes.html) â€” Mapa social, alianÃ§as e rivalidades
- [ğŸ“š Arquivo](paredoes.html) â€” HistÃ³rico de paredÃµes
:::
