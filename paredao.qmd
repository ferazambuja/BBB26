---
title: "BBB 26 â€” ParedÃ£o"
subtitle: "Acompanhe o paredÃ£o atual: formaÃ§Ã£o, votaÃ§Ã£o e anÃ¡lise de reaÃ§Ãµes"
author: "Dashboard Automatizado"
date: today
lang: pt-BR
format:
  html:
    code-fold: true
    code-summary: "Ver cÃ³digo"
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

REACTION_SLUG_TO_LABEL = {
    'coracao': 'CoraÃ§Ã£o', 'planta': 'Planta', 'mala': 'Mala', 'biscoito': 'Biscoito',
    'cobra': 'Cobra', 'alvo': 'Alvo', 'vomito': 'VÃ´mito', 'mentiroso': 'Mentiroso',
    'coracao-partido': 'CoraÃ§Ã£o partido'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0,
    'CoraÃ§Ã£o partido': -0.5  # Mild negative (disappointment, not hostility)
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito', 'CoraÃ§Ã£o partido'}  # ğŸ’” = disappointment, not hostility
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}  # preenchido ao carregar dados

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Plotly Dark Theme Configuration (matches Bootswatch darkly)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PLOT_BG = '#303030'  # Darkly body background
PAPER_BG = '#303030'
GRID_COLOR = '#444444'
TEXT_COLOR = '#fff'

# Standard layout applied to ALL plots
import plotly.io as pio

pio.templates['bbb_dark'] = go.layout.Template(
    layout=go.Layout(
        paper_bgcolor=PAPER_BG,
        plot_bgcolor=PLOT_BG,
        font=dict(color=TEXT_COLOR, family='Lato, -apple-system, sans-serif', size=13),
        title=dict(font=dict(size=16), x=0.5, xanchor='center', y=0.95),
        margin=dict(l=70, r=30, t=70, b=60),
        xaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        yaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        legend=dict(
            bgcolor='rgba(0,0,0,0)',
            bordercolor='rgba(0,0,0,0)',
        ),
        colorway=['#00bc8c', '#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6'],
    )
)
pio.templates.default = 'bbb_dark'
```

```{python}
#| label: load-data

def load_snapshot(filepath):
    """Carrega um snapshot JSON (formato novo ou antigo)."""
    with open(filepath, encoding="utf-8") as f:
        data = json.load(f)
    if isinstance(data, dict) and "participants" in data:
        return data["participants"], data.get("_metadata")
    return data, None

def get_all_snapshots():
    """Retorna lista de (filepath, date_str) ordenada cronologicamente."""
    if not DATA_DIR.exists():
        return []
    snapshots = sorted(DATA_DIR.glob("*.json"))
    result = []
    for fp in snapshots:
        parts = fp.stem.split("_")
        date_str = parts[0]
        result.append((fp, date_str))
    return result

def parse_roles(roles_data):
    """Extrai nomes de roles (pode ser lista de strings ou lista de dicts)."""
    if not roles_data:
        return []
    result = []
    for r in roles_data:
        if isinstance(r, str):
            result.append(r)
        elif isinstance(r, dict):
            result.append(r.get('label', str(r)))
    return result

def build_reaction_matrix(participants):
    """ConstrÃ³i dicionÃ¡rio {(giver_name, receiver_name): reaction_label}."""
    matrix = {}
    for receiver in participants:
        rname = receiver['name']
        for rxn in receiver.get('characteristics', {}).get('receivedReactions', []):
            label = rxn.get('label', '')
            for giver in rxn.get('participants', []):
                gname = giver['name']
                matrix[(gname, rname)] = label
    return matrix

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label legÃ­vel e flag de sintÃ©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (Ãºltima do dia) â€” usada para anÃ¡lises de reaÃ§Ãµes
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)
```

# ParedÃ£o Atual {#paredao-atual}

Esta pÃ¡gina Ã© dedicada ao **paredÃ£o em andamento** (ou o mais recente finalizado). Aqui vocÃª encontra a formaÃ§Ã£o, votaÃ§Ã£o da casa, e anÃ¡lise de como as reaÃ§Ãµes do queridÃ´metro se relacionam com os votos.

```{python}
#| label: paredao-status
#| output: asis

# Detectar participantes com role "ParedÃ£o" na API
paredao_from_api = []
for p in latest['participants']:
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    if 'ParedÃ£o' in roles:
        paredao_from_api.append(p['name'])

if paredao_from_api:
    names_str = ', '.join(sorted(paredao_from_api))
    print(f"""
<div class="alert alert-danger">
ğŸ—³ï¸ <strong>PAREDÃƒO EM ANDAMENTO</strong><br>
Participantes no paredÃ£o (API): {names_str}
</div>
""")
else:
    print("""
<div class="alert alert-secondary">
ğŸ“… Nenhum paredÃ£o em andamento detectado na API. O prÃ³ximo paredÃ£o serÃ¡ formado no domingo.
</div>
""")
```

## Resultado do ParedÃ£o

<div class="alert alert-secondary" role="alert">
<strong>â„¹ï¸ Sobre os dados:</strong> Os resultados do ParedÃ£o sÃ£o atualizados apÃ³s cada eliminaÃ§Ã£o com base em informaÃ§Ãµes oficiais (GShow, transmissÃ£o ao vivo).
</div>

```{python}
#| label: paredao-results
#| output: asis

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  DADOS MANUAIS â€” Atualizar a cada novo ParedÃ£o             â•‘
# â•‘  Fonte: GShow / transmissÃ£o ao vivo                        â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# âš ï¸ DADOS MANUAIS â€” Atualizar apÃ³s cada eliminaÃ§Ã£o.
#    Todos os campos abaixo sÃ£o inseridos manualmente.
#    IMPORTANTE: nomes em 'votos_casa' devem corresponder exatamente aos nomes da API.
#    Ver CLAUDE.md para instruÃ§Ãµes detalhadas de como coletar e formatar os dados.
#
# STATUS DO PAREDÃƒO:
#   'finalizado' â€” Resultado conhecido, exibe votaÃ§Ã£o completa
#   'em_andamento' â€” VotaÃ§Ã£o popular em curso, exibe apenas formaÃ§Ã£o e votos da casa
#
# FLUXO DE ATUALIZAÃ‡ÃƒO:
#   1. Domingo (apÃ³s votaÃ§Ã£o da casa): Adicionar novo paredÃ£o com status='em_andamento'
#   2. TerÃ§a (apÃ³s resultado): Alterar status para 'finalizado' e adicionar percentuais

paredoes = [
    {
        'numero': 1,                    # Manual: nÃºmero do paredÃ£o
        'status': 'finalizado',         # Manual: 'em_andamento' ou 'finalizado'
        'data': '2026-01-20',           # Manual: data da eliminaÃ§Ã£o (YYYY-MM-DD)
        'titulo': '1Âº ParedÃ£o â€” 20 de Janeiro de 2026',  # Manual: tÃ­tulo para exibiÃ§Ã£o
        'formacao': (                   # Manual: texto livre descrevendo a formaÃ§Ã£o
            "Marcelo atendeu o Big Fone e indicou Aline Campos, "
            "que contra-atacou Ana Paula Renault. O LÃ­der Alberto Cowboy indicou Milena "
            "(sem direito a Bate e Volta). Paulo Augusto, mais votado pela casa (11 votos), "
            "escapou na Prova Bate e Volta (jogo de memÃ³ria)."
        ),
        'lider': 'Alberto Cowboy',      # Manual: nome do lÃ­der (deve corresponder Ã  API)
        'indicado_lider': 'Milena',     # Manual: indicado pelo lÃ­der
        'imunizado': {'por': 'Jonas Sulzbach', 'quem': 'Sarah Andrade'},  # Manual: imunizaÃ§Ã£o
        'participantes': [              # Manual: percentuais e resultado de cada participante
            {'nome': 'Aline Campos',      'voto_unico': 60.42, 'voto_torcida': 64.50, 'voto_total': 61.64, 'resultado': 'ELIMINADA', 'grupo': 'Camarote'},
            {'nome': 'Milena',             'voto_unico': 33.02, 'voto_torcida': 31.27, 'voto_total': 32.50, 'resultado': 'Salva',     'grupo': 'Pipoca'},
            {'nome': 'Ana Paula Renault',  'voto_unico':  6.56, 'voto_torcida':  4.23, 'voto_total':  5.86, 'resultado': 'Salva',     'grupo': 'Veterano'},
        ],
        'votos_casa': {                 # Manual: quem votou em quem (nomes devem corresponder Ã  API!)
            'Solange Couto': 'Paulo Augusto', 'Ana Paula Renault': 'Paulo Augusto',
            'Breno': 'Paulo Augusto', 'Aline Campos': 'Paulo Augusto',
            'Jonas Sulzbach': 'Paulo Augusto', 'Maxiane': 'Paulo Augusto',
            'Marcelo': 'Paulo Augusto', 'Sarah Andrade': 'Paulo Augusto',
            'Samira': 'Paulo Augusto', 'Milena': 'Paulo Augusto',
            'Gabriela': 'Paulo Augusto',
            'Brigido': 'Sol Vega', 'Edilson': 'Sol Vega',
            'Juliano Floss': 'Sol Vega', 'Paulo Augusto': 'Sol Vega',
            'Babu Santana': 'Sol Vega',
            'Jordana': 'Edilson',
            'Marciele': 'Juliano Floss', 'Sol Vega': 'Juliano Floss',
            'Matheus': 'Maxiane',
            'Leandro': 'Jonas Sulzbach',
            'Chaiany': 'Brigido',
        },
        'fontes': [                     # Manual: URLs das fontes utilizadas
            'https://portalaltadefinicao.com/bbb-26-voto-unico-e-voto-de-torcida-definem-eliminacao-de-aline-campos',
            'https://exame.com/pop/bbb-26-veja-quem-votou-em-quem-no-1o-paredao/',
            'https://www.itatiaia.com.br/entretenimento/bbb/bbb-26-novo-sistema-de-votacao-nao-interferiu-na-eliminacao-de-aline',
        ],
    },
    # Adicionar novos paredÃµes aqui seguindo o mesmo formato.
    # Todos os campos sÃ£o manuais. Ver CLAUDE.md Â§ "How to Update ParedÃ£o Data".

    {
        'numero': 2,
        'status': 'em_andamento',           # FormaÃ§Ã£o parcial â€” aguardando mais indicados
        'data': '2026-01-27',               # TerÃ§a-feira (data prevista da eliminaÃ§Ã£o)
        'titulo': '2Âº ParedÃ£o â€” EM FORMAÃ‡ÃƒO',
        'total_esperado': 3,                # Quantos indicados esperamos (adapta os placeholders)
        'formacao': (
            "DinÃ¢mica das Caixas-Surpresa: Cowboy e BrÃ­gido, em consenso, "
            "indicaram Leandro ao ParedÃ£o. NÃ£o haverÃ¡ Bate e Volta neste paredÃ£o."
        ),
        'lider': None,                      # LÃ­der serÃ¡ definido no domingo
        'indicado_lider': None,             # Aguardando indicaÃ§Ã£o do lÃ­der
        'participantes': [
            # Indicados confirmados atÃ© agora
            {'nome': 'Leandro', 'grupo': 'Pipoca', 'como': 'Caixas-Surpresa'},
            # Novos indicados serÃ£o adicionados aqui no domingo Ã  noite
        ],
        # votos_casa serÃ¡ adicionado apÃ³s a formaÃ§Ã£o completa no domingo
    },
]

# â”€â”€ Detectar paredÃ£o em andamento da API â”€â”€
# Se hÃ¡ participantes com role "ParedÃ£o" na API E nÃ£o temos um paredÃ£o 'em_andamento'
# no manual, mostramos um aviso para adicionar dados
def get_api_paredao_participants():
    """Retorna lista de nomes com role 'ParedÃ£o' no snapshot mais recente."""
    paredao_names = []
    for p in latest['participants']:
        roles = p.get('characteristics', {}).get('roles', [])
        role_labels = [r.get('label') if isinstance(r, dict) else r for r in roles]
        if 'ParedÃ£o' in role_labels:
            paredao_names.append(p['name'])
    return paredao_names

api_paredao = get_api_paredao_participants()

# â”€â”€ VisualizaÃ§Ãµes do ParedÃ£o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXIBIÃ‡ÃƒO DO PAREDÃƒO â€” LÃ³gica flexÃ­vel que adapta ao dado disponÃ­vel
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# O cÃ³digo detecta automaticamente o estado baseado nos dados presentes:
# - Se tem 'resultado' nos participantes â†’ finalizado (mostra resultados)
# - Se nÃ£o tem 'resultado' â†’ em andamento (mostra formaÃ§Ã£o)
# - Se participantes < 3 â†’ formaÃ§Ã£o parcial (mostra "aguardando")
# - Se nÃ£o tem 'votos_casa' â†’ aguardando votaÃ§Ã£o da casa
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ultimo = paredoes[-1] if paredoes else None

if ultimo:
    is_finalizado = ultimo.get('status') == 'finalizado'
    participantes = ultimo.get('participantes', [])
    tem_resultado = any(p.get('resultado') for p in participantes)
    tem_votos_casa = bool(ultimo.get('votos_casa'))
    n_indicados = len(participantes)
    esperado_indicados = ultimo.get('total_esperado', 3)  # PadrÃ£o: 3 indicados

    if is_finalizado or tem_resultado:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO FINALIZADO â€” Resultado conhecido
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        pass  # Handled below in the else block

    else:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO EM ANDAMENTO â€” Ainda nÃ£o temos resultado
        # Adapta a exibiÃ§Ã£o baseado no que temos disponÃ­vel
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        # Determinar tÃ­tulo e mensagem baseado no estado
        if n_indicados < esperado_indicados:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” FORMAÃ‡ÃƒO EM ANDAMENTO"
            cor_titulo = '#3498db'  # Azul para formaÃ§Ã£o
            if n_indicados == 0:
                subtitulo = "Aguardando indicaÃ§Ãµes..."
            else:
                falta = esperado_indicados - n_indicados
                subtitulo = f"{n_indicados} indicado(s) confirmado(s). Aguardando mais {falta}..."
        else:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” EM VOTAÃ‡ÃƒO"
            cor_titulo = '#f39c12'  # Amarelo para votaÃ§Ã£o
            subtitulo = "VotaÃ§Ã£o popular em andamento. Resultado na terÃ§a-feira Ã  noite."

        # Header
        print(f"""
<div style="text-align: center; margin-bottom: 2rem;">
<h2 style="color: {cor_titulo}; margin-bottom: 0.5rem;">ğŸ—³ï¸ {titulo}</h2>
<p style="color: #aaa; font-size: 1.1em;">{subtitulo}</p>
</div>
""")

        # Cards dos indicados conhecidos
        if participantes:
            print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 2rem 0;">')
            for p in participantes:
                nome = p['nome']
                grupo = p.get('grupo', MEMBER_OF.get(nome, '?'))
                cor_grupo = GROUP_COLORS.get(grupo, '#666')
                avatar_url = AVATARS.get(nome, '')
                como_indicado = p.get('como', '')  # Ex: "DinÃ¢mica", "LÃ­der", "Casa"

                print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 180px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 2px solid {cor_grupo};">')
                if avatar_url:
                    print(f'<img src="{avatar_url}" alt="{nome}" style="width: 120px; height: 120px; border-radius: 50%; object-fit: cover; border: 3px solid {cor_grupo}; margin-bottom: 1rem;">')
                print(f'<h4 style="margin: 0; color: #fff; font-size: 1.1em;">{nome}</h4>')
                print(f'<span style="display: inline-block; margin-top: 0.5rem; padding: 0.25rem 0.75rem; background: {cor_grupo}; color: #fff; border-radius: 12px; font-size: 0.85em;">{grupo}</span>')
                if como_indicado:
                    print(f'<div style="color: #aaa; font-size: 0.8em; margin-top: 0.5rem;">via {como_indicado}</div>')
                print('</div>')

            # Placeholder cards para indicados faltantes
            for i in range(esperado_indicados - n_indicados):
                print(f'<div style="background: linear-gradient(145deg, #2a2a2a, #1a1a1a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 180px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 2px dashed #555;">')
                print(f'<div style="width: 120px; height: 120px; border-radius: 50%; background: #333; margin: 0 auto 1rem auto; display: flex; align-items: center; justify-content: center; font-size: 2em; color: #555;">?</div>')
                print(f'<h4 style="margin: 0; color: #666; font-size: 1.1em;">Aguardando...</h4>')
                print('</div>')

            print('</div>')

        # InformaÃ§Ãµes disponÃ­veis sobre a formaÃ§Ã£o
        if ultimo.get('formacao'):
            print(f"\n**Como estÃ¡ sendo formado:** {ultimo['formacao']}")

        if ultimo.get('lider'):
            print(f"\n**LÃ­der da semana:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"\n**IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
            elif n_indicados < esperado_indicados:
                print(f"\n**IndicaÃ§Ã£o do LÃ­der:** *Aguardando...*")

        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"\n**ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")

        # VotaÃ§Ã£o da casa
        if tem_votos_casa:
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### VotaÃ§Ã£o da Casa\n")
            print(f"Mais votado: **{ranking[0][0]}** ({ranking[0][1]} votos)\n")
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                print(f"- **{alvo}** ({n}): {', '.join(votantes)}")
        elif n_indicados >= esperado_indicados:
            # FormaÃ§Ã£o completa mas sem votos da casa ainda
            print(f"\n### VotaÃ§Ã£o da Casa\n")
            print(f"*Aguardando divulgaÃ§Ã£o da votaÃ§Ã£o da casa...*")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PAREDÃƒO FINALIZADO â€” Exibir se tem resultado
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if ultimo and (ultimo.get('status') == 'finalizado' or any(p.get('resultado') for p in ultimo.get('participantes', []))):
        df_p = pd.DataFrame(ultimo['participantes'])
        has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

        # â”€â”€ Visual: Cards com fotos e resultado â”€â”€
        print(f'<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 1.5rem 0 2rem 0;">')
        for _, row in df_p.iterrows():
            nome = row['nome']
            grupo = row.get('grupo', MEMBER_OF.get(nome, '?'))
            resultado = row.get('resultado', '')
            voto_total = row.get('voto_total', 0)
            avatar_url = AVATARS.get(nome, '')
            cor_grupo = GROUP_COLORS.get(grupo, '#666')

            # Card styling based on result
            if resultado == 'ELIMINADA':
                border_color = '#E6194B'
                badge_bg = '#E6194B'
                badge_text = 'ELIMINADO(A)'
                img_filter = 'grayscale(100%)'  # B&W for eliminated
            else:
                border_color = '#3CB44B'
                badge_bg = '#3CB44B'
                badge_text = 'SALVO(A)'
                img_filter = 'none'

            print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 3px solid {border_color};">')
            if avatar_url:
                print(f'<img src="{avatar_url}" alt="{nome}" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid {border_color}; margin-bottom: 0.75rem; filter: {img_filter};">')
            print(f'<h4 style="margin: 0 0 0.25rem 0; color: #fff; font-size: 1em;">{nome}</h4>')
            print(f'<span style="display: block; color: {cor_grupo}; font-size: 0.8em; margin-bottom: 0.5rem;">{grupo}</span>')
            print(f'<span style="display: inline-block; padding: 0.25rem 0.6rem; background: {badge_bg}; color: #fff; border-radius: 10px; font-size: 0.75em; font-weight: bold;">{badge_text}</span>')
            print(f'<div style="color: #fff; font-size: 1.3em; font-weight: bold; margin-top: 0.5rem;">{voto_total:.1f}%</div>')
            print('</div>')
        print('</div>')

        fig = go.Figure()

        if has_breakdown:
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_unico'],
                text=[f"{v:.1f}%" for v in df_p['voto_unico']],
                textposition='outside', name='Voto Ãšnico (70%)',
                marker_color='#1976D2',
                hovertemplate='%{x}: %{y:.1f}% (Voto Ãšnico)<extra></extra>',
            ))
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_torcida'],
                text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
                textposition='outside', name='Voto Torcida (30%)',
                marker_color='#FF9800',
                hovertemplate='%{x}: %{y:.1f}% (Voto Torcida)<extra></extra>',
            ))

        colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_total'],
            text=[f"{v:.1f}%" for v in df_p['voto_total']],
            textposition='outside', name='MÃ©dia Final',
            marker_color=colors_total,
            hovertemplate='%{x}: %{y:.1f}% (Final)<extra></extra>',
        ))

        fig.update_layout(
            title=dict(text=ultimo['titulo'], y=0.95, x=0.5, xanchor='center'),
            xaxis_title="", yaxis_title="Votos (%)",
            yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
            barmode='group',
            height=500,
            margin=dict(t=100),
            legend=dict(orientation='h', yanchor='bottom', y=1.08, xanchor='center', x=0.5),
            annotations=[dict(
                text="FÃ³rmula: (Voto Ãšnico Ã— 0,70) + (Voto Torcida Ã— 0,30) = MÃ©dia Final",
                xref="paper", yref="paper", x=0.5, y=-0.12, showarrow=False,
                font=dict(size=11, color='gray')
            )]
        )

        fig.show()

        # FormaÃ§Ã£o e detalhes do Ãºltimo paredÃ£o
        print(f"\n**Como foi formado:** {ultimo['formacao']}")

        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"\n**ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")

        # VotaÃ§Ã£o da casa do Ãºltimo paredÃ£o
        if ultimo.get('votos_casa'):
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n**VotaÃ§Ã£o da casa** â€” mais votado: **{ranking[0][0]}** ({ranking[0][1]} votos)")
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                print(f"- {alvo} ({n}): {', '.join(votantes)}")

# â”€â”€ Link para histÃ³rico completo de paredÃµes â”€â”€
paredoes_finalizados = [p for p in paredoes if p.get('status') == 'finalizado']
if len(paredoes_finalizados) >= 1:
    n_paredoes = len(paredoes_finalizados)
    print(f"""
<div style="background: linear-gradient(135deg, #2c3e50, #34495e); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; text-align: center; border: 1px solid #4a6785;">
<p style="margin: 0 0 0.75rem 0; color: #ecf0f1; font-size: 1.1em;">ğŸ“š <strong>Quer ver os paredÃµes anteriores?</strong></p>
<p style="margin: 0 0 1rem 0; color: #bdc3c7;">HistÃ³rico completo com votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o.</p>
<a href="paredoes.html" style="display: inline-block; background: #3498db; color: white; padding: 0.6rem 1.5rem; border-radius: 8px; text-decoration: none; font-weight: bold;">Ver HistÃ³rico de ParedÃµes â†’</a>
</div>
""")
```

## Voto da Casa vs QueridÃ´metro {#voto-vs-reacoes}

```{python}
#| label: vote-coherence
#| output: asis

# â”€â”€ VotaÃ§Ã£o da casa vs ReaÃ§Ãµes â”€â”€
# SÃ³ mostra se o paredÃ£o estiver finalizado (temos resultado)
ultimo_paredao = paredoes[-1] if paredoes else None

if ultimo_paredao and ultimo_paredao.get('status') == 'finalizado' and ultimo_paredao.get('votos_casa') and all_matrices:
    print("ComparaÃ§Ã£o entre o voto no confessionÃ¡rio e a reaÃ§Ã£o pÃºblica "
          "na coleta mais prÃ³xima ao paredÃ£o.\n")

    # Encontrar o snapshot mais prÃ³ximo Ã  data do paredÃ£o
    paredao_date = ultimo_paredao['data']
    closest_idx = 0
    for i, snap in enumerate(snapshots):
        if snap['date'] <= paredao_date:
            closest_idx = i

    matrix_at_paredao = all_matrices[closest_idx]
    votos = ultimo_paredao['votos_casa']

    match_rows = []
    for votante, alvo in sorted(votos.items()):
        reacao_ao_alvo = matrix_at_paredao.get((votante, alvo), '')
        emoji_alvo = REACTION_EMOJI.get(reacao_ao_alvo, '?')
        coerente = 'â€”'
        if reacao_ao_alvo in POSITIVE:
            coerente = 'â¤ï¸â†’ğŸ‘ Incoerente'
        elif reacao_ao_alvo in MILD_NEGATIVE:
            coerente = 'âœ… Leve'
        elif reacao_ao_alvo in STRONG_NEGATIVE:
            coerente = 'âœ… Forte'

        match_rows.append({
            'Votante': votante,
            'Votou em': alvo,
            'ReaÃ§Ã£o ao alvo': emoji_alvo,
            'CoerÃªncia': coerente,
        })

    df_match = pd.DataFrame(match_rows)

    n_incoerente = sum(1 for r in match_rows if 'Incoerente' in r['CoerÃªncia'])
    n_coerente = sum(1 for r in match_rows if r['CoerÃªncia'].startswith('âœ…'))
    total = len(match_rows)
    print(f"**Resultado:** {n_coerente}/{total} votos coerentes com a reaÃ§Ã£o pÃºblica, "
          f"{n_incoerente}/{total} incoerentes (deu â¤ï¸ mas votou contra).\n")

    print(df_match.to_markdown(index=False))
else:
    print("*Aguardando dados do paredÃ£o para exibir anÃ¡lise de coerÃªncia.*")
```

## ReaÃ§Ãµes Preveem Votos? {#reacoes-vs-votos}

```{python}
#| label: vote-reaction-analysis
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REAÃ‡Ã•ES PREVEEM VOTOS?
# SÃ³ exibe quando o paredÃ£o mais recente tem votos da casa para analisar
# (disponÃ­vel apÃ³s a formaÃ§Ã£o completa no domingo Ã  noite)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Verifica se o paredÃ£o mais recente tem votos da casa
ultimo_paredao = paredoes[-1] if paredoes else None
tem_votos_para_analisar = (
    ultimo_paredao and
    ultimo_paredao.get('votos_casa')
)

# SÃ³ mostra a seÃ§Ã£o se tivermos votos da casa para analisar
if tem_votos_para_analisar:
    print("AnÃ¡lise aprofundada: as reaÃ§Ãµes do queridÃ´metro refletem a intenÃ§Ã£o de voto privada?\n")

    # Usa o Ãºltimo paredÃ£o finalizado
    paredao = ultimo_paredao
    votos = paredao['votos_casa']
    paredao_date = paredao['data']

    # Snapshot mais prÃ³ximo antes do paredÃ£o
    closest_idx = 0
    for i, snap in enumerate(snapshots):
        if snap['date'] <= paredao_date:
            closest_idx = i
    matrix = all_matrices[closest_idx]
    snap_participants = snapshots[closest_idx]['participants']

    # â”€â”€ AnÃ¡lise 1: Sentimento recebido vs votos recebidos â”€â”€
    vote_counts = Counter(votos.values())
    sent_by_name = {}
    neg_count_by_name = {}
    for p in snap_participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        sent_by_name[name] = calc_sentiment(p)
        neg_count_by_name[name] = sum(
            r['amount'] for r in p.get('characteristics', {}).get('receivedReactions', [])
            if r['label'] != 'CoraÃ§Ã£o'
        )

    # Scatter: negatividade recebida vs votos recebidos
    scatter_data = []
    for name in set(list(vote_counts.keys()) + list(neg_count_by_name.keys())):
        if name in neg_count_by_name:
            scatter_data.append({
                'nome': name,
                'neg_recebidas': neg_count_by_name.get(name, 0),
                'votos_recebidos': vote_counts.get(name, 0),
                'grupo': MEMBER_OF.get(name, '?'),
            })

    df_scatter = pd.DataFrame(scatter_data)

    if len(df_scatter) > 2:
        corr_val = df_scatter['neg_recebidas'].corr(df_scatter['votos_recebidos'])

        fig = px.scatter(
            df_scatter, x='neg_recebidas', y='votos_recebidos',
            text='nome', color='grupo', color_discrete_map=GROUP_COLORS,
            title=f"ReaÃ§Ãµes Negativas Recebidas vs Votos na Casa (r = {corr_val:.2f})",
            labels={'neg_recebidas': 'ReaÃ§Ãµes negativas recebidas', 'votos_recebidos': 'Votos recebidos na casa'}
        )
        fig.update_traces(textposition='top center', textfont_size=9, marker_size=12)
        fig.update_layout(height=500)

        # Linha de tendÃªncia
        if df_scatter['neg_recebidas'].std() > 0:
            z = np.polyfit(df_scatter['neg_recebidas'], df_scatter['votos_recebidos'], 1)
            x_line = np.linspace(df_scatter['neg_recebidas'].min(), df_scatter['neg_recebidas'].max(), 50)
            fig.add_trace(go.Scatter(x=x_line, y=np.polyval(z, x_line), mode='lines',
                                     line=dict(dash='dash', color='gray'), name='TendÃªncia', showlegend=True))

        fig.show()

        if abs(corr_val) < 0.3:
            print(f"\n> **CorrelaÃ§Ã£o fraca (r = {corr_val:.2f}):** "
                  "As reaÃ§Ãµes do queridÃ´metro **nÃ£o preveem** quem serÃ¡ votado pela casa. "
                  "Os votos seguem lÃ³gica estratÃ©gica, nÃ£o emocional.\n")
        elif corr_val > 0.3:
            print(f"\n> **CorrelaÃ§Ã£o moderada (r = {corr_val:.2f}):** "
                  "Quem recebe mais reaÃ§Ãµes negativas tende a receber mais votos.\n")

    # â”€â”€ AnÃ¡lise 2: Cada votante votou no mais odiado? â”€â”€
    voted_worst = 0
    voter_analysis = []
    for votante, alvo in votos.items():
        worst_target = None
        worst_score = float('inf')
        for other_name in neg_count_by_name:
            if other_name == votante:
                continue
            rxn = matrix.get((votante, other_name), '')
            weight = SENTIMENT_WEIGHTS.get(rxn, 0)
            if weight < worst_score:
                worst_score = weight
                worst_target = other_name

        match = alvo == worst_target
        if match:
            voted_worst += 1
        rxn_to_target = matrix.get((votante, alvo), '')
        emoji_to_target = REACTION_EMOJI.get(rxn_to_target, '?')
        voter_analysis.append({
            'votante': votante, 'alvo': alvo, 'emoji': emoji_to_target,
            'pior_avaliado': worst_target, 'votou_no_pior': match
        })

    pct_worst = voted_worst / len(votos) * 100
    print(f"### Votaram no participante que mais detestam?\n")
    print(f"Apenas **{voted_worst}/{len(votos)} ({pct_worst:.0f}%)** votaram na pessoa que "
          f"avaliaram mais negativamente nas reaÃ§Ãµes. "
          f"Os votos sÃ£o **estratÃ©gicos**, nÃ£o reflexo direto das emoÃ§Ãµes pÃºblicas.\n")

    # â”€â”€ AnÃ¡lise 3: GrÃ¡fico de coerÃªncia por votante â”€â”€
    coerencia_data = []
    for va in voter_analysis:
        rxn = matrix.get((va['votante'], va['alvo']), '')
        if rxn in POSITIVE:
            tipo = 'Deu â¤ï¸ mas votou contra'
            cor = '#E6194B'
        elif rxn in MILD_NEGATIVE:
            tipo = 'Coerente (negativa leve)'
            cor = '#FF9800'
        elif rxn in STRONG_NEGATIVE:
            tipo = 'Coerente (negativa forte)'
            cor = '#3CB44B'
        else:
            tipo = 'Sem reaÃ§Ã£o'
            cor = '#999'
        coerencia_data.append({
            'Votante': va['votante'],
            'Tipo': tipo,
            'Cor': cor,
            'Votou em': va['alvo'],
            'ReaÃ§Ã£o': va['emoji'],
        })

    df_coer = pd.DataFrame(coerencia_data)
    tipo_colors = {'Deu â¤ï¸ mas votou contra': '#E6194B', 'Coerente (negativa leve)': '#FF9800',
                   'Coerente (negativa forte)': '#3CB44B', 'Sem reaÃ§Ã£o': '#999'}

    tipo_counts = df_coer['Tipo'].value_counts()

    fig = go.Figure(go.Pie(
        labels=tipo_counts.index.tolist(),
        values=tipo_counts.values.tolist(),
        marker_colors=[tipo_colors.get(t, '#999') for t in tipo_counts.index],
        textinfo='label+percent+value',
        textfont_size=12,
        hole=0.4,
        hovertemplate='%{label}: %{value} votantes (%{percent})<extra></extra>',
    ))

    fig.update_layout(
        title=f"CoerÃªncia: ReaÃ§Ã£o PÃºblica vs Voto Privado â€” {paredao['numero']}Âº ParedÃ£o",
        height=400,
        annotations=[dict(text=f"{len(votos)}<br>votos", x=0.5, y=0.5, font_size=16, showarrow=False)]
    )

    fig.show()

    # â”€â”€ AnÃ¡lise 4: O mais votado era amado ou odiado? â”€â”€
    mais_votado = vote_counts.most_common(1)[0]
    mv_name, mv_votes = mais_votado
    mv_sentiment = sent_by_name.get(mv_name, 0)
    mv_neg = neg_count_by_name.get(mv_name, 0)
    votantes_dele = [v for v, a in votos.items() if a == mv_name]
    hearts_from_voters = sum(1 for v in votantes_dele if matrix.get((v, mv_name), '') in POSITIVE)

    print(f"### O caso {mv_name}\n")
    print(f"**{mv_name}** foi o mais votado pela casa com **{mv_votes} votos**.\n")
    print(f"- Sentimento recebido: **{mv_sentiment:+.1f}** (reaÃ§Ãµes negativas: {mv_neg})")
    print(f"- Dos {mv_votes} que votaram nele, **{hearts_from_voters}** tinham lhe dado â¤ï¸ publicamente")

    if hearts_from_voters > mv_votes / 2:
        print(f"- **{hearts_from_voters}/{mv_votes} = {hearts_from_voters/mv_votes*100:.0f}%** dos votos "
              "foram \"duas caras\" â€” demonstraÃ§Ã£o pÃºblica de afeto, voto privado contra")
    print("")

    # â”€â”€ AnÃ¡lise 5: IndicaÃ§Ã£o do lÃ­der â”€â”€
    if paredao.get('lider') and paredao.get('indicado_lider'):
        lider = paredao['lider']
        indicado = paredao['indicado_lider']
        rxn_lider = matrix.get((lider, indicado), '')
        emoji_lider = REACTION_EMOJI.get(rxn_lider, '?')
        weight_lider = SENTIMENT_WEIGHTS.get(rxn_lider, 0)

        worst_for_leader = None
        worst_w = float('inf')
        for other in neg_count_by_name:
            if other == lider:
                continue
            w = SENTIMENT_WEIGHTS.get(matrix.get((lider, other), ''), 0)
            if w < worst_w:
                worst_w = w
                worst_for_leader = other

        print(f"### IndicaÃ§Ã£o do LÃ­der\n")
        print(f"**{lider}** (LÃ­der) indicou **{indicado}** ao paredÃ£o.")
        print(f"- ReaÃ§Ã£o do lÃ­der ao indicado: {emoji_lider} ({rxn_lider}, peso {weight_lider:+.1f})")

        if worst_for_leader == indicado:
            print(f"- **Coerente:** {indicado} era a pessoa que {lider} avaliou mais negativamente nas reaÃ§Ãµes")
        else:
            print(f"- Pior avaliado por {lider}: {worst_for_leader} ({REACTION_EMOJI.get(matrix.get((lider, worst_for_leader), ''), '?')})")
            if weight_lider < 0:
                print(f"- Parcialmente coerente: deu reaÃ§Ã£o negativa, mas nÃ£o era o pior avaliado")
            else:
                print(f"- **Incoerente:** deu {emoji_lider} ao indicado â€” decisÃ£o estratÃ©gica, nÃ£o emocional")
else:
    print("*Aguardando votaÃ§Ã£o da casa para anÃ¡lise de previsibilidade.*")
```

---

::: {.callout-tip}
## NavegaÃ§Ã£o
- [ğŸ“Š Painel](index.html) â€” Estado atual das reaÃ§Ãµes
- [ğŸ“… O Que Mudou](mudancas.html) â€” MudanÃ§as do dia anterior
- [ğŸ“ˆ TrajetÃ³ria](trajetoria.html) â€” EvoluÃ§Ã£o ao longo da temporada
- [ğŸ“š Arquivo](paredoes.html) â€” HistÃ³rico de paredÃµes
:::
