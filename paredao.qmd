---
title: "BBB 26 â€” ParedÃ£o"
subtitle: "Acompanhe o paredÃ£o atual: formaÃ§Ã£o, votaÃ§Ã£o e anÃ¡lise de reaÃ§Ãµes"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    load_snapshot, get_all_snapshots, parse_roles, build_reaction_matrix,
    require_clean_manual_events, calc_sentiment, setup_bbb_dark_theme,
    genero, artigo, get_nominee_badge,
    MONTH_MAP_PT, parse_votalhada_hora, make_poll_timeseries,
    avatar_html, avatar_img,
    REACTION_EMOJI, REACTION_SLUG_TO_LABEL, SENTIMENT_WEIGHTS,
    POSITIVE, MILD_NEGATIVE, STRONG_NEGATIVE, GROUP_COLORS,
)

require_clean_manual_events()
setup_bbb_dark_theme()

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

MEMBER_OF = {}  # preenchido ao carregar dados
```

```{python}
#| label: load-data

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label legÃ­vel e flag de sintÃ©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (Ãºltima do dia) â€” usada para anÃ¡lises de reaÃ§Ãµes
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)
```

```{python}
#| label: data-freshness
#| output: asis

# Data freshness shown in header area
print(f'<p class="text-muted small mb-0">ğŸ“… Dados de <strong>{latest["label"]}</strong> Â· {n_daily} dias de histÃ³rico</p>')
```

```{python}
#| label: paredao-results
#| output: asis

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  CARREGAR DADOS DE PAREDÃƒO DO JSON                          â•‘
# â•‘  Fonte: data/paredoes.json (atualizado manualmente)         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAREDOES_FILE = Path("data/paredoes.json")

def load_paredoes():
    """Carrega dados de paredÃ£o do arquivo JSON."""
    if not PAREDOES_FILE.exists():
        return []
    with open(PAREDOES_FILE, encoding="utf-8") as f:
        data = json.load(f)

    # Convert JSON structure to the format expected by the dashboard
    paredoes = []
    for p in data.get('paredoes', []):
        entry = {
            'numero': p['numero'],
            'status': p['status'],
            'data': p['data'],
            'data_formacao': p.get('data_formacao'),
            'titulo': p['titulo'],
            'lider': p.get('formacao', {}).get('lider'),
            'indicado_lider': p.get('formacao', {}).get('indicado_lider'),
            'motivo_lider': p.get('formacao', {}).get('motivo_lider'),
            'anjo': p.get('formacao', {}).get('anjo'),
            'anjo_autoimune': p.get('formacao', {}).get('anjo_autoimune'),
            'formacao': p.get('formacao', {}).get('resumo', ''),
            'dinamica': p.get('formacao', {}).get('dinamica'),
            'big_fone': p.get('formacao', {}).get('big_fone'),
            'contragolpe': p.get('formacao', {}).get('contragolpe'),
            'bate_volta': p.get('formacao', {}).get('bate_volta'),
            'votos_casa': p.get('votos_casa', {}),
            'fontes': p.get('fontes', []),
            'impedidos_votar': p.get('impedidos_votar', []),
            'votos_anulados': p.get('votos_anulados', []),
        }

        # Handle imunizado
        im = p.get('formacao', {}).get('imunizado')
        if im:
            entry['imunizado'] = im

        # Include resultado for badge logic
        if p.get('resultado'):
            entry['resultado'] = p['resultado']

        # Handle participantes based on status
        if p['status'] == 'finalizado' and p.get('resultado'):
            entry['participantes'] = []
            for ind in p.get('indicados_finais', []):
                part = {
                    'nome': ind['nome'],
                    'grupo': ind.get('grupo', MEMBER_OF.get(ind['nome'], '?')),
                    'como': ind.get('como', ''),
                }
                # Add vote data if available
                votos = p['resultado'].get('votos', {}).get(ind['nome'], {})
                if votos:
                    part['voto_unico'] = votos.get('voto_unico', 0)
                    part['voto_torcida'] = votos.get('voto_torcida', 0)
                    part['voto_total'] = votos.get('voto_total', 0)
                    part['resultado'] = 'ELIMINADA' if ind['nome'] == p['resultado'].get('eliminado') else 'Salva'
                entry['participantes'].append(part)
        else:
            entry['participantes'] = [
                {'nome': ind['nome'], 'grupo': ind.get('grupo', '?'), 'como': ind.get('como', '')}
                for ind in p.get('indicados_finais', [])
            ]
            entry['total_esperado'] = 3

        paredoes.append(entry)

    return paredoes

paredoes = load_paredoes()

# Aviso se faltar data_formacao
missing_formacao = [p for p in paredoes if p.get('status') == 'finalizado' and not p.get('data_formacao')]
if missing_formacao:
    print("::: {.callout-warning title=\"âš ï¸ data_formacao ausente\" appearance=\"minimal\"}")
    print("Alguns paredÃµes finalizados nÃ£o possuem `data_formacao`. A anÃ¡lise de coerÃªncia pode usar a data do paredÃ£o e ficar menos precisa.")
    print("Preencha `data_formacao` em `data/paredoes.json`.")
    print(":::\n")
# â”€â”€ Carregar dados de enquetes do Votalhada â”€â”€
from data_utils import load_votalhada_polls, get_poll_for_paredao, calculate_poll_accuracy
polls_data = load_votalhada_polls()

# â”€â”€ Detectar paredÃ£o em andamento da API â”€â”€
# Se hÃ¡ participantes com role "ParedÃ£o" na API E nÃ£o temos um paredÃ£o 'em_andamento'
# no manual, mostramos um aviso para adicionar dados
def get_api_paredao_participants():
    """Retorna lista de nomes com role 'ParedÃ£o' no snapshot mais recente."""
    paredao_names = []
    for p in latest['participants']:
        roles = p.get('characteristics', {}).get('roles', [])
        role_labels = [r.get('label') if isinstance(r, dict) else r for r in roles]
        if 'ParedÃ£o' in role_labels:
            paredao_names.append(p['name'])
    return paredao_names

api_paredao = get_api_paredao_participants()

# â”€â”€ Merge API participants into manual paredÃ£o data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Auto-add participants from API that aren't in the manual list
def merge_api_paredao(paredao_entry, api_names):
    """Merge API-detected paredÃ£o participants into manual entry."""
    if not paredao_entry or paredao_entry.get('status') == 'finalizado':
        return  # Don't modify finalized paredÃµes

    participantes = paredao_entry.get('participantes', [])
    manual_names = {p['nome'] for p in participantes}

    # Add API participants not in manual list
    for name in api_names:
        if name not in manual_names:
            # Get grupo from latest snapshot
            grupo = 'Pipoca'
            for p in latest['participants']:
                if p['name'] == name:
                    grupo = p.get('characteristics', {}).get('memberOf', 'Pipoca')
                    break
            participantes.append({
                'nome': name,
                'grupo': grupo,
                'como': 'API'  # Will be updated manually later
            })

    paredao_entry['participantes'] = participantes

# Apply merge to the latest paredÃ£o if it's em_andamento
if paredoes and paredoes[-1].get('status') == 'em_andamento':
    merge_api_paredao(paredoes[-1], api_paredao)

# â”€â”€ VisualizaÃ§Ãµes do ParedÃ£o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXIBIÃ‡ÃƒO DO PAREDÃƒO â€” LÃ³gica flexÃ­vel que adapta ao dado disponÃ­vel
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# O cÃ³digo detecta automaticamente o estado baseado nos dados presentes:
# - Se tem 'resultado' nos participantes â†’ finalizado (mostra resultados)
# - Se nÃ£o tem 'resultado' â†’ em andamento (mostra formaÃ§Ã£o)
# - Se participantes < 3 â†’ formaÃ§Ã£o parcial (mostra "aguardando")
# - Se nÃ£o tem 'votos_casa' â†’ aguardando votaÃ§Ã£o da casa
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ultimo = paredoes[-1] if paredoes else None

if ultimo:
    is_finalizado = ultimo.get('status') == 'finalizado'
    participantes = ultimo.get('participantes', [])
    tem_resultado = any(p.get('resultado') for p in participantes)
    tem_votos_casa = bool(ultimo.get('votos_casa'))
    n_indicados = len(participantes)
    esperado_indicados = ultimo.get('total_esperado', 3)  # PadrÃ£o: 3 indicados

    if is_finalizado or tem_resultado:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO FINALIZADO â€” Resultado conhecido
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        pass  # Handled below in the else block

    else:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO EM ANDAMENTO â€” Ainda nÃ£o temos resultado
        # Adapta a exibiÃ§Ã£o baseado no que temos disponÃ­vel
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        # Determinar tÃ­tulo e mensagem baseado no estado
        if n_indicados < esperado_indicados:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” FORMAÃ‡ÃƒO EM ANDAMENTO"
            cor_titulo = '#3498db'  # Azul para formaÃ§Ã£o
            if n_indicados == 0:
                subtitulo = "Aguardando indicaÃ§Ãµes..."
            else:
                falta = esperado_indicados - n_indicados
                subtitulo = f"{n_indicados} indicado(s) confirmado(s). Aguardando mais {falta}..."
        else:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” EM VOTAÃ‡ÃƒO"
            cor_titulo = '#f39c12'  # Amarelo para votaÃ§Ã£o
            subtitulo = "VotaÃ§Ã£o popular em andamento. Resultado na terÃ§a-feira Ã  noite."

        # Check for auto-detected participants (need manual info)
        auto_detected = [p for p in participantes if p.get('como') == 'API']
        needs_manual_info = len(auto_detected) > 0 or not tem_votos_casa

        # Header
        print(f"""
<div style="text-align: center; margin-bottom: 2rem;">
<h2 style="color: {cor_titulo}; margin-bottom: 0.5rem;">ğŸ—³ï¸ {titulo}</h2>
<p style="color: #aaa; font-size: 1.1em;">{subtitulo}</p>
</div>
""")

        # Warning for incomplete data
        if needs_manual_info:
            missing = []
            if auto_detected:
                names = ', '.join([p['nome'] for p in auto_detected])
                missing.append(f"Como {names} foram indicados")
            if not tem_votos_casa and n_indicados >= esperado_indicados:
                missing.append("VotaÃ§Ã£o da casa")
            if not ultimo.get('lider'):
                missing.append("LÃ­der da semana")

            missing_text = ' Â· '.join(missing) if missing else "Detalhes da formaÃ§Ã£o"
            print(f"""
<div style="background: rgba(243, 156, 18, 0.15); border: 1px solid rgba(243, 156, 18, 0.4); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; text-align: center;">
<span style="color: #f39c12;">âš ï¸ <strong>Dados parciais</strong></span>
<p style="color: #ccc; margin: 0.5rem 0 0 0; font-size: 0.9em;">Participantes detectados da API. InformaÃ§Ãµes adicionais serÃ£o preenchidas manualmente.</p>
<p style="color: #888; margin: 0.3rem 0 0 0; font-size: 0.8em;">Pendente: {missing_text}</p>
</div>
""")

        # Cards dos indicados conhecidos
        if participantes:
            print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 2rem 0;">')
            for p in participantes:
                nome = p['nome']
                grupo = p.get('grupo', MEMBER_OF.get(nome, '?'))
                cor_grupo = GROUP_COLORS.get(grupo, '#666')
                avatar_url = AVATARS.get(nome, '')
                como_indicado = p.get('como', '')  # Ex: "DinÃ¢mica", "LÃ­der", "Casa", "API"
                is_auto = como_indicado == 'API'

                # Different border style for auto-detected
                border_style = f"2px dashed {cor_grupo}" if is_auto else f"2px solid {cor_grupo}"
                opacity = "0.85" if is_auto else "1"

                print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 180px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: {border_style}; opacity: {opacity};">')
                if avatar_url:
                    print(f'<img src="{avatar_url}" alt="{nome}" style="width: 120px; height: 120px; border-radius: 50%; object-fit: cover; border: 3px solid {cor_grupo}; margin-bottom: 1rem;">')
                print(f'<h4 style="margin: 0; color: #fff; font-size: 1.1em; text-align: center;">{nome}</h4>')
                print(f'<span style="display: inline-block; margin-top: 0.5rem; padding: 0.25rem 0.75rem; background: {cor_grupo}; color: #fff; border-radius: 12px; font-size: 0.85em;">{grupo}</span>')
                if como_indicado and not is_auto:
                    print(f'<div style="color: #aaa; font-size: 0.8em; margin-top: 0.5rem;">via {como_indicado}</div>')
                elif is_auto:
                    print(f'<div style="color: #f39c12; font-size: 0.75em; margin-top: 0.5rem;">â³ aguardando detalhes</div>')
                print('</div>')

            # Placeholder cards para indicados faltantes
            for i in range(esperado_indicados - n_indicados):
                print(f'<div style="background: linear-gradient(145deg, #2a2a2a, #1a1a1a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 180px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 2px dashed #555;">')
                print(f'<div style="width: 120px; height: 120px; border-radius: 50%; background: #333; margin: 0 auto 1rem auto; display: flex; align-items: center; justify-content: center; font-size: 2em; color: #555;">?</div>')
                print(f'<h4 style="margin: 0; color: #666; font-size: 1.1em; text-align: center;">Aguardando...</h4>')
                print('</div>')

            print('</div>')

        # â”€â”€ Enquetes do Votalhada (em andamento) â”€â”€
        poll = get_poll_for_paredao(polls_data, ultimo['numero'])
        if poll:
            participantes_poll = poll.get('participantes', [])
            consolidado = poll.get('consolidado', {})
            plataformas = poll.get('plataformas', {})

            print("\n## ğŸ“Š PrevisÃ£o das Enquetes\n")
            print(f'<p class="text-muted small">Dados agregados de <a href="https://votalhada.blogspot.com/" target="_blank">Votalhada</a> â€” coleta em {poll.get("data_coleta", "?")[:10]} {poll.get("data_coleta", "?")[11:16] if len(poll.get("data_coleta", "")) > 11 else ""}</p>\n')

            print(f'<div class="alert alert-info" style="font-size:0.95rem;">')
            print(f'ğŸ”® <strong>PrevisÃ£o atual:</strong> {consolidado.get("predicao_eliminado", "â€”")} com mais votos para sair ({consolidado.get(consolidado.get("predicao_eliminado", ""), 0):.1f}%)')
            print(f'</div>\n')

            # Platform breakdown table
            print('<table class="table table-striped" style="max-width: 100%; font-size: 1rem;">')
            print('<thead><tr><th>Plataforma</th>')
            for nome in participantes_poll:
                avatar = avatar_img(nome, AVATARS, 28)
                print(f'<th style="text-align:center;">{avatar}</th>')
            print('<th style="text-align:center; color:#888;">Votos</th>')
            print('</tr></thead><tbody>')

            platform_order = ['sites', 'youtube', 'twitter', 'instagram']
            platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

            for plat in platform_order:
                if plat in plataformas:
                    pdata = plataformas[plat]
                    votos = pdata.get('votos', 0)
                    votos_str = f"{votos:,.0f}".replace(',', '.')
                    print(f'<tr><td>{platform_names.get(plat, plat)}</td>')
                    for nome in participantes_poll:
                        val = pdata.get(nome, 0)
                        is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                        style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                        print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
                    print(f'<td style="text-align:center; color:#888; font-size:0.9em;">{votos_str}</td>')
                    print('</tr>')

            # Consolidado row
            total_votos = consolidado.get('total_votos', 0)
            total_str = f"{total_votos:,.0f}".replace(',', '.')
            print(f'<tr style="background:rgba(155,89,182,0.2);"><td style="font-weight:bold;">ğŸ“Š Consolidado</td>')
            for nome in participantes_poll:
                val = consolidado.get(nome, 0)
                is_max = val == max(consolidado.get(n, 0) for n in participantes_poll)
                style = 'font-weight:bold; color:#9b59b6;' if is_max else 'font-weight:bold;'
                print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
            print(f'<td style="text-align:center; color:#888; font-size:0.9em;">{total_str}</td>')
            print('</tr>')

            print('</tbody></table>\n')

            # Time series chart (em_andamento)
            if poll.get('serie_temporal'):
                fig_ts = make_poll_timeseries(poll)
                if fig_ts:
                    fig_ts.show()

        # Resumo da formaÃ§Ã£o (formato compacto)
        print("\n### ğŸ§© Resumo da FormaÃ§Ã£o\n")

        if ultimo.get('formacao'):
            prefixo = "Como foi formado" if n_indicados >= esperado_indicados else "Como estÃ¡ sendo formado"
            print(f"- **{prefixo}:** {ultimo['formacao']}")

        if ultimo.get('lider'):
            print(f"- **LÃ­der:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
            elif n_indicados < esperado_indicados:
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** *Aguardando...*")

        if ultimo.get('anjo'):
            auto = " (autoimune)" if ultimo.get('anjo_autoimune') else ""
            print(f"- **Anjo:** {ultimo['anjo']}{auto}")

        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"- **ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")

        if ultimo.get('dinamica'):
            dinamica = ultimo['dinamica']
            print(f"- **DinÃ¢mica:** {dinamica.get('nome', 'DinÃ¢mica especial')}")
            if dinamica.get('indicaram') and dinamica.get('indicado'):
                ind_list = ', '.join(dinamica['indicaram'])
                print(f"  - Indicaram: {ind_list} â†’ **{dinamica['indicado']}**")
            efeitos = dinamica.get('efeitos', {})
            if efeitos:
                for pessoa, efeito in efeitos.items():
                    print(f"  - {pessoa}: {efeito}")

        if ultimo.get('big_fone'):
            bf = ultimo['big_fone']
            print(f"- **Big Fone:** {bf.get('atendeu', 'â€”')} indicou {bf.get('indicou', 'â€”')}")

        if ultimo.get('contragolpe'):
            cg = ultimo['contragolpe']
            print(f"- **Contragolpe:** {cg.get('de', 'â€”')} â†’ {cg.get('para', 'â€”')}")

        if ultimo.get('bate_volta') is None and n_indicados >= esperado_indicados:
            print("- **Bate e Volta:** nÃ£o haverÃ¡")
        elif ultimo.get('bate_volta'):
            bv = ultimo['bate_volta']
            print(f"- **Bate e Volta:** {', '.join(bv.get('participantes', []))} â€” vencedor: {bv.get('vencedor', 'â€”')}")

        if ultimo.get('impedidos_votar'):
            print(f"- **Impedidos de votar:** {', '.join(ultimo['impedidos_votar'])}")

        if ultimo.get('votos_anulados'):
            print(f"- **Votos anulados:** {', '.join(ultimo['votos_anulados'])}")

        # VotaÃ§Ã£o da casa (formato mais legÃ­vel)
        if tem_votos_casa:
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"**Mais votado:** **{ranking[0][0]}** ({ranking[0][1]} votos)\n")

            print('<table class="table table-striped" style="font-size: 1.05rem;">')
            print('<thead><tr><th>Alvo</th><th style="text-align:center;">Votos</th><th>Votantes</th></tr></thead>')
            print('<tbody>')
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                votantes_html = ' '.join([avatar_img(v, AVATARS, 42) for v in votantes])
                print(f'<tr><td>{avatar_html(alvo, AVATARS, 42)}</td><td style="text-align:center; font-weight:bold; font-size:1.1em;">{n}</td><td>{votantes_html}</td></tr>')
            print('</tbody></table>\n')
        elif n_indicados >= esperado_indicados:
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"*Aguardando divulgaÃ§Ã£o da votaÃ§Ã£o da casa...*")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PAREDÃƒO FINALIZADO â€” Exibir se tem resultado
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if ultimo and (ultimo.get('status') == 'finalizado' or any(p.get('resultado') for p in ultimo.get('participantes', []))):
        df_p = pd.DataFrame(ultimo['participantes'])
        has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

        # â”€â”€ Visual: Cards com fotos e resultado â”€â”€
        print(f'<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 1.5rem 0 2rem 0;">')
        for _, row in df_p.iterrows():
            nome = row['nome']
            grupo = row.get('grupo', MEMBER_OF.get(nome, '?'))
            resultado = row.get('resultado', '')
            voto_total = row.get('voto_total', 0)
            avatar_url = AVATARS.get(nome, '')
            cor_grupo = GROUP_COLORS.get(grupo, '#666')

            # Card styling based on result
            if resultado == 'ELIMINADA':
                border_color = '#E6194B'
                badge_bg = '#E6194B'
                badge_text = 'ELIMINADO(A)'
                img_filter = 'grayscale(100%)'  # B&W for eliminated
            else:
                border_color = '#3CB44B'
                badge_bg = '#3CB44B'
                badge_text = 'SALVO(A)'
                img_filter = 'none'

            print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 3px solid {border_color};">')
            if avatar_url:
                print(f'<img src="{avatar_url}" alt="{nome}" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid {border_color}; margin-bottom: 0.75rem; filter: {img_filter};">')
            print(f'<h4 style="margin: 0 0 0.25rem 0; color: #fff; font-size: 1em; text-align: center;">{nome}</h4>')
            print(f'<span style="display: block; color: {cor_grupo}; font-size: 0.8em; margin-bottom: 0.5rem;">{grupo}</span>')
            print(f'<span style="display: inline-block; padding: 0.25rem 0.6rem; background: {badge_bg}; color: #fff; border-radius: 10px; font-size: 0.75em; font-weight: bold;">{badge_text}</span>')
            print(f'<div style="color: #fff; font-size: 1.3em; font-weight: bold; margin-top: 0.5rem;">{voto_total:.1f}%</div>')
            print('</div>')
        print('</div>')

        fig = go.Figure()

        if has_breakdown:
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_unico'],
                text=[f"{v:.1f}%" for v in df_p['voto_unico']],
                textposition='outside', name='Voto Ãšnico (70%)',
                marker_color='#1976D2',
                hovertemplate='%{x}: %{y:.1f}% (Voto Ãšnico)<extra></extra>',
            ))
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_torcida'],
                text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
                textposition='outside', name='Voto Torcida (30%)',
                marker_color='#FF9800',
                hovertemplate='%{x}: %{y:.1f}% (Voto Torcida)<extra></extra>',
            ))

        colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_total'],
            text=[f"{v:.1f}%" for v in df_p['voto_total']],
            textposition='outside', name='MÃ©dia Final',
            marker_color=colors_total,
            hovertemplate='%{x}: %{y:.1f}% (Final)<extra></extra>',
        ))

        fig.update_layout(
            title=dict(text=ultimo['titulo'], y=0.95, x=0.5, xanchor='center'),
            xaxis_title="", yaxis_title="Votos (%)",
            yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
            barmode='group',
            height=500,
            margin=dict(t=100),
            legend=dict(orientation='h', yanchor='bottom', y=1.08, xanchor='center', x=0.5),
            annotations=[dict(
                text="FÃ³rmula: (Voto Ãšnico Ã— 0,70) + (Voto Torcida Ã— 0,30) = MÃ©dia Final",
                xref="paper", yref="paper", x=0.5, y=-0.12, showarrow=False,
                font=dict(size=11, color='gray')
            )]
        )

        fig.show()

        # â”€â”€ Enquetes vs Resultado (finalizado) â”€â”€
        poll = get_poll_for_paredao(polls_data, ultimo['numero'])
        if poll and poll.get('resultado_real'):
            participantes_poll = poll.get('participantes', [])
            consolidado = poll.get('consolidado', {})
            plataformas = poll.get('plataformas', {})
            resultado = poll['resultado_real']
            accuracy = calculate_poll_accuracy(poll)

            print("\n## ğŸ“Š Enquetes vs Resultado\n")
            print(f'<p class="text-muted small">Dados agregados de <a href="https://votalhada.blogspot.com/" target="_blank">Votalhada</a> â€” coleta em {poll.get("data_coleta", "?")[:10]}</p>\n')

            # Status badge
            if accuracy and accuracy['predicao_correta']:
                status_html = '<span style="background:#3CB44B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âœ… PrevisÃ£o correta</span>'
            else:
                status_html = '<span style="background:#E6194B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âŒ PrevisÃ£o errada</span>'

            erro_medio = accuracy['erro_medio'] if accuracy else 0
            print(f'<div style="text-align:center; margin-bottom:1.5rem;">')
            print(f'{status_html}')
            print(f'<span style="margin-left:1rem; color:#888;">Erro mÃ©dio: <strong>{erro_medio:.1f}</strong> pontos percentuais</span>')
            print(f'</div>\n')

            # Grouped bar chart: Enquetes vs Resultado Real
            fig_poll = go.Figure()
            enquete_vals = [consolidado.get(n, 0) for n in participantes_poll]
            fig_poll.add_trace(go.Bar(
                x=participantes_poll, y=enquete_vals,
                text=[f"{v:.1f}%" for v in enquete_vals],
                textposition='outside', name='Enquete (Consolidado)',
                marker_color='#9b59b6',
                hovertemplate='%{x}: %{y:.1f}% (Enquete)<extra></extra>',
            ))
            resultado_vals = [resultado.get(n, 0) for n in participantes_poll]
            colors_real = ['#E6194B' if n == resultado.get('eliminado') else '#3CB44B' for n in participantes_poll]
            fig_poll.add_trace(go.Bar(
                x=participantes_poll, y=resultado_vals,
                text=[f"{v:.1f}%" for v in resultado_vals],
                textposition='outside', name='Resultado Real',
                marker_color=colors_real,
                hovertemplate='%{x}: %{y:.1f}% (Real)<extra></extra>',
            ))
            fig_poll.update_layout(
                title=dict(text='Enquetes Agregadas vs Resultado Real', y=0.95, x=0.5, xanchor='center'),
                xaxis_title="", yaxis_title="Votos (%)",
                yaxis_range=[0, max(max(enquete_vals), max(resultado_vals)) * 1.25],
                barmode='group',
                height=400,
                margin=dict(t=80, b=60),
                legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
            )
            fig_poll.show()

            # Time series chart (finalizado)
            if poll.get('serie_temporal'):
                fig_ts = make_poll_timeseries(poll, resultado_real=resultado)
                if fig_ts:
                    fig_ts.show()

            # Platform breakdown table
            print("\n### ğŸ“± Por Plataforma\n")
            print('<table class="table table-striped table-hover" style="max-width: 100%; font-size: 1rem;">')
            print('<thead><tr><th>Plataforma</th>')
            for nome in participantes_poll:
                avatar = avatar_img(nome, AVATARS, 28)
                print(f'<th style="text-align:center;">{avatar}</th>')
            print('<th style="text-align:center; color:#888;">Votos</th>')
            print('</tr></thead><tbody>')

            platform_order = ['sites', 'youtube', 'twitter', 'instagram']
            platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}
            platform_colors = {'sites': '#3498db', 'youtube': '#e74c3c', 'twitter': '#1da1f2', 'instagram': '#e1306c'}

            for plat in platform_order:
                if plat in plataformas:
                    pdata = plataformas[plat]
                    votos = pdata.get('votos', 0)
                    votos_str = f"{votos:,.0f}".replace(',', '.')
                    print(f'<tr><td style="font-weight:bold; color:{platform_colors.get(plat, "#fff")}">{platform_names.get(plat, plat)}</td>')
                    for nome in participantes_poll:
                        val = pdata.get(nome, 0)
                        is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                        style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                        print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
                    print(f'<td style="text-align:center; color:#888; font-size:0.9em;">{votos_str}</td>')
                    print('</tr>')

            total_votos = consolidado.get('total_votos', 0)
            total_str = f"{total_votos:,.0f}".replace(',', '.')
            print(f'<tr style="background:rgba(155,89,182,0.2);"><td style="font-weight:bold;">ğŸ“Š Consolidado</td>')
            for nome in participantes_poll:
                val = consolidado.get(nome, 0)
                is_max = val == max(consolidado.get(n, 0) for n in participantes_poll)
                style = 'font-weight:bold; color:#9b59b6;' if is_max else 'font-weight:bold;'
                print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
            print(f'<td style="text-align:center; color:#888; font-size:0.9em;">{total_str}</td>')
            print('</tr>')

            print(f'<tr style="background:rgba(52,152,219,0.2);"><td style="font-weight:bold;">ğŸ† Resultado Real</td>')
            for nome in participantes_poll:
                val = resultado.get(nome, 0)
                is_elim = nome == resultado.get('eliminado')
                style = 'font-weight:bold; color:#E6194B;' if is_elim else 'font-weight:bold; color:#3CB44B;'
                print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
            print('<td style="text-align:center; color:#888;">â€”</td>')
            print('</tr>')
            print('</tbody></table>\n')

            # â”€â”€ AnÃ¡lise de PrecisÃ£o: Enquetes vs Tipos de Voto â”€â”€
            # Get vote breakdown from paredoes.json for this paredÃ£o
            paredao_votos = {}
            for p in ultimo.get('participantes', []):
                nome = p.get('nome')
                if nome and 'voto_total' in p:
                    paredao_votos[nome] = {
                        'voto_unico': p.get('voto_unico', 0),
                        'voto_torcida': p.get('voto_torcida', 0),
                        'voto_total': p.get('voto_total', 0),
                    }

            if paredao_votos:
                eliminado_nome = resultado.get('eliminado')

                # Calculate errors for eliminated person against each vote type
                poll_elim = consolidado.get(eliminado_nome, 0)
                voto_unico_elim = paredao_votos.get(eliminado_nome, {}).get('voto_unico', 0)
                voto_torcida_elim = paredao_votos.get(eliminado_nome, {}).get('voto_torcida', 0)
                voto_total_elim = paredao_votos.get(eliminado_nome, {}).get('voto_total', 0)

                erro_vs_unico = poll_elim - voto_unico_elim
                erro_vs_torcida = poll_elim - voto_torcida_elim
                erro_vs_total = poll_elim - voto_total_elim

                print("\n### ğŸ¯ PrecisÃ£o das Enquetes\n")
                print(f"**{eliminado_nome}** (eliminado): enquete previa **{poll_elim:.1f}%**, resultado real **{voto_total_elim:.1f}%**\n")

                # Table: Poll vs Vote Types
                print('<table class="table table-sm" style="max-width: 600px;">')
                print('<thead><tr><th>ComparaÃ§Ã£o</th><th style="text-align:center;">Enquete</th><th style="text-align:center;">VotaÃ§Ã£o</th><th style="text-align:center;">Erro</th></tr></thead>')
                print('<tbody>')

                vote_types = [
                    ('Voto Ãšnico (70%)', voto_unico_elim, erro_vs_unico),
                    ('Voto Torcida (30%)', voto_torcida_elim, erro_vs_torcida),
                    ('MÃ©dia Final', voto_total_elim, erro_vs_total),
                ]

                # Find which vote type poll was closest to
                closest_type = min(vote_types, key=lambda x: abs(x[2]))

                for vtype, vval, verr in vote_types:
                    is_closest = vtype == closest_type[0]
                    row_style = 'background:rgba(60,180,75,0.2);' if is_closest else ''
                    badge = ' ğŸ¯' if is_closest else ''
                    err_color = '#E6194B' if verr < -5 else '#3CB44B' if abs(verr) < 5 else '#f39c12'
                    print(f'<tr style="{row_style}"><td>{vtype}{badge}</td>')
                    print(f'<td style="text-align:center;">{poll_elim:.1f}%</td>')
                    print(f'<td style="text-align:center;">{vval:.1f}%</td>')
                    print(f'<td style="text-align:center; color:{err_color}; font-weight:bold;">{verr:+.1f} p.p.</td>')
                    print('</tr>')

                print('</tbody></table>\n')

                # Platform accuracy for eliminated person
                print("### ğŸ“± Qual plataforma acertou mais?\n")
                platform_errors = []
                for plat in ['sites', 'youtube', 'twitter', 'instagram']:
                    if plat in plataformas:
                        plat_val = plataformas[plat].get(eliminado_nome, 0)
                        plat_err = abs(plat_val - voto_total_elim)
                        platform_errors.append((plat, plat_val, plat_err))

                # Sort by error (ascending)
                platform_errors.sort(key=lambda x: x[2])

                platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

                print(f'<p>Para <strong>{eliminado_nome}</strong> (resultado: {voto_total_elim:.1f}%):</p>')
                print('<table class="table table-sm" style="max-width: 500px;">')
                print('<thead><tr><th>#</th><th>Plataforma</th><th style="text-align:center;">PrevisÃ£o</th><th style="text-align:center;">Erro</th></tr></thead>')
                print('<tbody>')
                for rank, (plat, pval, perr) in enumerate(platform_errors, 1):
                    medal = 'ğŸ¥‡' if rank == 1 else 'ğŸ¥ˆ' if rank == 2 else 'ğŸ¥‰' if rank == 3 else '4Âº'
                    row_style = 'background:rgba(60,180,75,0.2);' if rank == 1 else ''
                    print(f'<tr style="{row_style}"><td>{medal}</td><td>{platform_names.get(plat, plat)}</td>')
                    print(f'<td style="text-align:center;">{pval:.1f}%</td>')
                    print(f'<td style="text-align:center;">{perr:.1f} p.p.</td>')
                    print('</tr>')
                print('</tbody></table>\n')

                # â”€â”€ Historical comparison across all paredÃµes â”€â”€
                all_polls = polls_data.get('paredoes', [])
                finalized_polls = [p for p in all_polls if p.get('resultado_real')]

                if len(finalized_polls) >= 2:
                    print("### ğŸ“Š PadrÃµes Observados (todos os paredÃµes)\n")

                    total_correct = sum(1 for p in finalized_polls if p['resultado_real'].get('predicao_correta'))
                    total_polls = len(finalized_polls)

                    # Calculate average underestimation of eliminated person
                    underest_sum = 0
                    for p in finalized_polls:
                        elim = p['resultado_real'].get('eliminado')
                        poll_val = p['consolidado'].get(elim, 0)
                        real_val = p['resultado_real'].get(elim, 0)
                        underest_sum += (poll_val - real_val)
                    avg_underest = underest_sum / total_polls

                    # Find best platform across all paredÃµes
                    platform_total_err = {'sites': 0, 'youtube': 0, 'twitter': 0, 'instagram': 0}
                    for p in finalized_polls:
                        elim = p['resultado_real'].get('eliminado')
                        real_val = p['resultado_real'].get(elim, 0)
                        for plat in platform_total_err:
                            if plat in p.get('plataformas', {}):
                                plat_val = p['plataformas'][plat].get(elim, 0)
                                platform_total_err[plat] += abs(plat_val - real_val)

                    best_platform = min(platform_total_err, key=platform_total_err.get)

                    print(f'<div style="background:rgba(52,152,219,0.1); border-radius:12px; padding:1rem; margin:1rem 0;">')
                    print(f'<p style="margin:0;"><strong>âœ… Taxa de acerto:</strong> {total_correct}/{total_polls} paredÃµes ({100*total_correct/total_polls:.0f}%)</p>')
                    print(f'<p style="margin:0.5rem 0 0 0;"><strong>ğŸ“‰ PadrÃ£o:</strong> Enquetes subestimam o eliminado em <strong>{abs(avg_underest):.1f} p.p.</strong> em mÃ©dia</p>')
                    print(f'<p style="margin:0.5rem 0 0 0;"><strong>ğŸ† Plataforma mais precisa:</strong> {platform_names.get(best_platform, best_platform)} (erro mÃ©dio: {platform_total_err[best_platform]/total_polls:.1f} p.p.)</p>')
                    print(f'</div>\n')

        # Resumo da formaÃ§Ã£o (finalizado)
        print("\n### ğŸ§© Resumo da FormaÃ§Ã£o\n")
        if ultimo.get('formacao'):
            print(f"- **Como foi formado:** {ultimo['formacao']}")
        if ultimo.get('lider'):
            print(f"- **LÃ­der:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
        if ultimo.get('anjo'):
            auto = " (autoimune)" if ultimo.get('anjo_autoimune') else ""
            print(f"- **Anjo:** {ultimo['anjo']}{auto}")
        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"- **ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")
        if ultimo.get('dinamica'):
            dinamica = ultimo['dinamica']
            print(f"- **DinÃ¢mica:** {dinamica.get('nome', 'DinÃ¢mica especial')}")
            if dinamica.get('indicaram') and dinamica.get('indicado'):
                ind_list = ', '.join(dinamica['indicaram'])
                print(f"  - Indicaram: {ind_list} â†’ **{dinamica['indicado']}**")
            efeitos = dinamica.get('efeitos', {})
            if efeitos:
                for pessoa, efeito in efeitos.items():
                    print(f"  - {pessoa}: {efeito}")
        if ultimo.get('big_fone'):
            bf = ultimo['big_fone']
            print(f"- **Big Fone:** {bf.get('atendeu', 'â€”')} indicou {bf.get('indicou', 'â€”')}")
        if ultimo.get('contragolpe'):
            cg = ultimo['contragolpe']
            print(f"- **Contragolpe:** {cg.get('de', 'â€”')} â†’ {cg.get('para', 'â€”')}")
        if ultimo.get('bate_volta'):
            bv = ultimo['bate_volta']
            print(f"- **Bate e Volta:** {', '.join(bv.get('participantes', []))} â€” vencedor: {bv.get('vencedor', 'â€”')}")

        # VotaÃ§Ã£o da casa (finalizado)
        if ultimo.get('votos_casa'):
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"**Mais votado:** **{ranking[0][0]}** ({ranking[0][1]} votos)\n")

            print('<table class="table table-striped" style="font-size: 1.05rem;">')
            print('<thead><tr><th>Alvo</th><th style="text-align:center;">Votos</th><th>Votantes</th></tr></thead>')
            print('<tbody>')
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                votantes_html = ' '.join([avatar_img(v, AVATARS, 42) for v in votantes])
                print(f'<tr><td>{avatar_html(alvo, AVATARS, 42)}</td><td style="text-align:center; font-weight:bold; font-size:1.1em;">{n}</td><td>{votantes_html}</td></tr>')
            print('</tbody></table>\n')

```

```{python}
#| label: paredao-prediction
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PREVISÃƒO DE INDICAÃ‡ÃƒO DO LÃDER
# Shown when: no active paredÃ£o, or formation still incomplete.
# Hidden when: formation complete (â‰¥ expected nominees) or finalized.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_show_prediction = False
if ultimo is None:
    _show_prediction = True
elif ultimo.get('status') == 'finalizado':
    _show_prediction = True  # Between paredÃµes
elif ultimo.get('status') == 'em_andamento':
    _n_ind = len(ultimo.get('participantes', []))
    _esp = ultimo.get('total_esperado', 3)
    _show_prediction = _n_ind < _esp  # Formation still incomplete

if _show_prediction:
    # â”€â”€ Load relations scores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _rel_path = Path("data/derived/relations_scores.json")
    _relations = json.loads(_rel_path.read_text(encoding="utf-8")) if _rel_path.exists() else {}
    _pairs_daily = _relations.get("pairs_daily", {}) or _relations.get("pairs", {})
    _rel_edges = _relations.get("edges", [])
    _rel_meta = _relations.get("_metadata", {})
    _display_week = _rel_meta.get("effective_week_daily") or _rel_meta.get("week") or "?"

    # â”€â”€ Detect current LÃ­der + Anjo from roles_daily.json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _rd = json.loads(Path("data/derived/roles_daily.json").read_text(encoding="utf-8"))
    _rd_daily = _rd.get("daily", [])
    _rd_latest = _rd_daily[-1] if _rd_daily else {}
    _lider_list = _rd_latest.get("roles", {}).get("LÃ­der", [])
    _anjo_list = _rd_latest.get("roles", {}).get("Anjo", [])
    _vip_list = _rd_latest.get("vip", [])
    _lider_name = _lider_list[0] if _lider_list else None

    # â”€â”€ Active participant set â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _pix = json.loads(Path("data/derived/participants_index.json").read_text(encoding="utf-8"))
    _pix_list = _pix.get("participants", _pix) if isinstance(_pix, dict) else _pix
    _active_names = {p["name"] for p in _pix_list if p.get("active", True)}

    html_pred = ""

    if not _lider_name:
        html_pred += '<div style="background:#1a1a2e; border:1px solid #444; border-radius:10px; '
        html_pred += 'padding:1.5rem; margin:1rem 0; text-align:center; color:#aaa; font-size:1.1em;">'
        html_pred += 'ğŸ  <strong>Sem lÃ­der ativo</strong> â€” previsÃ£o de indicaÃ§Ã£o indisponÃ­vel.</div>'
    else:
        # â”€â”€ LÃ­der's scores toward all participants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _lider_scores = _pairs_daily.get(_lider_name, {})

        # Eligible targets: active participants minus the LÃ­der
        _eligible = {name: entry for name, entry in _lider_scores.items()
                     if name in _active_names and name != _lider_name}

        # Rank by score ascending (most negative = most likely target)
        _ranked = sorted(_eligible.items(), key=lambda x: x[1].get("score", 0))

        # â”€â”€ Anjo immunity info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _anjo_name = _anjo_list[0] if _anjo_list else None
        _imunizado_nome = None
        if ultimo and ultimo.get('status') == 'em_andamento':
            _imun = ultimo.get('imunizado', {})
            _imunizado_nome = _imun.get('quem') if _imun else None

        # â”€â”€ Component emoji mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _comp_meta = {
            "queridometro": ("ğŸ", "#e74c3c", "#2ecc71"),
            "power_event": ("âš”ï¸", "#e74c3c", "#2ecc71"),
            "sincerao":    ("ğŸ“¢", "#e67e22", "#3498db"),
            "vote":        ("ğŸ—³ï¸", "#e74c3c", "#2ecc71"),
            "vip":         ("ğŸ ", "#3498db", "#3498db"),
            "anjo":        ("ğŸ˜‡", "#3498db", "#3498db"),
        }
        _edge_display = {
            "power_event": ("âš”ï¸", "Power Event"),
            "sincerao": ("ğŸ“¢", "SincerÃ£o"),
            "vote": ("ğŸ—³ï¸", "Voto"),
            "vip": ("ğŸ ", "VIP"),
            "anjo": ("ğŸ˜‡", "Anjo"),
        }

        # â”€â”€ Build queridÃ´metro history (reuse already-loaded snapshots) â”€â”€
        _emoji_map = {
            "CoraÃ§Ã£o": "â¤ï¸", "Planta": "ğŸŒ±", "Cobra": "ğŸ", "Mala": "ğŸ’¼",
            "Biscoito": "ğŸª", "CoraÃ§Ã£o partido": "ğŸ’”", "Alvo": "ğŸ¯",
            "VÃ´mito": "ğŸ¤®", "Mentiroso": "ğŸ¤¥",
        }
        _querido_history = {}
        for _i_snap, _snap_d in enumerate(daily_snapshots):
            _mat = daily_matrices[_i_snap]
            _dt = _snap_d['date']
            for (g, r), lbl in _mat.items():
                if g == _lider_name or r == _lider_name:
                    _querido_history.setdefault((g, r), []).append((_dt, lbl))

        # â”€â”€ Section header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _art = artigo(_lider_name)

        html_pred += '<h2 id="previsao-indicacao">ğŸ¯ PrevisÃ£o â€” IndicaÃ§Ã£o do LÃ­der</h2>'

        html_pred += '<div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); '
        html_pred += 'border:2px solid #e74c3c; border-radius:12px; padding:1.2rem 1.5rem; margin:1rem 0;">'
        html_pred += f'<div style="font-size:1.2em; margin-bottom:0.8rem;">'
        html_pred += f'ğŸ¯ <strong style="color:#e74c3c;">PrevisÃ£o de IndicaÃ§Ã£o d{_art} LÃ­der</strong></div>'

        html_pred += f'<div style="display:flex; align-items:center; gap:0.8rem; margin-bottom:1rem;">'
        html_pred += f'{avatar_img(_lider_name, AVATARS, size=40)}'
        html_pred += f'<span style="font-size:1.1em; color:#eee;"><strong>{_lider_name}</strong> '
        html_pred += f'<span style="color:#888;">â€” LÃ­der da Semana {_display_week}</span></span></div>'

        # â”€â”€ Top 3 summary cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        _top3 = _ranked[:3]
        html_pred += '<div style="display:flex; gap:0.8rem; flex-wrap:wrap; margin-bottom:0.8rem;">'
        for _i, (_tname, _tentry) in enumerate(_top3):
            _sc = _tentry.get("score", 0)
            _color = "#e74c3c" if _sc < -2 else "#e67e22" if _sc < 0 else "#2ecc71"
            _vip_tag = ' <span style="color:#3498db; font-size:0.75em;">VIP</span>' if _tname in _vip_list else ""
            html_pred += f'<div style="background:#111; border:1px solid {_color}; border-radius:8px; '
            html_pred += f'padding:0.6rem 0.8rem; min-width:140px; flex:1;">'
            html_pred += f'<div style="color:#888; font-size:0.75em;">#{_i+1} mais provÃ¡vel</div>'
            html_pred += f'<div style="display:flex; align-items:center; gap:0.4rem; margin:0.3rem 0;">'
            html_pred += f'{avatar_img(_tname, AVATARS, size=24)} '
            html_pred += f'<strong style="color:#eee;">{_tname}</strong>{_vip_tag}</div>'
            html_pred += f'<div style="color:{_color}; font-size:1.1em; font-weight:bold;">{_sc:+.2f}</div>'
            html_pred += '</div>'
        html_pred += '</div>'

        # Anjo note
        if _anjo_name:
            html_pred += f'<div style="color:#3498db; font-size:0.9em;">ğŸ˜‡ Anjo: <strong>{_anjo_name}</strong>'
            if _imunizado_nome:
                html_pred += f' â€” imunizou <strong>{_imunizado_nome}</strong> (bloqueado como alvo)'
            html_pred += '</div>'
        else:
            html_pred += '<div style="color:#888; font-size:0.9em;">ğŸ˜‡ Anjo ainda nÃ£o definido esta semana</div>'

        html_pred += '</div>'

        # â”€â”€ Full ranking table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        html_pred += '<div style="overflow-x:auto; margin-top:1.2rem;">'
        html_pred += '<table style="width:100%; border-collapse:collapse; font-size:0.85em;">'
        html_pred += '<thead><tr style="border-bottom:2px solid #444;">'
        for _hdr in ["#", "Participante", "Score", "Barra", "Componentes", "Reciprocidade", "Streak", "VIP"]:
            html_pred += f'<th style="padding:0.5rem 0.4rem; text-align:left; color:#aaa; white-space:nowrap;">{_hdr}</th>'
        html_pred += '</tr></thead><tbody>'

        _max_abs = max((abs(e.get("score", 0)) for _, e in _ranked), default=1) or 1

        for _rank, (_tname, _tentry) in enumerate(_ranked, 1):
            _sc = _tentry.get("score", 0)
            _comps = _tentry.get("components", {})
            _streak_len = _tentry.get("streak_len", 0)
            _has_break = _tentry.get("break", False)

            _sc_color = "#e74c3c" if _sc < -2 else "#e67e22" if _sc < 0 else "#2ecc71"
            _row_bg = "background:rgba(231,76,60,0.08);" if _rank <= 3 else ""

            _is_immune = (_tname == _imunizado_nome)
            _immune_tag = ' <span style="background:#3498db; color:#fff; font-size:0.7em; padding:1px 4px; border-radius:3px;">IMUNE</span>' if _is_immune else ""

            html_pred += f'<tr style="border-bottom:1px solid #333; {_row_bg}">'
            html_pred += f'<td style="padding:0.4rem; color:#888; text-align:center;">{_rank}</td>'
            html_pred += f'<td style="padding:0.4rem; white-space:nowrap;">{avatar_img(_tname, AVATARS, size=22)} '
            html_pred += f'<strong style="color:#eee;">{_tname}</strong>{_immune_tag}</td>'
            html_pred += f'<td style="padding:0.4rem; color:{_sc_color}; font-weight:bold; font-family:monospace;">{_sc:+.2f}</td>'

            # Score bar
            _bar_pct = min(abs(_sc) / _max_abs * 100, 100)
            _bar_color = "#e74c3c" if _sc < 0 else "#2ecc71"
            _bar_dir = "right" if _sc < 0 else "left"
            html_pred += f'<td style="padding:0.4rem; min-width:80px;">'
            html_pred += f'<div style="width:100%; background:#222; border-radius:3px; height:12px; position:relative;">'
            html_pred += f'<div style="width:{_bar_pct:.0f}%; background:{_bar_color}; height:100%; border-radius:3px; '
            html_pred += f'float:{_bar_dir};"></div></div></td>'

            # Components
            html_pred += f'<td style="padding:0.4rem;">'
            _chips = []
            for _ck, (_ce, _cneg, _cpos) in _comp_meta.items():
                _cv = _comps.get(_ck, 0.0)
                if abs(_cv) < 0.01:
                    continue
                _cc = _cneg if _cv < 0 else _cpos
                _chips.append(
                    f'<span style="background:{_cc}22; color:{_cc}; border:1px solid {_cc}44; '
                    f'border-radius:3px; padding:0px 4px; font-size:0.78em; white-space:nowrap;">'
                    f'{_ce} {_cv:+.2f}</span>'
                )
            html_pred += " ".join(_chips) if _chips else '<span style="color:#555;">â€”</span>'
            html_pred += '</td>'

            # Reciprocity
            _recip_entry = _pairs_daily.get(_tname, {}).get(_lider_name, {})
            _recip_score = _recip_entry.get("score", 0) if _recip_entry else 0

            if _sc < 0 and _recip_score < 0:
                _rl, _rc = "âš”ï¸ MÃºtua", "#e74c3c"
            elif _sc < 0 and _recip_score >= 0:
                _rl, _rc = "ğŸ” Alvo cego", "#e67e22"
            elif _sc >= 0 and _recip_score < 0:
                _rl, _rc = "âš ï¸ Risco oculto", "#e67e22"
            else:
                _rl, _rc = "ğŸ’š Aliados", "#2ecc71"

            html_pred += f'<td style="padding:0.4rem; white-space:nowrap;">'
            html_pred += f'<span style="color:{_rc}; font-size:0.85em;">{_rl}</span> '
            html_pred += f'<span style="color:#888; font-size:0.78em;">({_recip_score:+.2f})</span></td>'

            # Streak
            _si = "ğŸ”´" if _has_break else ("ğŸŸ¢" if _streak_len >= 5 else "âšª")
            _bt = ' <span style="color:#e74c3c; font-size:0.75em;">BREAK</span>' if _has_break else ""
            html_pred += f'<td style="padding:0.4rem; text-align:center; white-space:nowrap;">{_si} {_streak_len}d{_bt}</td>'

            # VIP
            if _tname in _vip_list:
                html_pred += '<td style="padding:0.4rem; text-align:center;">'
                html_pred += '<span style="background:#3498db33; color:#3498db; border:1px solid #3498db55; '
                html_pred += 'border-radius:3px; padding:1px 5px; font-size:0.78em;">VIP</span></td>'
            else:
                html_pred += '<td style="padding:0.4rem; text-align:center; color:#555;">â€”</td>'

            html_pred += '</tr>'

            # â”€â”€ Expandable detail row: edges + queridÃ´metro history â”€â”€â”€â”€
            _pair_edges = [e for e in _rel_edges if
                (e.get("actor") == _lider_name and e.get("target") == _tname) or
                (e.get("actor") == _tname and e.get("target") == _lider_name)]
            _pair_edges.sort(key=lambda e: e.get("date", ""))

            _hist_fwd = _querido_history.get((_lider_name, _tname), [])
            _hist_rev = _querido_history.get((_tname, _lider_name), [])

            if _pair_edges or _hist_fwd:
                html_pred += f'<tr style="{_row_bg}"><td colspan="8" style="padding:0;">'
                html_pred += '<details style="margin:0 0.4rem 0.4rem 1.8rem;">'
                html_pred += '<summary style="cursor:pointer; color:#888; font-size:0.78em; '
                html_pred += f'padding:0.2rem 0;">ğŸ“‹ {len(_pair_edges)} evento(s) Â· '
                html_pred += f'{len(_hist_fwd)} dia(s) de queridÃ´metro</summary>'
                html_pred += '<div style="display:flex; gap:1rem; flex-wrap:wrap; margin-top:0.4rem;">'

                # Edges sub-table
                if _pair_edges:
                    html_pred += '<div style="flex:1; min-width:280px;">'
                    html_pred += '<div style="color:#aaa; font-size:0.78em; margin-bottom:0.3rem;"><strong>Eventos & Edges</strong></div>'
                    html_pred += '<table style="width:100%; border-collapse:collapse; font-size:0.78em;">'
                    html_pred += '<thead><tr style="border-bottom:1px solid #333;">'
                    html_pred += '<th style="padding:2px 4px; color:#666; text-align:left;">Data</th>'
                    html_pred += '<th style="padding:2px 4px; color:#666; text-align:left;">Tipo</th>'
                    html_pred += '<th style="padding:2px 4px; color:#666; text-align:left;">DireÃ§Ã£o</th>'
                    html_pred += '<th style="padding:2px 4px; color:#666; text-align:right;">Peso</th>'
                    html_pred += '<th style="padding:2px 4px; color:#666; text-align:left;">Detalhe</th>'
                    html_pred += '</tr></thead><tbody>'
                    for _edge in _pair_edges:
                        _e_type = _edge.get("type", "?")
                        _e_actor = _edge.get("actor", "")
                        _e_weight = _edge.get("weight", 0)
                        _e_date = _edge.get("date", "?")
                        _e_emoji, _e_label = _edge_display.get(_e_type, ("â“", _e_type))
                        _e_wcolor = "#e74c3c" if _e_weight < 0 else "#2ecc71"
                        _is_backlash = _edge.get("backlash", False)
                        _arrow = f'{_e_actor.split()[0]} â†’ {(_tname if _e_actor == _lider_name else _lider_name).split()[0]}'
                        _detail_parts = []
                        if _edge.get("event_type"):
                            _detail_parts.append(_edge["event_type"])
                        if _edge.get("vote_kind"):
                            _detail_parts.append(_edge["vote_kind"])
                        if _is_backlash:
                            _detail_parts.append('<span style="color:#e67e22;">backlash</span>')
                        _detail_str = " Â· ".join(_detail_parts) if _detail_parts else "â€”"
                        html_pred += f'<tr style="border-bottom:1px solid #222;">'
                        html_pred += f'<td style="padding:2px 4px; color:#888; white-space:nowrap;">{_e_date}</td>'
                        html_pred += f'<td style="padding:2px 4px; white-space:nowrap;">{_e_emoji} {_e_label}</td>'
                        html_pred += f'<td style="padding:2px 4px; color:#aaa; font-size:0.9em;">{_arrow}</td>'
                        html_pred += f'<td style="padding:2px 4px; color:{_e_wcolor}; text-align:right; font-family:monospace;">{_e_weight:+.2f}</td>'
                        html_pred += f'<td style="padding:2px 4px; color:#888;">{_detail_str}</td>'
                        html_pred += '</tr>'
                    html_pred += '</tbody></table></div>'

                # QueridÃ´metro timeline
                if _hist_fwd:
                    _all_dates = sorted(set(d for d, _ in _hist_fwd) | set(d for d, _ in _hist_rev))
                    _fwd_by_date = {d: lbl for d, lbl in _hist_fwd}
                    _rev_by_date = {d: lbl for d, lbl in _hist_rev}
                    _show_dates = _all_dates[-14:]

                    html_pred += '<div style="flex:1; min-width:240px;">'
                    html_pred += '<div style="color:#aaa; font-size:0.78em; margin-bottom:0.3rem;">'
                    html_pred += f'<strong>QueridÃ´metro</strong> (Ãºltimos {len(_show_dates)} dias)</div>'
                    html_pred += '<table style="width:100%; border-collapse:collapse; font-size:0.78em;">'
                    html_pred += '<thead><tr style="border-bottom:1px solid #333;">'
                    html_pred += f'<th style="padding:2px 4px; color:#666; text-align:left;">Data</th>'
                    html_pred += f'<th style="padding:2px 4px; color:#666; text-align:center;">{_lider_name.split()[0]}â†’</th>'
                    html_pred += f'<th style="padding:2px 4px; color:#666; text-align:center;">â†’{_lider_name.split()[0]}</th>'
                    html_pred += '</tr></thead><tbody>'
                    for _dt in _show_dates:
                        _fwd_lbl = _fwd_by_date.get(_dt, "")
                        _rev_lbl = _rev_by_date.get(_dt, "")
                        _fwd_e = _emoji_map.get(_fwd_lbl, "")
                        _rev_e = _emoji_map.get(_rev_lbl, "")
                        _fwd_sent = SENTIMENT_WEIGHTS.get(_fwd_lbl, 0)
                        _rev_sent = SENTIMENT_WEIGHTS.get(_rev_lbl, 0)
                        _fwd_c = "#2ecc71" if _fwd_sent > 0 else "#e74c3c" if _fwd_sent < -0.5 else "#e67e22" if _fwd_sent < 0 else "#555"
                        _rev_c = "#2ecc71" if _rev_sent > 0 else "#e74c3c" if _rev_sent < -0.5 else "#e67e22" if _rev_sent < 0 else "#555"
                        html_pred += f'<tr style="border-bottom:1px solid #222;">'
                        html_pred += f'<td style="padding:1px 4px; color:#888; font-size:0.9em;">{_dt[5:]}</td>'
                        html_pred += f'<td style="padding:1px 4px; text-align:center; color:{_fwd_c};">{_fwd_e}</td>'
                        html_pred += f'<td style="padding:1px 4px; text-align:center; color:{_rev_c};">{_rev_e}</td>'
                        html_pred += '</tr>'
                    html_pred += '</tbody></table></div>'

                html_pred += '</div></details></td></tr>'

        html_pred += '</tbody></table></div>'

        # â”€â”€ Methodology note â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        html_pred += '<div style="background:#111; border:1px solid #333; border-radius:8px; '
        html_pred += 'padding:0.8rem 1rem; margin:1rem 0; font-size:0.82em; color:#888;">'
        html_pred += '<strong style="color:#aaa;">ğŸ“ Metodologia</strong><br>'
        html_pred += 'A previsÃ£o Ã© baseada no <strong>score acumulado do LÃ­der â†’ cada participante</strong>, '
        html_pred += 'calculado pelo sistema de Sentiment Index (queridÃ´metro com memÃ³ria de streak + '
        html_pred += 'eventos de poder, SincerÃ£o, votos e VIP). O participante com o score mais negativo '
        html_pred += 'Ã© o alvo mais provÃ¡vel de indicaÃ§Ã£o. '
        html_pred += 'Membros do VIP foram escolhidos pelo LÃ­der, indicando alianÃ§a â€” sÃ£o alvos improvÃ¡veis. '
        html_pred += '<strong>Isto nÃ£o Ã© um modelo preditivo dedicado</strong> â€” Ã© uma leitura dos dados '
        html_pred += 'de relacionamento acumulados atÃ© o momento.'
        html_pred += '</div>'

    print(html_pred)
```

---

```{python}
#| label: paredao-per-nominee
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PER-NOMINEE ANALYSIS â€” Structured storytelling per nominee
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Uses precomputed data from paredao_analysis.json (built by build_derived_data.py).
# Each nominee gets their own section with context, votes, betrayals, blind spots.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

paredao_analysis_data = {}
_pa_path = Path("data/derived/paredao_analysis.json")
if _pa_path.exists():
    with open(_pa_path) as f:
        paredao_analysis_data = json.load(f)

# Load vote prediction data
_vp_path = Path("data/derived/vote_prediction.json")
vote_pred = json.loads(_vp_path.read_text(encoding="utf-8")) if _vp_path.exists() else {}

if ultimo and ultimo.get('participantes'):
    indicados_list = [p['nome'] for p in ultimo['participantes']]
    par_numero = str(ultimo.get('numero', ''))
    is_finalizado = ultimo.get('status') == 'finalizado'
    analysis_date = ultimo.get('data_formacao') or ultimo.get('data') or latest['date']

    # Load precomputed analysis
    pa_entry = paredao_analysis_data.get("by_paredao", {}).get(par_numero, {})
    qi = pa_entry.get("quick_insights", {})
    va = pa_entry.get("vote_analysis", [])
    vagg = pa_entry.get("vote_aggregates", {})
    per_nominee_data = pa_entry.get("per_nominee", {})
    indicator_reactions = pa_entry.get("indicator_reactions", [])
    rh = pa_entry.get("relationship_history", {})
    indicados_stats = qi.get("indicados_stats", [])

    # Vote prediction data
    vp_entry = vote_pred.get("by_paredao", {}).get(par_numero, {})
    vp_predictions = vp_entry.get("predictions", {})
    vp_aggregate = vp_entry.get("aggregate", {})
    vp_retro = vp_entry.get("retrospective", {})

    votos = ultimo.get('votos_casa', {}) or {}

    # Classify votes into lists
    betrayals = [v for v in va if v["tipo"] in ("falso_amigo", "aliados_mutuos")]
    blind_spots = [v for v in va if v["tipo"] == "ponto_cego"]

    n_traicoes = vagg.get("n_traicoes", 0)
    n_pontos_cegos = vagg.get("n_pontos_cegos", 0)
    n_esperados = vagg.get("n_esperados", 0)
    total_votes = vagg.get("total_votes", 0)
    rel_counts = vagg.get("relationship_counts", {})

    if is_finalizado:
        analysis_date_label = f"ğŸ“… Dados de **{qi.get('analysis_date', analysis_date)}** (dia da formaÃ§Ã£o)"
    else:
        analysis_date_label = f"ğŸ“… Dados de **{latest['label']}** (atual)"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SECTION 1: A HistÃ³ria do NÂº ParedÃ£o (global brief narrative)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print(f"## ğŸ“– A HistÃ³ria do {ultimo['numero']}Âº ParedÃ£o\n")

    if is_finalizado:
        print(f'<div class="alert alert-secondary" style="font-size: 0.9rem;">')
        print(f'{analysis_date_label} â€” anÃ¡lise histÃ³rica congelada no momento da formaÃ§Ã£o.')
        print(f'</div>\n')

    # Opening narrative
    if total_votes > 0:
        if n_traicoes >= 3:
            print(f"Um paredÃ£o marcado por **{n_traicoes} traiÃ§Ãµes** â€” votos de quem dava â¤ï¸ ao alvo no queridÃ´metro. ")
            print(f"A dissimulaÃ§Ã£o dominou a votaÃ§Ã£o da casa.\n")
        elif n_pontos_cegos >= 3:
            print(f"Um paredÃ£o de **pontos cegos** â€” {n_pontos_cegos} votos de pessoas que o alvo considerava aliadas, ")
            print(f"mas que secretamente davam reaÃ§Ãµes negativas.\n")
        elif n_esperados >= total_votes * 0.5:
            print(f"Uma votaÃ§Ã£o **previsÃ­vel**: {n_esperados} de {total_votes} votos ({n_esperados*100//total_votes}%) ")
            print(f"vieram de quem jÃ¡ dava reaÃ§Ãµes negativas no queridÃ´metro.\n")
        else:
            print(f"Uma votaÃ§Ã£o **estratÃ©gica** â€” a mistura de traiÃ§Ãµes ({n_traicoes}), pontos cegos ({n_pontos_cegos}) ")
            print(f"e votos esperados ({n_esperados}) revela um jogo complexo.\n")

        # Coherence one-liner
        n_aligned = sum(1 for v in va if v["tipo"] in ("inimigos_declarados", "hostilidade_forte", "hostilidade_leve"))
        pct_aligned = (n_aligned / total_votes * 100) if total_votes else 0
        print(f"**CoerÃªncia social:** {n_aligned}/{total_votes} votos ({pct_aligned:.0f}%) estavam alinhados com o queridÃ´metro.\n")

        # Model accuracy summary
        if vp_retro and is_finalizado:
            vp_ind = vp_retro.get("individual", {})
            vp_hc = vp_retro.get("high_confidence", {})
            if vp_ind.get("total", 0) > 0:
                print(f"ğŸ¤– **PrevisÃ£o do modelo:** acertou {vp_ind['correct']}/{vp_ind['total']} votos ({vp_ind['pct']:.1f}%)", end="")
                if vp_hc.get("total", 0) > 0:
                    print(f" Â· Alta confianÃ§a: {vp_hc['correct']}/{vp_hc['total']} ({vp_hc['pct']:.1f}%)")
                else:
                    print()
                print()

                # Side-by-side predicted vs actual vote concentration (compact HTML bars)
                vote_concentration = vp_aggregate.get("vote_concentration", {})
                actual_votes = Counter(votos.values()) if votos else {}
                all_targets = sorted(set(list(vote_concentration.keys()) + list(actual_votes.keys())),
                                     key=lambda n: -(vote_concentration.get(n, 0) + actual_votes.get(n, 0)))
                if all_targets and actual_votes:
                    max_count = max(max(vote_concentration.values(), default=1), max(actual_votes.values(), default=1))
                    print('<div style="display:flex; gap:2rem; flex-wrap:wrap; margin-bottom:1rem;">')
                    # Predicted
                    print('<div style="flex:1; min-width:250px;">')
                    print('<div style="font-size:0.85em; color:#888; margin-bottom:4px;">ğŸ“Š PrevisÃ£o do modelo</div>')
                    for tgt in all_targets[:6]:
                        cnt = vote_concentration.get(tgt, 0)
                        pct_bar = (cnt / max_count * 100) if max_count else 0
                        print(f'<div style="display:flex; align-items:center; gap:6px; margin:2px 0;">')
                        print(f'<span style="width:80px; font-size:0.8em; text-align:right;">{tgt.split()[0]}</span>')
                        print(f'<div style="flex:1; background:#333; border-radius:3px; height:14px;">')
                        print(f'<div style="width:{pct_bar}%; background:#9b59b6; height:100%; border-radius:3px;"></div></div>')
                        print(f'<span style="font-size:0.8em; width:20px;">{cnt}</span></div>')
                    print('</div>')
                    # Actual
                    print('<div style="flex:1; min-width:250px;">')
                    print('<div style="font-size:0.85em; color:#888; margin-bottom:4px;">ğŸ—³ï¸ VotaÃ§Ã£o real</div>')
                    for tgt in all_targets[:6]:
                        cnt = actual_votes.get(tgt, 0)
                        pct_bar = (cnt / max_count * 100) if max_count else 0
                        print(f'<div style="display:flex; align-items:center; gap:6px; margin:2px 0;">')
                        print(f'<span style="width:80px; font-size:0.8em; text-align:right;">{tgt.split()[0]}</span>')
                        print(f'<div style="flex:1; background:#333; border-radius:3px; height:14px;">')
                        print(f'<div style="width:{pct_bar}%; background:#3498db; height:100%; border-radius:3px;"></div></div>')
                        print(f'<span style="font-size:0.8em; width:20px;">{cnt}</span></div>')
                    print('</div>')
                    print('</div>\n')
        # Scatter insight as narrative
        if pct_aligned >= 60:
            print(f"Os votos **seguiram** as reaÃ§Ãµes â€” a maioria votou conforme o queridÃ´metro sugeria.\n")
        elif pct_aligned <= 30:
            print(f"Os votos **nÃ£o seguiram** as reaÃ§Ãµes â€” muita divergÃªncia entre queridÃ´metro e urna.\n")
        else:
            print(f"Resultado misto: parte dos votos seguiu o queridÃ´metro, parte foi por estratÃ©gia.\n")
    else:
        print("Aguardando votaÃ§Ã£o da casa para anÃ¡lise completa.\n")

        # em_andamento: show predictions even before house votes
        if vp_predictions and not is_finalizado:
            vote_concentration = vp_aggregate.get("vote_concentration", {})
            if vote_concentration:
                top_predicted = max(vote_concentration, key=vote_concentration.get)
                print(f"ğŸ¤– **PrevisÃ£o do modelo:** {vote_concentration[top_predicted]} votos previstos para {top_predicted}.\n")

    # â”€â”€ Anatomia dos Votos chart (keep) â”€â”€
    if total_votes > 0 and rel_counts:
        print("### Anatomia dos Votos\n")
        rel_order = [
            ('aliados_mutuos', 'ğŸ’” TraiÃ§Ã£o de Aliado', '#9b59b6'),
            ('falso_amigo', 'ğŸ­ Falso Amigo', '#E6194B'),
            ('ponto_cego', 'ğŸ¯ Ponto Cego', '#f39c12'),
            ('inimigos_declarados', 'âš”ï¸ Hostilidade MÃºtua', '#3CB44B'),
            ('hostilidade_forte', 'ğŸ Hostilidade Forte', '#3CB44B'),
            ('hostilidade_leve', 'ğŸŒ± Hostilidade Leve', '#FF9800'),
            ('neutro', 'â“ Neutro', '#999'),
        ]
        labels_chart = []
        values_chart = []
        colors_chart = []
        for tipo, label, cor in rel_order:
            count = rel_counts.get(tipo, 0)
            if count > 0:
                labels_chart.append(label)
                values_chart.append(count)
                colors_chart.append(cor)

        if labels_chart:
            fig_anat = go.Figure(go.Bar(
                y=labels_chart[::-1], x=values_chart[::-1],
                orientation='h',
                marker_color=colors_chart[::-1],
                text=[str(v) for v in values_chart[::-1]],
                textposition='auto',
                textfont=dict(size=14, color='white'),
            ))
            fig_anat.update_layout(
                title="DistribuiÃ§Ã£o dos Votos por Tipo de Relacionamento",
                xaxis_title="NÃºmero de Votos", yaxis_title="",
                height=max(250, 60 * len(labels_chart)),
                margin=dict(l=200),
                showlegend=False,
            )
            fig_anat.show()
            print()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SECTION 2: Per-Nominee Loop
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Build the complete nominees list including BV survivors
    all_nominees = list(ultimo.get('participantes', []))
    bv = ultimo.get('bate_volta') or {}
    bv_survivors = set()
    if bv and bv.get('vencedor'):
        bv_survivors.add(bv['vencedor'])
        existing_names = {p['nome'] for p in all_nominees}
        if bv['vencedor'] not in existing_names:
            all_nominees.append({
                'nome': bv['vencedor'],
                'grupo': MEMBER_OF.get(bv['vencedor'], '?'),
                'como': 'Bate e Volta (escapou)',
                '_bv_escapee': True,
            })

    # Sort: eliminado first â†’ by house votes desc â†’ BV survivors last
    resultado = ultimo.get('resultado', {}) if is_finalizado else {}
    eliminado_nome = resultado.get('eliminado', '') if resultado else ''

    def _nominee_sort_key(p):
        nome = p['nome']
        if nome == eliminado_nome:
            return (0, 0, nome)
        if p.get('_bv_escapee'):
            return (2, 0, nome)
        pn = per_nominee_data.get(nome, {})
        return (1, -pn.get('n_votes', 0), nome)

    all_nominees.sort(key=_nominee_sort_key)

    for nominee in all_nominees:
        nome = nominee['nome']
        grupo = nominee.get('grupo', MEMBER_OF.get(nome, '?'))
        como = nominee.get('como', '')
        is_bv_escapee = nominee.get('_bv_escapee', False)
        pn = per_nominee_data.get(nome, {})

        # â”€â”€ A. Header + Context â”€â”€
        badge_text, badge_color, badge_emoji = get_nominee_badge(nome, ultimo, bv_survivors)
        grupo_color = GROUP_COLORS.get(grupo, '#888')

        print(f"\n### {badge_emoji} O Caso {nome}\n")
        print(f'<div style="display:flex; align-items:center; gap:16px; margin-bottom:12px;">')
        print(f'{avatar_img(nome, AVATARS, 64)}')
        print(f'<div>')
        print(f'<span style="background:{badge_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.95em;">{badge_text}</span>')
        print(f' <span style="color:{grupo_color}; font-weight:500; margin-left:8px;">{grupo}</span>')
        print(f'</div></div>\n')

        # How they got there
        if como:
            print(f"**Como chegou ao paredÃ£o:** {como}\n")

        # Vote percentages (if finalized)
        if is_finalizado and not is_bv_escapee:
            votos_part = resultado.get('votos', {}).get(nome, {})
            if votos_part:
                vu = votos_part.get('voto_unico', 0)
                vt = votos_part.get('voto_torcida', 0)
                vtotal = votos_part.get('voto_total', 0)
                print(f"**Resultado:** Voto Ãšnico {vu:.2f}% Â· Torcida {vt:.2f}% Â· **MÃ©dia Final {vtotal:.2f}%**\n")

        # â”€â”€ B. IndicaÃ§Ã£o Analysis (only for power-indicated nominees) â”€â”€
        # Detect indicator type from 'como' field
        nominee_indicators = [ir for ir in indicator_reactions if ir['target'] == nome]

        if nominee_indicators:
            for ir in nominee_indicators:
                actor = ir['actor']
                ind_type = ir['type']
                type_labels = {'lider': 'ğŸ‘‘ IndicaÃ§Ã£o do LÃ­der', 'contragolpe': 'ğŸŒ€ Contragolpe',
                               'big_fone': 'ğŸ“ Big Fone', 'dinamica': 'ğŸ² DinÃ¢mica'}
                type_label = type_labels.get(ind_type, ind_type.replace('_', ' ').title())

                print(f"#### {type_label}\n")
                print(f"**{actor}** indicou **{nome}**.\n")

                # Bidirectional reaction table
                a2t = ir.get('actor_to_target', '?')
                t2a = ir.get('target_to_actor', '?')
                print('<table class="table" style="max-width:500px; font-size:1.05rem;">')
                print(f'<thead><tr><th>DireÃ§Ã£o</th><th style="text-align:center;">ReaÃ§Ã£o</th></tr></thead>')
                print(f'<tbody>')
                print(f'<tr><td>{avatar_html(actor, AVATARS, 28)} â†’ {nome}</td><td style="text-align:center; font-size:1.3em;">{a2t}</td></tr>')
                print(f'<tr><td>{avatar_html(nome, AVATARS, 28)} â†’ {actor}</td><td style="text-align:center; font-size:1.3em;">{t2a}</td></tr>')
                print(f'</tbody></table>\n')

                # Relationship classification
                a2t_raw = ir.get('actor_to_target_raw', '')
                t2a_raw = ir.get('target_to_actor_raw', '')
                a_pos = a2t_raw in POSITIVE
                t_pos = t2a_raw in POSITIVE
                a_neg = a2t_raw in (MILD_NEGATIVE | STRONG_NEGATIVE)
                t_neg = t2a_raw in (MILD_NEGATIVE | STRONG_NEGATIVE)

                if a_pos and t_pos:
                    print(f"ğŸ’” **Aliados mÃºtuos** â€” ambos davam â¤ï¸. IndicaÃ§Ã£o surpreendente.\n")
                elif a_neg and t_neg:
                    print(f"âš”ï¸ **Hostilidade mÃºtua** â€” ambos davam negativo. IndicaÃ§Ã£o esperada.\n")
                elif a_neg and t_pos:
                    print(f"ğŸ¯ **Ponto cego** â€” {nome} dava â¤ï¸ a {actor}, que secretamente dava negativo. {nome} nÃ£o via vir.\n")
                elif a_pos and t_neg:
                    print(f"ğŸ­ **Falso amigo** â€” {actor} dava â¤ï¸ a {nome} mas indicou mesmo assim. TraiÃ§Ã£o.\n")
                elif a_neg:
                    print(f"ğŸ **Hostilidade unilateral** â€” {actor} dava negativo. IndicaÃ§Ã£o coerente com o queridÃ´metro.\n")
                else:
                    print(f"â“ RelaÃ§Ã£o neutra ou sem dados claros no queridÃ´metro.\n")

                # Historical pattern
                key_fwd = f"{actor}â†’{nome}"
                hist = rh.get(key_fwd, {})
                if hist.get('pattern') and hist['pattern'] != 'sem_dados':
                    print(f"**HistÃ³rico:** {hist.get('narrative', '')}\n")

        # â”€â”€ C. QueridÃ´metro Snapshot â”€â”€
        stat = next((s for s in indicados_stats if s['nome'] == nome), None)
        if stat:
            print(f"#### ğŸ“Š QueridÃ´metro\n")
            sent_val = stat['sentimento']
            sent_color = '#4CAF50' if sent_val >= 0 else '#E6194B'
            delta = stat.get('delta_3d', 'â€”')
            delta_color = '#4CAF50' if 'â–²' in str(delta) or '+' in str(delta) else ('#E6194B' if 'â–¼' in str(delta) else '#888')

            print('<table class="table" style="max-width:600px; font-size:1.0rem;">')
            print('<thead><tr><th>Sentimento</th><th>Rank</th><th>Î” 3 dias</th><th>Top 5</th><th>Bottom 5</th><th>Dias neg.</th></tr></thead>')
            print(f'<tbody><tr>')
            print(f'<td style="color:{sent_color}; font-weight:bold; font-size:1.1em;">{sent_val:+.1f}</td>')
            print(f'<td>{stat.get("rank", "â€”")}</td>')
            print(f'<td style="color:{delta_color}; font-weight:500;">{delta}</td>')
            print(f'<td>{stat.get("dias_top5", 0)}</td>')
            print(f'<td>{stat.get("dias_bottom5", 0)}</td>')
            print(f'<td>{stat.get("dias_negativos", "â€”")}</td>')
            print(f'</tr></tbody></table>\n')

        # â”€â”€ D. Quem Votou em [Name]? â”€â”€
        votes_for_nominee = [v for v in va if v['alvo'] == nome]
        n_votes = pn.get('n_votes', len(votes_for_nominee))
        n_enemies = pn.get('from_enemies', 0)
        n_traitors = pn.get('from_traitors', 0)
        n_blind = pn.get('from_blind', 0)

        # Pre-compute prediction metrics (used in summary + conclusion)
        vp_predicted_votes_for = vp_aggregate.get("vote_concentration", {}).get(nome, 0) if vp_predictions else 0
        vp_correct_for_nominee = sum(
            1 for v in votes_for_nominee
            if vp_predictions.get(v['votante'], {}).get('predicted') == nome
        ) if vp_predictions else 0
        vp_surprise_votes = n_votes - vp_correct_for_nominee

        if n_votes > 0:

            print(f"#### ğŸ—³ï¸ Quem Votou em {nome}?\n")
            print(f"**{n_votes} votos** recebidos", end="")
            parts = []
            if n_enemies:
                parts.append(f"{n_enemies} de inimigos")
            if n_traitors:
                parts.append(f"{n_traitors} traiÃ§Ãµes")
            if n_blind:
                parts.append(f"{n_blind} pontos cegos")
            if parts:
                print(f" â€” {', '.join(parts)}.", end="")
            print("\n")

            # Per-nominee prediction summary
            if vp_predictions and is_finalizado and (vp_predicted_votes_for > 0 or vp_correct_for_nominee > 0):
                if vp_predicted_votes_for == n_votes:
                    print(f"O modelo previa {vp_predicted_votes_for} votos para {nome} (real: {n_votes}) â€” acertou {vp_correct_for_nominee} dos {n_votes} votantes.\n")
                elif vp_predicted_votes_for > n_votes:
                    print(f"O modelo previa {vp_predicted_votes_for} votos para {nome} (real: {n_votes}) â€” superestimou a rejeiÃ§Ã£o.\n")
                else:
                    if vp_surprise_votes > 0:
                        print(f"O modelo previa {vp_predicted_votes_for} votos para {nome} (real: {n_votes}) â€” {vp_surprise_votes} voto(s) surpresa.\n")
                    else:
                        print(f"O modelo previa {vp_predicted_votes_for} votos para {nome} (real: {n_votes}).\n")

            # Voter table
            has_vp = bool(vp_predictions)
            print('<table class="table table-striped" style="max-width:850px; font-size:1.0rem;">')
            print('<thead><tr><th>Votante</th><th style="text-align:center;">Deu</th><th style="text-align:center;">Recebeu</th><th>Tipo</th><th>HistÃ³rico</th>', end="")
            if has_vp:
                print('<th style="text-align:center;">Prev.</th>', end="")
            print('</tr></thead>')
            print('<tbody>')

            pattern_emoji = {
                'sempre_amigos': 'ğŸ’š', 'sempre_inimigos': 'ğŸ’€', 'ex_amigos': 'ğŸ’”',
                'recem_inimigos': 'âš¡', 'reconciliados': 'ğŸ•Šï¸', 'instavel': 'ğŸ”„', 'sem_dados': 'â€”',
            }

            for v in votes_for_nominee:
                votante = v['votante']
                emoji_dado = v.get('emoji_dado', '?')
                emoji_recebido = v.get('emoji_recebido', '?')
                tipo_label = v.get('label', '?')
                hist_pat = v.get('hist_pattern', 'sem_dados')
                hist_emoji = pattern_emoji.get(hist_pat, 'â€”')
                hist_narr = v.get('hist_narrative', '')
                print(f'<tr>')
                print(f'<td>{avatar_html(votante, AVATARS, 28)}</td>')
                print(f'<td style="text-align:center; font-size:1.2em;">{emoji_dado}</td>')
                print(f'<td style="text-align:center; font-size:1.2em;">{emoji_recebido}</td>')
                print(f'<td style="font-size:0.9em;">{tipo_label}</td>')
                print(f'<td style="font-size:0.85em;" title="{hist_narr}">{hist_emoji} {hist_narr}</td>')
                if has_vp:
                    pred = vp_predictions.get(votante, {})
                    if not pred:
                        print(f'<td style="text-align:center; color:#666;">â€”</td>')
                    elif pred.get('predicted') == nome:
                        conf = pred.get('confidence', '')
                        print(f'<td style="text-align:center; color:#3CB44B; font-size:0.85em;">âœ… {conf}</td>')
                    else:
                        pred_target = pred.get('predicted', '?')
                        short_name = pred_target.split()[0]
                        print(f'<td style="text-align:center; color:#E6194B; font-size:0.85em;">âŒâ†’{short_name}</td>')
                print(f'</tr>')
            print('</tbody></table>\n')
        elif not is_bv_escapee:
            print(f"*{nome} nÃ£o recebeu votos da casa â€” chegou ao paredÃ£o por indicaÃ§Ã£o direta.*\n")

        # â”€â”€ E. Destaques (conditional) â”€â”€
        nominee_betrayals = [v for v in betrayals if v['alvo'] == nome]
        nominee_blind = [v for v in blind_spots if v['alvo'] == nome]
        # Temporal insights: ex-amigos/recem-inimigos NOT already in betrayals/blind_spots
        betrayal_voters = {v['votante'] for v in nominee_betrayals}
        blind_voters = {v['votante'] for v in nominee_blind}
        nominee_temporal = [v for v in votes_for_nominee
                           if v.get('hist_pattern') in ('ex_amigos', 'recem_inimigos')
                           and v['votante'] not in betrayal_voters
                           and v['votante'] not in blind_voters]

        has_highlights = nominee_betrayals or nominee_blind or nominee_temporal
        if has_highlights:
            print(f"#### Destaques\n")
            for b in nominee_betrayals:
                pat = b.get('hist_pattern', '')
                votante = b['votante']
                cd = b.get('change_date') or ''
                if pat == 'sempre_amigos':
                    print(f"- ğŸ—¡ï¸ **TraiÃ§Ã£o de longa data:** {votante} dava â¤ï¸ por {b.get('days_as_friends', '?')} dias e mesmo assim votou contra")
                elif pat == 'ex_amigos' and cd:
                    print(f"- ğŸ’” **Ex-amigos:** {votante} e {nome} eram aliados, romperam em {cd}")
                else:
                    print(f"- ğŸ’” **TraiÃ§Ã£o:** {votante} dava â¤ï¸ a {nome} mas votou contra")
            for bs in nominee_blind:
                print(f"- ğŸ¯ **Ponto cego:** {nome} dava â¤ï¸ a {bs['votante']}, que secretamente dava {bs.get('emoji_dado', '?')}")
            # Temporal: summarize if many (>3), list individually if few
            if len(nominee_temporal) > 3:
                ex_names = [t['votante'] for t in nominee_temporal if t.get('hist_pattern') == 'ex_amigos']
                rec_names = [t['votante'] for t in nominee_temporal if t.get('hist_pattern') == 'recem_inimigos']
                if ex_names:
                    print(f"- ğŸ’” **{len(ex_names)} ex-amigos** votaram contra: {', '.join(ex_names)}")
                if rec_names:
                    print(f"- âš¡ **{len(rec_names)} mudanÃ§as recentes**: {', '.join(rec_names)}")
            else:
                for t in nominee_temporal:
                    cd = t.get('change_date') or ''
                    if t.get('hist_pattern') == 'recem_inimigos':
                        print(f"- âš¡ **MudanÃ§a recente:** {t['votante']} mudou de â¤ï¸ para negativo hÃ¡ pouco tempo")
                    elif t.get('hist_pattern') == 'ex_amigos' and cd:
                        print(f"- ğŸ’” **Ex-amigos:** {t['votante']} rompeu com {nome} em {cd}")
                    elif t.get('hist_pattern') == 'ex_amigos':
                        print(f"- ğŸ’” **Ex-amigos:** {t['votante']} e {nome} se afastaram")
            print()

        # â”€â”€ F. Narrative Conclusion â”€â”€
        if n_votes > 0:
            if n_traitors >= n_votes * 0.5 and n_traitors >= 2:
                sufixo = 'a' if genero(nome) == 'f' else 'o'
                print(f"**ConclusÃ£o:** {nome} foi **apunhalad{sufixo} pelas costas** â€” mais da metade dos votos veio de quem dava â¤ï¸ no queridÃ´metro.\n")
            elif n_blind >= 2:
                print(f"**ConclusÃ£o:** {nome} **nÃ£o viu seus inimigos chegando** â€” {n_blind} votos de pessoas que {artigo(nome)} considerava aliadas.\n")
            elif n_enemies >= n_votes * 0.7:
                print(f"**ConclusÃ£o:** {nome} foi **alvo previsÃ­vel** â€” a maioria dos votos veio de quem jÃ¡ dava negativo no queridÃ´metro.\n")
            else:
                print(f"**ConclusÃ£o:** VotaÃ§Ã£o mista para {nome} â€” combinaÃ§Ã£o de inimizades, estratÃ©gia e contradiÃ§Ãµes.\n")

            # Prediction context in conclusion
            if vp_predictions and is_finalizado:
                if vp_correct_for_nominee >= n_votes * 0.8:
                    print(f"*ğŸ¤– O modelo previu com precisÃ£o a maioria dos votos â€” resultado coerente com o queridÃ´metro.*\n")
                elif vp_surprise_votes >= 3:
                    print(f"*ğŸ¤– {vp_surprise_votes} votos nÃ£o previstos pelo modelo sugerem coordenaÃ§Ã£o estratÃ©gica ou alianÃ§as nÃ£o capturadas pelo queridÃ´metro.*\n")
                elif vp_predicted_votes_for > n_votes + 2:
                    over = vp_predicted_votes_for - n_votes
                    print(f"*ğŸ¤– O modelo superestimou a rejeiÃ§Ã£o â€” {over} votantes que pareciam inimigos pelo queridÃ´metro votaram em outro alvo.*\n")
        elif is_bv_escapee:
            sufixo = 'a' if genero(nome) == 'f' else 'o'
            print(f"**ConclusÃ£o:** {nome} **escapou pelo Bate e Volta** â€” foi indicad{sufixo} mas venceu a prova e saiu do paredÃ£o.\n")
        else:
            sufixo = 'a' if genero(nome) == 'f' else 'o'
            print(f"**ConclusÃ£o:** {nome} chegou ao paredÃ£o **apenas por indicaÃ§Ã£o direta** â€” sem votos da casa.\n")

else:
    print("*Aguardando dados do paredÃ£o para anÃ¡lise.*")

```

---

::: {.callout-note title="ğŸ“š Ver mais" appearance="simple"}
Quer ver os paredÃµes anteriores? Acesse o **[Arquivo de ParedÃµes](paredoes.html)** com votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o.
:::

::: {.callout-caution title="â„¹ï¸ Sobre os dados (limitaÃ§Ãµes e melhorias)" appearance="minimal" collapse="true"}
- **Data de formaÃ§Ã£o**: a anÃ¡lise usa o queridÃ´metro do **dia da formaÃ§Ã£o** (`data_formacao`). Se faltou snapshot do dia, usamos o mais prÃ³ximo anterior.
- **QueridÃ´metro Ã© privado**: contradiÃ§Ãµes nÃ£o significam falsidade â€” podem ser **estratÃ©gia** (consenso, alvo fÃ¡cil, proteÃ§Ã£o de aliados).
- **Emojis leves** (ğŸŒ±ğŸ’¼ğŸªğŸ’”) sÃ£o negativos mas nÃ£o equivalem a hostilidade forte.  
  **Melhoria prevista**: ponderar mais forte ğŸğŸ¯ğŸ¤®ğŸ¤¥ e reduzir peso de negativos leves nas leituras de coerÃªncia.
- **Timing do jogo**: entre eliminaÃ§Ã£o e nova lideranÃ§a, as relaÃ§Ãµes podem mudar rÃ¡pido.  
  **Melhoria prevista**: permitir â€œmÃ©dia mÃ³velâ€ de 2â€“3 dias na semana da formaÃ§Ã£o.
:::

::: {.callout-tip title="ğŸ§­ NavegaÃ§Ã£o"}
- [ğŸ“Š Painel](index.html) â€” Estado atual das reaÃ§Ãµes
- [ğŸ“ˆ EvoluÃ§Ã£o](evolucao.html) â€” Rankings, sentimento e pulso diÃ¡rio
- [ğŸ¤ RelaÃ§Ãµes](relacoes.html) â€” Mapa social, alianÃ§as e rivalidades
- [ğŸ“š Arquivo](paredoes.html) â€” HistÃ³rico de paredÃµes
:::
