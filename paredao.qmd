---
title: "BBB 26 â€” ParedÃ£o"
subtitle: "Acompanhe o paredÃ£o atual: formaÃ§Ã£o, votaÃ§Ã£o e anÃ¡lise de reaÃ§Ãµes"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    load_snapshot, get_all_snapshots, parse_roles, build_reaction_matrix,
    require_clean_manual_events, calc_sentiment, setup_bbb_dark_theme,
    REACTION_EMOJI, REACTION_SLUG_TO_LABEL, SENTIMENT_WEIGHTS,
    POSITIVE, MILD_NEGATIVE, STRONG_NEGATIVE, GROUP_COLORS,
)

require_clean_manual_events()
setup_bbb_dark_theme()

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

MEMBER_OF = {}  # preenchido ao carregar dados
```

```{python}
#| label: load-data

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

def avatar_html(name, size=24):
    """Generate HTML for participant avatar + name."""
    url = AVATARS.get(name, '')
    if url:
        return f'<img src="{url}" width="{size}" height="{size}" style="border-radius:50%; vertical-align:middle; margin-right:6px;" alt="{name}">{name}'
    return name

def avatar_img(name, size=24):
    """Generate just the avatar image HTML."""
    url = AVATARS.get(name, '')
    if url:
        return f'<img src="{url}" width="{size}" height="{size}" style="border-radius:50%;" alt="{name}" title="{name}">'
    return ''

# Enriquecer cada snapshot com label legÃ­vel e flag de sintÃ©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (Ãºltima do dia) â€” usada para anÃ¡lises de reaÃ§Ãµes
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)
```

```{python}
#| label: data-freshness
#| output: asis

# Data freshness shown in header area
print(f'<p class="text-muted small mb-0">ğŸ“… Dados de <strong>{latest["label"]}</strong> Â· {n_daily} dias de histÃ³rico</p>')
```

```{python}
#| label: paredao-results
#| output: asis

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  CARREGAR DADOS DE PAREDÃƒO DO JSON                          â•‘
# â•‘  Fonte: data/paredoes.json (atualizado manualmente)         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAREDOES_FILE = Path("data/paredoes.json")

def load_paredoes():
    """Carrega dados de paredÃ£o do arquivo JSON."""
    if not PAREDOES_FILE.exists():
        return []
    with open(PAREDOES_FILE, encoding="utf-8") as f:
        data = json.load(f)

    # Convert JSON structure to the format expected by the dashboard
    paredoes = []
    for p in data.get('paredoes', []):
        entry = {
            'numero': p['numero'],
            'status': p['status'],
            'data': p['data'],
            'titulo': p['titulo'],
            'lider': p.get('formacao', {}).get('lider'),
            'indicado_lider': p.get('formacao', {}).get('indicado_lider'),
            'motivo_lider': p.get('formacao', {}).get('motivo_lider'),
            'anjo': p.get('formacao', {}).get('anjo'),
            'anjo_autoimune': p.get('formacao', {}).get('anjo_autoimune'),
            'formacao': p.get('formacao', {}).get('resumo', ''),
            'dinamica': p.get('formacao', {}).get('dinamica'),
            'big_fone': p.get('formacao', {}).get('big_fone'),
            'contragolpe': p.get('formacao', {}).get('contragolpe'),
            'bate_volta': p.get('formacao', {}).get('bate_volta'),
            'votos_casa': p.get('votos_casa', {}),
            'fontes': p.get('fontes', []),
            'impedidos_votar': p.get('impedidos_votar', []),
            'votos_anulados': p.get('votos_anulados', []),
        }

        # Handle imunizado
        im = p.get('formacao', {}).get('imunizado')
        if im:
            entry['imunizado'] = im

        # Handle participantes based on status
        if p['status'] == 'finalizado' and p.get('resultado'):
            entry['participantes'] = []
            for ind in p.get('indicados_finais', []):
                part = {
                    'nome': ind['nome'],
                    'grupo': ind.get('grupo', MEMBER_OF.get(ind['nome'], '?')),
                    'como': ind.get('como', ''),
                }
                # Add vote data if available
                votos = p['resultado'].get('votos', {}).get(ind['nome'], {})
                if votos:
                    part['voto_unico'] = votos.get('voto_unico', 0)
                    part['voto_torcida'] = votos.get('voto_torcida', 0)
                    part['voto_total'] = votos.get('voto_total', 0)
                    part['resultado'] = 'ELIMINADA' if ind['nome'] == p['resultado'].get('eliminado') else 'Salva'
                entry['participantes'].append(part)
        else:
            entry['participantes'] = [
                {'nome': ind['nome'], 'grupo': ind.get('grupo', '?'), 'como': ind.get('como', '')}
                for ind in p.get('indicados_finais', [])
            ]
            entry['total_esperado'] = 3

        paredoes.append(entry)

    return paredoes

paredoes = load_paredoes()

# â”€â”€ Carregar dados de enquetes do Votalhada â”€â”€
from data_utils import load_votalhada_polls, get_poll_for_paredao, calculate_poll_accuracy
polls_data = load_votalhada_polls()

# â”€â”€ Detectar paredÃ£o em andamento da API â”€â”€
# Se hÃ¡ participantes com role "ParedÃ£o" na API E nÃ£o temos um paredÃ£o 'em_andamento'
# no manual, mostramos um aviso para adicionar dados
def get_api_paredao_participants():
    """Retorna lista de nomes com role 'ParedÃ£o' no snapshot mais recente."""
    paredao_names = []
    for p in latest['participants']:
        roles = p.get('characteristics', {}).get('roles', [])
        role_labels = [r.get('label') if isinstance(r, dict) else r for r in roles]
        if 'ParedÃ£o' in role_labels:
            paredao_names.append(p['name'])
    return paredao_names

api_paredao = get_api_paredao_participants()

# â”€â”€ Merge API participants into manual paredÃ£o data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Auto-add participants from API that aren't in the manual list
def merge_api_paredao(paredao_entry, api_names):
    """Merge API-detected paredÃ£o participants into manual entry."""
    if not paredao_entry or paredao_entry.get('status') == 'finalizado':
        return  # Don't modify finalized paredÃµes

    participantes = paredao_entry.get('participantes', [])
    manual_names = {p['nome'] for p in participantes}

    # Add API participants not in manual list
    for name in api_names:
        if name not in manual_names:
            # Get grupo from latest snapshot
            grupo = 'Pipoca'
            for p in latest['participants']:
                if p['name'] == name:
                    grupo = p.get('characteristics', {}).get('memberOf', 'Pipoca')
                    break
            participantes.append({
                'nome': name,
                'grupo': grupo,
                'como': 'API'  # Will be updated manually later
            })

    paredao_entry['participantes'] = participantes

# Apply merge to the latest paredÃ£o if it's em_andamento
if paredoes and paredoes[-1].get('status') == 'em_andamento':
    merge_api_paredao(paredoes[-1], api_paredao)

# â”€â”€ VisualizaÃ§Ãµes do ParedÃ£o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXIBIÃ‡ÃƒO DO PAREDÃƒO â€” LÃ³gica flexÃ­vel que adapta ao dado disponÃ­vel
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# O cÃ³digo detecta automaticamente o estado baseado nos dados presentes:
# - Se tem 'resultado' nos participantes â†’ finalizado (mostra resultados)
# - Se nÃ£o tem 'resultado' â†’ em andamento (mostra formaÃ§Ã£o)
# - Se participantes < 3 â†’ formaÃ§Ã£o parcial (mostra "aguardando")
# - Se nÃ£o tem 'votos_casa' â†’ aguardando votaÃ§Ã£o da casa
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ultimo = paredoes[-1] if paredoes else None

if ultimo:
    is_finalizado = ultimo.get('status') == 'finalizado'
    participantes = ultimo.get('participantes', [])
    tem_resultado = any(p.get('resultado') for p in participantes)
    tem_votos_casa = bool(ultimo.get('votos_casa'))
    n_indicados = len(participantes)
    esperado_indicados = ultimo.get('total_esperado', 3)  # PadrÃ£o: 3 indicados

    if is_finalizado or tem_resultado:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO FINALIZADO â€” Resultado conhecido
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        pass  # Handled below in the else block

    else:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAREDÃƒO EM ANDAMENTO â€” Ainda nÃ£o temos resultado
        # Adapta a exibiÃ§Ã£o baseado no que temos disponÃ­vel
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        # Determinar tÃ­tulo e mensagem baseado no estado
        if n_indicados < esperado_indicados:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” FORMAÃ‡ÃƒO EM ANDAMENTO"
            cor_titulo = '#3498db'  # Azul para formaÃ§Ã£o
            if n_indicados == 0:
                subtitulo = "Aguardando indicaÃ§Ãµes..."
            else:
                falta = esperado_indicados - n_indicados
                subtitulo = f"{n_indicados} indicado(s) confirmado(s). Aguardando mais {falta}..."
        else:
            titulo = f"{ultimo['numero']}Âº ParedÃ£o â€” EM VOTAÃ‡ÃƒO"
            cor_titulo = '#f39c12'  # Amarelo para votaÃ§Ã£o
            subtitulo = "VotaÃ§Ã£o popular em andamento. Resultado na terÃ§a-feira Ã  noite."

        # Check for auto-detected participants (need manual info)
        auto_detected = [p for p in participantes if p.get('como') == 'API']
        needs_manual_info = len(auto_detected) > 0 or not tem_votos_casa

        # Header
        print(f"""
<div style="text-align: center; margin-bottom: 2rem;">
<h2 style="color: {cor_titulo}; margin-bottom: 0.5rem;">ğŸ—³ï¸ {titulo}</h2>
<p style="color: #aaa; font-size: 1.1em;">{subtitulo}</p>
</div>
""")

        # Warning for incomplete data
        if needs_manual_info:
            missing = []
            if auto_detected:
                names = ', '.join([p['nome'] for p in auto_detected])
                missing.append(f"Como {names} foram indicados")
            if not tem_votos_casa and n_indicados >= esperado_indicados:
                missing.append("VotaÃ§Ã£o da casa")
            if not ultimo.get('lider'):
                missing.append("LÃ­der da semana")

            missing_text = ' Â· '.join(missing) if missing else "Detalhes da formaÃ§Ã£o"
            print(f"""
<div style="background: rgba(243, 156, 18, 0.15); border: 1px solid rgba(243, 156, 18, 0.4); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; text-align: center;">
<span style="color: #f39c12;">âš ï¸ <strong>Dados parciais</strong></span>
<p style="color: #ccc; margin: 0.5rem 0 0 0; font-size: 0.9em;">Participantes detectados da API. InformaÃ§Ãµes adicionais serÃ£o preenchidas manualmente.</p>
<p style="color: #888; margin: 0.3rem 0 0 0; font-size: 0.8em;">Pendente: {missing_text}</p>
</div>
""")

        # Cards dos indicados conhecidos
        if participantes:
            print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 2rem 0;">')
            for p in participantes:
                nome = p['nome']
                grupo = p.get('grupo', MEMBER_OF.get(nome, '?'))
                cor_grupo = GROUP_COLORS.get(grupo, '#666')
                avatar_url = AVATARS.get(nome, '')
                como_indicado = p.get('como', '')  # Ex: "DinÃ¢mica", "LÃ­der", "Casa", "API"
                is_auto = como_indicado == 'API'

                # Different border style for auto-detected
                border_style = f"2px dashed {cor_grupo}" if is_auto else f"2px solid {cor_grupo}"
                opacity = "0.85" if is_auto else "1"

                print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 180px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: {border_style}; opacity: {opacity};">')
                if avatar_url:
                    print(f'<img src="{avatar_url}" alt="{nome}" style="width: 120px; height: 120px; border-radius: 50%; object-fit: cover; border: 3px solid {cor_grupo}; margin-bottom: 1rem;">')
                print(f'<h4 style="margin: 0; color: #fff; font-size: 1.1em; text-align: center;">{nome}</h4>')
                print(f'<span style="display: inline-block; margin-top: 0.5rem; padding: 0.25rem 0.75rem; background: {cor_grupo}; color: #fff; border-radius: 12px; font-size: 0.85em;">{grupo}</span>')
                if como_indicado and not is_auto:
                    print(f'<div style="color: #aaa; font-size: 0.8em; margin-top: 0.5rem;">via {como_indicado}</div>')
                elif is_auto:
                    print(f'<div style="color: #f39c12; font-size: 0.75em; margin-top: 0.5rem;">â³ aguardando detalhes</div>')
                print('</div>')

            # Placeholder cards para indicados faltantes
            for i in range(esperado_indicados - n_indicados):
                print(f'<div style="background: linear-gradient(145deg, #2a2a2a, #1a1a1a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 180px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 2px dashed #555;">')
                print(f'<div style="width: 120px; height: 120px; border-radius: 50%; background: #333; margin: 0 auto 1rem auto; display: flex; align-items: center; justify-content: center; font-size: 2em; color: #555;">?</div>')
                print(f'<h4 style="margin: 0; color: #666; font-size: 1.1em; text-align: center;">Aguardando...</h4>')
                print('</div>')

            print('</div>')

        # â”€â”€ Enquetes do Votalhada (em andamento) â”€â”€
        poll = get_poll_for_paredao(polls_data, ultimo['numero'])
        if poll:
            participantes_poll = poll.get('participantes', [])
            consolidado = poll.get('consolidado', {})
            plataformas = poll.get('plataformas', {})

            print("\n## ğŸ“Š PrevisÃ£o das Enquetes\n")
            print(f'<p class="text-muted small">Dados agregados de <a href="https://votalhada.blogspot.com/" target="_blank">Votalhada</a> â€” coleta em {poll.get("data_coleta", "?")[:10]} {poll.get("data_coleta", "?")[11:16] if len(poll.get("data_coleta", "")) > 11 else ""}</p>\n')

            print(f'<div class="alert alert-info" style="font-size:0.95rem;">')
            print(f'ğŸ”® <strong>PrevisÃ£o atual:</strong> {consolidado.get("predicao_eliminado", "â€”")} com mais votos para sair ({consolidado.get(consolidado.get("predicao_eliminado", ""), 0):.1f}%)')
            print(f'</div>\n')

            # Platform breakdown table
            print('<table class="table table-striped" style="max-width: 100%; font-size: 1rem;">')
            print('<thead><tr><th>Plataforma</th>')
            for nome in participantes_poll:
                avatar = avatar_img(nome, 28)
                print(f'<th style="text-align:center;">{avatar}</th>')
            print('<th style="text-align:center; color:#888;">Votos</th>')
            print('</tr></thead><tbody>')

            platform_order = ['sites', 'youtube', 'twitter', 'instagram']
            platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

            for plat in platform_order:
                if plat in plataformas:
                    pdata = plataformas[plat]
                    votos = pdata.get('votos', 0)
                    votos_str = f"{votos:,.0f}".replace(',', '.')
                    print(f'<tr><td>{platform_names.get(plat, plat)}</td>')
                    for nome in participantes_poll:
                        val = pdata.get(nome, 0)
                        is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                        style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                        print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
                    print(f'<td style="text-align:center; color:#888; font-size:0.9em;">{votos_str}</td>')
                    print('</tr>')

            # Consolidado row
            total_votos = consolidado.get('total_votos', 0)
            total_str = f"{total_votos:,.0f}".replace(',', '.')
            print(f'<tr style="background:rgba(155,89,182,0.2);"><td style="font-weight:bold;">ğŸ“Š Consolidado</td>')
            for nome in participantes_poll:
                val = consolidado.get(nome, 0)
                is_max = val == max(consolidado.get(n, 0) for n in participantes_poll)
                style = 'font-weight:bold; color:#9b59b6;' if is_max else 'font-weight:bold;'
                print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
            print(f'<td style="text-align:center; color:#888; font-size:0.9em;">{total_str}</td>')
            print('</tr>')

            print('</tbody></table>\n')

        # Resumo da formaÃ§Ã£o (formato compacto)
        print("\n### ğŸ§© Resumo da FormaÃ§Ã£o\n")

        if ultimo.get('formacao'):
            prefixo = "Como foi formado" if n_indicados >= esperado_indicados else "Como estÃ¡ sendo formado"
            print(f"- **{prefixo}:** {ultimo['formacao']}")

        if ultimo.get('lider'):
            print(f"- **LÃ­der:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
            elif n_indicados < esperado_indicados:
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** *Aguardando...*")

        if ultimo.get('anjo'):
            auto = " (autoimune)" if ultimo.get('anjo_autoimune') else ""
            print(f"- **Anjo:** {ultimo['anjo']}{auto}")

        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"- **ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")

        if ultimo.get('dinamica'):
            dinamica = ultimo['dinamica']
            print(f"- **DinÃ¢mica:** {dinamica.get('nome', 'DinÃ¢mica especial')}")
            if dinamica.get('indicaram') and dinamica.get('indicado'):
                ind_list = ', '.join(dinamica['indicaram'])
                print(f"  - Indicaram: {ind_list} â†’ **{dinamica['indicado']}**")
            efeitos = dinamica.get('efeitos', {})
            if efeitos:
                for pessoa, efeito in efeitos.items():
                    print(f"  - {pessoa}: {efeito}")

        if ultimo.get('big_fone'):
            bf = ultimo['big_fone']
            print(f"- **Big Fone:** {bf.get('atendeu', 'â€”')} indicou {bf.get('indicou', 'â€”')}")

        if ultimo.get('contragolpe'):
            cg = ultimo['contragolpe']
            print(f"- **Contragolpe:** {cg.get('de', 'â€”')} â†’ {cg.get('para', 'â€”')}")

        if ultimo.get('bate_volta') is None and n_indicados >= esperado_indicados:
            print("- **Bate e Volta:** nÃ£o haverÃ¡")
        elif ultimo.get('bate_volta'):
            bv = ultimo['bate_volta']
            print(f"- **Bate e Volta:** {', '.join(bv.get('participantes', []))} â€” vencedor: {bv.get('vencedor', 'â€”')}")

        if ultimo.get('impedidos_votar'):
            print(f"- **Impedidos de votar:** {', '.join(ultimo['impedidos_votar'])}")

        if ultimo.get('votos_anulados'):
            print(f"- **Votos anulados:** {', '.join(ultimo['votos_anulados'])}")

        # VotaÃ§Ã£o da casa (formato mais legÃ­vel)
        if tem_votos_casa:
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"**Mais votado:** **{ranking[0][0]}** ({ranking[0][1]} votos)\n")

            print('<table class="table table-striped" style="max-width: 800px; font-size: 1.05rem;">')
            print('<thead><tr><th>Alvo</th><th style="text-align:center;">Votos</th><th>Principais votantes</th></tr></thead>')
            print('<tbody>')
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                votantes_html = ' '.join([avatar_img(v, 28) for v in votantes[:6]])
                if len(votantes) > 6:
                    votantes_html += f' <span style="color:#888; font-size:0.9em;">+{len(votantes) - 6}</span>'
                print(f'<tr><td>{avatar_html(alvo, 32)}</td><td style="text-align:center; font-weight:bold; font-size:1.1em;">{n}</td><td>{votantes_html}</td></tr>')
            print('</tbody></table>\n')
        elif n_indicados >= esperado_indicados:
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"*Aguardando divulgaÃ§Ã£o da votaÃ§Ã£o da casa...*")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PAREDÃƒO FINALIZADO â€” Exibir se tem resultado
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if ultimo and (ultimo.get('status') == 'finalizado' or any(p.get('resultado') for p in ultimo.get('participantes', []))):
        df_p = pd.DataFrame(ultimo['participantes'])
        has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

        # â”€â”€ Visual: Cards com fotos e resultado â”€â”€
        print(f'<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 1.5rem 0 2rem 0;">')
        for _, row in df_p.iterrows():
            nome = row['nome']
            grupo = row.get('grupo', MEMBER_OF.get(nome, '?'))
            resultado = row.get('resultado', '')
            voto_total = row.get('voto_total', 0)
            avatar_url = AVATARS.get(nome, '')
            cor_grupo = GROUP_COLORS.get(grupo, '#666')

            # Card styling based on result
            if resultado == 'ELIMINADA':
                border_color = '#E6194B'
                badge_bg = '#E6194B'
                badge_text = 'ELIMINADO(A)'
                img_filter = 'grayscale(100%)'  # B&W for eliminated
            else:
                border_color = '#3CB44B'
                badge_bg = '#3CB44B'
                badge_text = 'SALVO(A)'
                img_filter = 'none'

            print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 3px solid {border_color};">')
            if avatar_url:
                print(f'<img src="{avatar_url}" alt="{nome}" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid {border_color}; margin-bottom: 0.75rem; filter: {img_filter};">')
            print(f'<h4 style="margin: 0 0 0.25rem 0; color: #fff; font-size: 1em; text-align: center;">{nome}</h4>')
            print(f'<span style="display: block; color: {cor_grupo}; font-size: 0.8em; margin-bottom: 0.5rem;">{grupo}</span>')
            print(f'<span style="display: inline-block; padding: 0.25rem 0.6rem; background: {badge_bg}; color: #fff; border-radius: 10px; font-size: 0.75em; font-weight: bold;">{badge_text}</span>')
            print(f'<div style="color: #fff; font-size: 1.3em; font-weight: bold; margin-top: 0.5rem;">{voto_total:.1f}%</div>')
            print('</div>')
        print('</div>')

        fig = go.Figure()

        if has_breakdown:
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_unico'],
                text=[f"{v:.1f}%" for v in df_p['voto_unico']],
                textposition='outside', name='Voto Ãšnico (70%)',
                marker_color='#1976D2',
                hovertemplate='%{x}: %{y:.1f}% (Voto Ãšnico)<extra></extra>',
            ))
            fig.add_trace(go.Bar(
                x=df_p['nome'], y=df_p['voto_torcida'],
                text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
                textposition='outside', name='Voto Torcida (30%)',
                marker_color='#FF9800',
                hovertemplate='%{x}: %{y:.1f}% (Voto Torcida)<extra></extra>',
            ))

        colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_total'],
            text=[f"{v:.1f}%" for v in df_p['voto_total']],
            textposition='outside', name='MÃ©dia Final',
            marker_color=colors_total,
            hovertemplate='%{x}: %{y:.1f}% (Final)<extra></extra>',
        ))

        fig.update_layout(
            title=dict(text=ultimo['titulo'], y=0.95, x=0.5, xanchor='center'),
            xaxis_title="", yaxis_title="Votos (%)",
            yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
            barmode='group',
            height=500,
            margin=dict(t=100),
            legend=dict(orientation='h', yanchor='bottom', y=1.08, xanchor='center', x=0.5),
            annotations=[dict(
                text="FÃ³rmula: (Voto Ãšnico Ã— 0,70) + (Voto Torcida Ã— 0,30) = MÃ©dia Final",
                xref="paper", yref="paper", x=0.5, y=-0.12, showarrow=False,
                font=dict(size=11, color='gray')
            )]
        )

        fig.show()

        # â”€â”€ Enquetes vs Resultado (finalizado) â”€â”€
        poll = get_poll_for_paredao(polls_data, ultimo['numero'])
        if poll and poll.get('resultado_real'):
            participantes_poll = poll.get('participantes', [])
            consolidado = poll.get('consolidado', {})
            plataformas = poll.get('plataformas', {})
            resultado = poll['resultado_real']
            accuracy = calculate_poll_accuracy(poll)

            print("\n## ğŸ“Š Enquetes vs Resultado\n")
            print(f'<p class="text-muted small">Dados agregados de <a href="https://votalhada.blogspot.com/" target="_blank">Votalhada</a> â€” coleta em {poll.get("data_coleta", "?")[:10]}</p>\n')

            # Status badge
            if accuracy and accuracy['predicao_correta']:
                status_html = '<span style="background:#3CB44B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âœ… PrevisÃ£o correta</span>'
            else:
                status_html = '<span style="background:#E6194B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âŒ PrevisÃ£o errada</span>'

            erro_medio = accuracy['erro_medio'] if accuracy else 0
            print(f'<div style="text-align:center; margin-bottom:1.5rem;">')
            print(f'{status_html}')
            print(f'<span style="margin-left:1rem; color:#888;">Erro mÃ©dio: <strong>{erro_medio:.1f}</strong> pontos percentuais</span>')
            print(f'</div>\n')

            # Grouped bar chart: Enquetes vs Resultado Real
            fig_poll = go.Figure()
            enquete_vals = [consolidado.get(n, 0) for n in participantes_poll]
            fig_poll.add_trace(go.Bar(
                x=participantes_poll, y=enquete_vals,
                text=[f"{v:.1f}%" for v in enquete_vals],
                textposition='outside', name='Enquete (Consolidado)',
                marker_color='#9b59b6',
                hovertemplate='%{x}: %{y:.1f}% (Enquete)<extra></extra>',
            ))
            resultado_vals = [resultado.get(n, 0) for n in participantes_poll]
            colors_real = ['#E6194B' if n == resultado.get('eliminado') else '#3CB44B' for n in participantes_poll]
            fig_poll.add_trace(go.Bar(
                x=participantes_poll, y=resultado_vals,
                text=[f"{v:.1f}%" for v in resultado_vals],
                textposition='outside', name='Resultado Real',
                marker_color=colors_real,
                hovertemplate='%{x}: %{y:.1f}% (Real)<extra></extra>',
            ))
            fig_poll.update_layout(
                title=dict(text='Enquetes Agregadas vs Resultado Real', y=0.95, x=0.5, xanchor='center'),
                xaxis_title="", yaxis_title="Votos (%)",
                yaxis_range=[0, max(max(enquete_vals), max(resultado_vals)) * 1.25],
                barmode='group',
                height=400,
                margin=dict(t=80, b=60),
                legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
            )
            fig_poll.show()

            # Platform breakdown table
            print("\n### ğŸ“± Por Plataforma\n")
            print('<table class="table table-striped table-hover" style="max-width: 100%; font-size: 1rem;">')
            print('<thead><tr><th>Plataforma</th>')
            for nome in participantes_poll:
                avatar = avatar_img(nome, 28)
                print(f'<th style="text-align:center;">{avatar}</th>')
            print('<th style="text-align:center; color:#888;">Votos</th>')
            print('</tr></thead><tbody>')

            platform_order = ['sites', 'youtube', 'twitter', 'instagram']
            platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}
            platform_colors = {'sites': '#3498db', 'youtube': '#e74c3c', 'twitter': '#1da1f2', 'instagram': '#e1306c'}

            for plat in platform_order:
                if plat in plataformas:
                    pdata = plataformas[plat]
                    votos = pdata.get('votos', 0)
                    votos_str = f"{votos:,.0f}".replace(',', '.')
                    print(f'<tr><td style="font-weight:bold; color:{platform_colors.get(plat, "#fff")}">{platform_names.get(plat, plat)}</td>')
                    for nome in participantes_poll:
                        val = pdata.get(nome, 0)
                        is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                        style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                        print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
                    print(f'<td style="text-align:center; color:#888; font-size:0.9em;">{votos_str}</td>')
                    print('</tr>')

            total_votos = consolidado.get('total_votos', 0)
            total_str = f"{total_votos:,.0f}".replace(',', '.')
            print(f'<tr style="background:rgba(155,89,182,0.2);"><td style="font-weight:bold;">ğŸ“Š Consolidado</td>')
            for nome in participantes_poll:
                val = consolidado.get(nome, 0)
                is_max = val == max(consolidado.get(n, 0) for n in participantes_poll)
                style = 'font-weight:bold; color:#9b59b6;' if is_max else 'font-weight:bold;'
                print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
            print(f'<td style="text-align:center; color:#888; font-size:0.9em;">{total_str}</td>')
            print('</tr>')

            print(f'<tr style="background:rgba(52,152,219,0.2);"><td style="font-weight:bold;">ğŸ† Resultado Real</td>')
            for nome in participantes_poll:
                val = resultado.get(nome, 0)
                is_elim = nome == resultado.get('eliminado')
                style = 'font-weight:bold; color:#E6194B;' if is_elim else 'font-weight:bold; color:#3CB44B;'
                print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
            print('<td style="text-align:center; color:#888;">â€”</td>')
            print('</tr>')
            print('</tbody></table>\n')

            # â”€â”€ AnÃ¡lise de PrecisÃ£o: Enquetes vs Tipos de Voto â”€â”€
            # Get vote breakdown from paredoes.json for this paredÃ£o
            paredao_votos = {}
            for p in ultimo.get('participantes', []):
                nome = p.get('nome')
                if nome and 'voto_total' in p:
                    paredao_votos[nome] = {
                        'voto_unico': p.get('voto_unico', 0),
                        'voto_torcida': p.get('voto_torcida', 0),
                        'voto_total': p.get('voto_total', 0),
                    }

            if paredao_votos:
                eliminado_nome = resultado.get('eliminado')

                # Calculate errors for eliminated person against each vote type
                poll_elim = consolidado.get(eliminado_nome, 0)
                voto_unico_elim = paredao_votos.get(eliminado_nome, {}).get('voto_unico', 0)
                voto_torcida_elim = paredao_votos.get(eliminado_nome, {}).get('voto_torcida', 0)
                voto_total_elim = paredao_votos.get(eliminado_nome, {}).get('voto_total', 0)

                erro_vs_unico = poll_elim - voto_unico_elim
                erro_vs_torcida = poll_elim - voto_torcida_elim
                erro_vs_total = poll_elim - voto_total_elim

                print("\n### ğŸ¯ PrecisÃ£o das Enquetes\n")
                print(f"**{eliminado_nome}** (eliminado): enquete previa **{poll_elim:.1f}%**, resultado real **{voto_total_elim:.1f}%**\n")

                # Table: Poll vs Vote Types
                print('<table class="table table-sm" style="max-width: 600px;">')
                print('<thead><tr><th>ComparaÃ§Ã£o</th><th style="text-align:center;">Enquete</th><th style="text-align:center;">VotaÃ§Ã£o</th><th style="text-align:center;">Erro</th></tr></thead>')
                print('<tbody>')

                vote_types = [
                    ('Voto Ãšnico (70%)', voto_unico_elim, erro_vs_unico),
                    ('Voto Torcida (30%)', voto_torcida_elim, erro_vs_torcida),
                    ('MÃ©dia Final', voto_total_elim, erro_vs_total),
                ]

                # Find which vote type poll was closest to
                closest_type = min(vote_types, key=lambda x: abs(x[2]))

                for vtype, vval, verr in vote_types:
                    is_closest = vtype == closest_type[0]
                    row_style = 'background:rgba(60,180,75,0.2);' if is_closest else ''
                    badge = ' ğŸ¯' if is_closest else ''
                    err_color = '#E6194B' if verr < -5 else '#3CB44B' if abs(verr) < 5 else '#f39c12'
                    print(f'<tr style="{row_style}"><td>{vtype}{badge}</td>')
                    print(f'<td style="text-align:center;">{poll_elim:.1f}%</td>')
                    print(f'<td style="text-align:center;">{vval:.1f}%</td>')
                    print(f'<td style="text-align:center; color:{err_color}; font-weight:bold;">{verr:+.1f} p.p.</td>')
                    print('</tr>')

                print('</tbody></table>\n')

                # Platform accuracy for eliminated person
                print("### ğŸ“± Qual plataforma acertou mais?\n")
                platform_errors = []
                for plat in ['sites', 'youtube', 'twitter', 'instagram']:
                    if plat in plataformas:
                        plat_val = plataformas[plat].get(eliminado_nome, 0)
                        plat_err = abs(plat_val - voto_total_elim)
                        platform_errors.append((plat, plat_val, plat_err))

                # Sort by error (ascending)
                platform_errors.sort(key=lambda x: x[2])

                platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

                print(f'<p>Para <strong>{eliminado_nome}</strong> (resultado: {voto_total_elim:.1f}%):</p>')
                print('<table class="table table-sm" style="max-width: 500px;">')
                print('<thead><tr><th>#</th><th>Plataforma</th><th style="text-align:center;">PrevisÃ£o</th><th style="text-align:center;">Erro</th></tr></thead>')
                print('<tbody>')
                for rank, (plat, pval, perr) in enumerate(platform_errors, 1):
                    medal = 'ğŸ¥‡' if rank == 1 else 'ğŸ¥ˆ' if rank == 2 else 'ğŸ¥‰' if rank == 3 else '4Âº'
                    row_style = 'background:rgba(60,180,75,0.2);' if rank == 1 else ''
                    print(f'<tr style="{row_style}"><td>{medal}</td><td>{platform_names.get(plat, plat)}</td>')
                    print(f'<td style="text-align:center;">{pval:.1f}%</td>')
                    print(f'<td style="text-align:center;">{perr:.1f} p.p.</td>')
                    print('</tr>')
                print('</tbody></table>\n')

                # â”€â”€ Historical comparison across all paredÃµes â”€â”€
                all_polls = polls_data.get('paredoes', [])
                finalized_polls = [p for p in all_polls if p.get('resultado_real')]

                if len(finalized_polls) >= 2:
                    print("### ğŸ“Š PadrÃµes Observados (todos os paredÃµes)\n")

                    total_correct = sum(1 for p in finalized_polls if p['resultado_real'].get('predicao_correta'))
                    total_polls = len(finalized_polls)

                    # Calculate average underestimation of eliminated person
                    underest_sum = 0
                    for p in finalized_polls:
                        elim = p['resultado_real'].get('eliminado')
                        poll_val = p['consolidado'].get(elim, 0)
                        real_val = p['resultado_real'].get(elim, 0)
                        underest_sum += (poll_val - real_val)
                    avg_underest = underest_sum / total_polls

                    # Find best platform across all paredÃµes
                    platform_total_err = {'sites': 0, 'youtube': 0, 'twitter': 0, 'instagram': 0}
                    for p in finalized_polls:
                        elim = p['resultado_real'].get('eliminado')
                        real_val = p['resultado_real'].get(elim, 0)
                        for plat in platform_total_err:
                            if plat in p.get('plataformas', {}):
                                plat_val = p['plataformas'][plat].get(elim, 0)
                                platform_total_err[plat] += abs(plat_val - real_val)

                    best_platform = min(platform_total_err, key=platform_total_err.get)

                    print(f'<div style="background:rgba(52,152,219,0.1); border-radius:12px; padding:1rem; margin:1rem 0;">')
                    print(f'<p style="margin:0;"><strong>âœ… Taxa de acerto:</strong> {total_correct}/{total_polls} paredÃµes ({100*total_correct/total_polls:.0f}%)</p>')
                    print(f'<p style="margin:0.5rem 0 0 0;"><strong>ğŸ“‰ PadrÃ£o:</strong> Enquetes subestimam o eliminado em <strong>{abs(avg_underest):.1f} p.p.</strong> em mÃ©dia</p>')
                    print(f'<p style="margin:0.5rem 0 0 0;"><strong>ğŸ† Plataforma mais precisa:</strong> {platform_names.get(best_platform, best_platform)} (erro mÃ©dio: {platform_total_err[best_platform]/total_polls:.1f} p.p.)</p>')
                    print(f'</div>\n')

        # Resumo da formaÃ§Ã£o (finalizado)
        print("\n### ğŸ§© Resumo da FormaÃ§Ã£o\n")
        if ultimo.get('formacao'):
            print(f"- **Como foi formado:** {ultimo['formacao']}")
        if ultimo.get('lider'):
            print(f"- **LÃ­der:** {ultimo['lider']}")
            if ultimo.get('indicado_lider'):
                print(f"- **IndicaÃ§Ã£o do LÃ­der:** {ultimo['indicado_lider']}")
        if ultimo.get('anjo'):
            auto = " (autoimune)" if ultimo.get('anjo_autoimune') else ""
            print(f"- **Anjo:** {ultimo['anjo']}{auto}")
        if ultimo.get('imunizado'):
            im = ultimo['imunizado']
            print(f"- **ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}")
        if ultimo.get('dinamica'):
            dinamica = ultimo['dinamica']
            print(f"- **DinÃ¢mica:** {dinamica.get('nome', 'DinÃ¢mica especial')}")
            if dinamica.get('indicaram') and dinamica.get('indicado'):
                ind_list = ', '.join(dinamica['indicaram'])
                print(f"  - Indicaram: {ind_list} â†’ **{dinamica['indicado']}**")
            efeitos = dinamica.get('efeitos', {})
            if efeitos:
                for pessoa, efeito in efeitos.items():
                    print(f"  - {pessoa}: {efeito}")
        if ultimo.get('big_fone'):
            bf = ultimo['big_fone']
            print(f"- **Big Fone:** {bf.get('atendeu', 'â€”')} indicou {bf.get('indicou', 'â€”')}")
        if ultimo.get('contragolpe'):
            cg = ultimo['contragolpe']
            print(f"- **Contragolpe:** {cg.get('de', 'â€”')} â†’ {cg.get('para', 'â€”')}")
        if ultimo.get('bate_volta'):
            bv = ultimo['bate_volta']
            print(f"- **Bate e Volta:** {', '.join(bv.get('participantes', []))} â€” vencedor: {bv.get('vencedor', 'â€”')}")

        # VotaÃ§Ã£o da casa (finalizado)
        if ultimo.get('votos_casa'):
            votos = ultimo['votos_casa']
            contagem = Counter(votos.values())
            ranking = contagem.most_common()
            print(f"\n### ğŸ—³ï¸ VotaÃ§Ã£o da Casa\n")
            print(f"**Mais votado:** **{ranking[0][0]}** ({ranking[0][1]} votos)\n")

            print('<table class="table table-striped" style="max-width: 800px; font-size: 1.05rem;">')
            print('<thead><tr><th>Alvo</th><th style="text-align:center;">Votos</th><th>Principais votantes</th></tr></thead>')
            print('<tbody>')
            for alvo, n in ranking:
                votantes = sorted([v for v, a in votos.items() if a == alvo])
                votantes_html = ' '.join([avatar_img(v, 28) for v in votantes[:6]])
                if len(votantes) > 6:
                    votantes_html += f' <span style="color:#888; font-size:0.9em;">+{len(votantes) - 6}</span>'
                print(f'<tr><td>{avatar_html(alvo, 32)}</td><td style="text-align:center; font-weight:bold; font-size:1.1em;">{n}</td><td>{votantes_html}</td></tr>')
            print('</tbody></table>\n')

```

---

```{python}
#| label: paredao-quick-insights
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LEITURA RÃPIDA â€” QUERIDÃ”METRO DOS INDICADOS (PAREDÃƒO DATE + HISTÃ“RICO)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CRITICAL: For finalizado paredÃµes, we MUST use the paredÃ£o-date snapshot,
# not the latest snapshot. This ensures historical analysis is consistent
# and reflects data as it was at voting time.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if ultimo and ultimo.get('participantes'):
    indicados = [p['nome'] for p in ultimo['participantes']]
    paredao_date = ultimo.get('data', latest['date'])
    is_finalizado = ultimo.get('status') == 'finalizado'

    # â”€â”€ Determine which snapshot to use for "today" analysis â”€â”€
    # For finalizado: use paredÃ£o-date snapshot (frozen historical view)
    # For em_andamento: use latest snapshot (live current view)
    if is_finalizado:
        # Find the snapshot closest to paredÃ£o date
        snap_for_analysis = None
        for snap in reversed(snapshots):
            if snap['date'] <= paredao_date:
                snap_for_analysis = snap
                break
        if snap_for_analysis is None:
            snap_for_analysis = snapshots[0]
        analysis_date_label = f"ğŸ“… Dados de **{snap_for_analysis['date']}** (dia do paredÃ£o)"
    else:
        snap_for_analysis = latest
        analysis_date_label = f"ğŸ“… Dados de **{latest['label']}** (atual)"

    # Sentimento e negativas no snapshot de anÃ¡lise
    sent_paredao = {}
    neg_paredao = {}
    for p in snap_for_analysis['participants']:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        sent_paredao[name] = calc_sentiment(p)
        neg_paredao[name] = sum(
            r['amount'] for r in p.get('characteristics', {}).get('receivedReactions', [])
            if r['label'] != 'CoraÃ§Ã£o'
        )

    # Ranking no snapshot de anÃ¡lise
    ranking_paredao = sorted(sent_paredao.items(), key=lambda x: x[1], reverse=True)
    rank_map = {name: i + 1 for i, (name, _) in enumerate(ranking_paredao)}

    # â”€â”€ SÃ©rie histÃ³rica (diÃ¡ria) â€” filtered to paredÃ£o date for finalizado â”€â”€
    rows = []
    for snap in daily_snapshots:
        date = snap['date']
        # For finalizado paredÃµes, don't include data AFTER the paredÃ£o
        if is_finalizado and date > paredao_date:
            continue
        for p in snap['participants']:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            rows.append({
                'date': date,
                'name': p['name'],
                'sentiment': calc_sentiment(p),
            })

    df_daily = pd.DataFrame(rows)

    # Top/bottom 5 por dia
    top5_counts = Counter()
    bottom5_counts = Counter()
    for date, g in df_daily.groupby('date'):
        g_sorted = g.sort_values('sentiment', ascending=False)
        top = g_sorted.head(5)['name']
        bottom = g_sorted.tail(5)['name']
        for n in top:
            top5_counts[n] += 1
        for n in bottom:
            bottom5_counts[n] += 1

    # FunÃ§Ãµes auxiliares
    def trend_3d(name):
        series = df_daily[df_daily['name'] == name].sort_values('date')['sentiment'].tolist()
        if len(series) < 2:
            return None
        last = series[-1]
        if len(series) >= 4:
            prev = sum(series[-4:-1]) / 3
        else:
            prev = sum(series[:-1]) / (len(series) - 1)
        return last - prev

    # Construir tabela resumida
    table_rows = []
    for nome in indicados:
        series = df_daily[df_daily['name'] == nome].sort_values('date')['sentiment'].tolist()
        total_days = len(series)
        neg_days = sum(1 for v in series if v < 0)
        pct_neg = (neg_days / total_days * 100) if total_days else 0

        delta = trend_3d(nome)
        if delta is None:
            delta_str = "â€”"
        elif delta >= 0.8:
            delta_str = f"â–² +{delta:.1f}"
        elif delta <= -0.8:
            delta_str = f"â–¼ {delta:.1f}"
        else:
            delta_str = f"â‰ˆ {delta:+.1f}"

        table_rows.append({
            'Indicado': nome,
            'Grupo': MEMBER_OF.get(nome, '?'),
            'Sentimento': f"{sent_paredao.get(nome, 0):+.1f}",
            'Rank': rank_map.get(nome, 'â€”'),
            'Î” 3 dias': delta_str,
            'Dias no Top 5': top5_counts.get(nome, 0),
            'Dias no Bottom 5': bottom5_counts.get(nome, 0),
            'Dias negativos': f"{neg_days}/{total_days} ({pct_neg:.0f}%)",
        })

    df_table = pd.DataFrame(table_rows)

    print("## ğŸ” Leitura RÃ¡pida dos Indicados\n")

    # Show data source indicator
    if is_finalizado:
        print(f'<div class="alert alert-secondary" style="font-size: 0.9rem;">')
        print(f'{analysis_date_label} â€” anÃ¡lise histÃ³rica congelada no momento da votaÃ§Ã£o.')
        print(f'</div>\n')
    else:
        print(f"Como os emparedados estÃ£o no **queridÃ´metro** ({analysis_date_label.replace('ğŸ“… ', '')}).\n")

    # HTML table with avatars
    print('<table class="table table-striped table-hover" style="max-width: 100%; font-size: 1.05rem;">')
    print('<thead><tr>')
    print('<th>Indicado</th><th>Grupo</th><th style="text-align:center;">Sentimento</th>')
    print('<th style="text-align:center;">Rank</th><th style="text-align:center;">Î” 3 dias</th>')
    print('<th style="text-align:center;">Top 5</th><th style="text-align:center;">Bottom 5</th>')
    print('<th style="text-align:center;">Dias neg.</th>')
    print('</tr></thead><tbody>')
    for row in table_rows:
        nome = row['Indicado']
        grupo = row['Grupo']
        grupo_color = GROUP_COLORS.get(grupo, '#888')
        sent = row['Sentimento']
        sent_val = float(sent.replace('+', ''))
        sent_color = '#4CAF50' if sent_val >= 0 else '#E6194B'
        delta = row['Î” 3 dias']
        delta_color = '#4CAF50' if 'â–²' in delta or '+' in delta else ('#E6194B' if 'â–¼' in delta else '#888')
        print(f'<tr>')
        print(f'<td>{avatar_html(nome, 32)}</td>')
        print(f'<td><span style="color:{grupo_color}; font-weight:500;">{grupo}</span></td>')
        print(f'<td style="text-align:center; color:{sent_color}; font-weight:bold; font-size:1.1em;">{sent}</td>')
        print(f'<td style="text-align:center;">{row["Rank"]}</td>')
        print(f'<td style="text-align:center; color:{delta_color}; font-weight:500;">{delta}</td>')
        print(f'<td style="text-align:center;">{row["Dias no Top 5"]}</td>')
        print(f'<td style="text-align:center;">{row["Dias no Bottom 5"]}</td>')
        print(f'<td style="text-align:center;">{row["Dias negativos"]}</td>')
        print(f'</tr>')
    print('</tbody></table>\n')

    # Destaques dos indicados
    if table_rows:
        worst_paredao = min(table_rows, key=lambda x: float(x['Sentimento'].replace('+', '')))
        most_neg = max(table_rows, key=lambda x: neg_paredao.get(x['Indicado'], 0))
        most_bottom = max(table_rows, key=lambda x: x['Dias no Bottom 5'])
        most_top = max(table_rows, key=lambda x: x['Dias no Top 5'])

        deltas = {r['Indicado']: trend_3d(r['Indicado']) for r in table_rows}
        deltas = {k: v for k, v in deltas.items() if v is not None}

        print("\n### ğŸ“Š Destaques\n")

        # Adapt labels based on whether this is historical or current
        rejected_label = "Mais rejeitado (paredÃ£o)" if is_finalizado else "Mais rejeitado hoje"
        negativas_label = "Mais negativas recebidas" if is_finalizado else "Mais negativas recebidas"

        print('<table class="table" style="max-width: 750px; font-size: 1.05rem;">')
        print('<thead><tr><th>MÃ©trica</th><th>Participante</th><th style="text-align:center;">Valor</th></tr></thead>')
        print('<tbody>')
        print(f'<tr><td>ğŸ”´ <strong>{rejected_label}</strong></td><td>{avatar_html(worst_paredao["Indicado"], 28)}</td><td style="text-align:center; font-weight:bold;">{worst_paredao["Sentimento"]} sentimento</td></tr>')
        print(f'<tr><td>ğŸ‘ <strong>{negativas_label}</strong></td><td>{avatar_html(most_neg["Indicado"], 28)}</td><td style="text-align:center; font-weight:bold;">{neg_paredao.get(most_neg["Indicado"], 0)} reaÃ§Ãµes</td></tr>')
        if deltas:
            biggest_drop = min(deltas.items(), key=lambda x: x[1])
            biggest_rise = max(deltas.items(), key=lambda x: x[1])
            print(f'<tr><td>ğŸ“‰ <strong>Maior queda (3 dias)</strong></td><td>{avatar_html(biggest_drop[0], 28)}</td><td style="text-align:center; font-weight:bold; color:#E6194B;">{biggest_drop[1]:+.1f}</td></tr>')
            print(f'<tr><td>ğŸ“ˆ <strong>Maior recuperaÃ§Ã£o (3 dias)</strong></td><td>{avatar_html(biggest_rise[0], 28)}</td><td style="text-align:center; font-weight:bold; color:#4CAF50;">{biggest_rise[1]:+.1f}</td></tr>')
        print(f'<tr><td>â¬‡ï¸ <strong>Mais dias no Bottom 5</strong></td><td>{avatar_html(most_bottom["Indicado"], 28)}</td><td style="text-align:center; font-weight:bold;">{most_bottom["Dias no Bottom 5"]} dias</td></tr>')
        if most_top['Dias no Top 5'] > 0:
            print(f'<tr><td>â¬†ï¸ <strong>Mais dias no Top 5</strong></td><td>{avatar_html(most_top["Indicado"], 28)}</td><td style="text-align:center; font-weight:bold;">{most_top["Dias no Top 5"]} dias</td></tr>')
        print('</tbody></table>')
```

```{python}
#| label: relationship-analysis
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANÃLISE ESTRATÃ‰GICA DE VOTOS â€” Baseada em Categorias de Relacionamento
#
# Classifica cada voto de acordo com o tipo de relacionamento entre votante e alvo:
#
# CATEGORIAS DE RELACIONAMENTO (votante â†’ alvo):
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1. INIMIGOS DECLARADOS (mÃºtuo) â€” Ambos se dÃ£o reaÃ§Ãµes negativas
#    â†’ Voto esperado. Ambos se dÃ£o reaÃ§Ãµes negativas (mesmo sem saber).
#
# 2. FALSOS AMIGOS â€” Votante deu â¤ï¸ ao alvo publicamente, mas votou contra
#    â†’ TraiÃ§Ã£o. O alvo achava que tinha um amigo, mas foi apunhalado.
#
# 3. PONTO CEGO â€” Alvo dÃ¡ â¤ï¸ ao votante, mas votante dÃ¡ negativo ao alvo
#    â†’ O votante ataca alguÃ©m que o considera amigo. Alvo nem percebe o perigo.
#
# 4. ALIADOS MÃšTUOS â€” Ambos se dÃ£o â¤ï¸
#    â†’ ProteÃ§Ã£o esperada. Se votou contra, Ã© traiÃ§Ã£o grave.
#
# 5. HOSTILIDADE UNILATERAL â€” Votante dÃ¡ negativo, alvo tambÃ©m (mas nÃ£o mÃºtuo)
#    â†’ Voto coerente com a reaÃ§Ã£o dada no queridÃ´metro.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ultimo_paredao = paredoes[-1] if paredoes else None
tem_votos = ultimo_paredao and ultimo_paredao.get('votos_casa')

if tem_votos and all_matrices:
    paredao = ultimo_paredao
    votos = paredao['votos_casa']
    paredao_date = paredao['data']

    # Encontrar snapshot mais prÃ³ximo Ã  data do paredÃ£o
    closest_idx = 0
    for i, snap in enumerate(snapshots):
        if snap['date'] <= paredao_date:
            closest_idx = i
    matrix = all_matrices[closest_idx]
    snap_participants = snapshots[closest_idx]['participants']

    # Calcular sentimento e negatividade por participante
    sent_by_name = {}
    neg_count_by_name = {}
    for p in snap_participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        sent_by_name[name] = calc_sentiment(p)
        neg_count_by_name[name] = sum(
            r['amount'] for r in p.get('characteristics', {}).get('receivedReactions', [])
            if r['label'] != 'CoraÃ§Ã£o'
        )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CLASSIFICAR CADA VOTO POR TIPO DE RELACIONAMENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def classify_relationship(votante, alvo, matrix):
        """Classifica o relacionamento entre votante e alvo."""
        rxn_votante_to_alvo = matrix.get((votante, alvo), '')
        rxn_alvo_to_votante = matrix.get((alvo, votante), '')

        votante_positive = rxn_votante_to_alvo in POSITIVE
        alvo_positive = rxn_alvo_to_votante in POSITIVE
        votante_negative = rxn_votante_to_alvo in (MILD_NEGATIVE | STRONG_NEGATIVE)
        alvo_negative = rxn_alvo_to_votante in (MILD_NEGATIVE | STRONG_NEGATIVE)
        votante_strong_neg = rxn_votante_to_alvo in STRONG_NEGATIVE

        # Mutual hearts = Aliados
        if votante_positive and alvo_positive:
            return 'aliados_mutuos', 'ğŸ’” TraiÃ§Ã£o de Aliado', '#9b59b6'

        # Votante gave heart but voted against = Falso Amigo
        if votante_positive and not alvo_positive:
            return 'falso_amigo', 'ğŸ­ Falso Amigo', '#E6194B'

        # Mutual negativity = Declared enemies
        if votante_negative and alvo_negative:
            return 'inimigos_declarados', 'âš”ï¸ Hostilidade MÃºtua', '#3CB44B'

        # Alvo gave heart but votante gave negative = Blind spot for alvo
        if votante_negative and alvo_positive:
            return 'ponto_cego', 'ğŸ¯ Ponto Cego do Alvo', '#f39c12'

        # One-sided hostility (votante hostile, alvo neutral/mild)
        if votante_strong_neg:
            return 'hostilidade_forte', 'ğŸ Hostilidade Forte', '#3CB44B'

        if votante_negative:
            return 'hostilidade_leve', 'ğŸŒ± Hostilidade Leve', '#FF9800'

        return 'neutro', 'â“ Neutro', '#999'

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ANÃLISE TEMPORAL â€” COMO OS RELACIONAMENTOS EVOLUÃRAM AO LONGO DO TEMPO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def analyze_relationship_history(votante, alvo, daily_matrices, daily_snapshots, paredao_date):
        """
        Analisa a evoluÃ§Ã£o do relacionamento entre votante e alvo ao longo do tempo.

        Retorna um dict com:
        - history: lista de (date, rxn_votante_to_alvo, rxn_alvo_to_votante)
        - pattern: 'sempre_amigos', 'sempre_inimigos', 'ex_amigos', 'recÃ©m_inimigos', 'instÃ¡vel'
        - days_as_friends: quantos dias foram amigos mÃºtuos
        - days_as_enemies: quantos dias foram inimigos
        - change_date: data da Ãºltima mudanÃ§a significativa (se houver)
        - narrative: texto descritivo da evoluÃ§Ã£o
        """
        history = []
        days_positive = 0
        days_negative = 0
        days_mutual_positive = 0
        last_positive_date = None
        first_negative_date = None
        change_date = None
        prev_was_positive = None

        for i, mat in enumerate(daily_matrices):
            snap_date = daily_snapshots[i]['date']
            if snap_date > paredao_date:
                break  # Don't look past paredÃ£o date

            rxn_v = mat.get((votante, alvo), '')
            rxn_a = mat.get((alvo, votante), '')

            if not rxn_v:  # Participant might not exist yet
                continue

            v_pos = rxn_v in POSITIVE
            a_pos = rxn_a in POSITIVE
            v_neg = rxn_v in (MILD_NEGATIVE | STRONG_NEGATIVE)

            history.append((snap_date, rxn_v, rxn_a))

            if v_pos:
                days_positive += 1
                last_positive_date = snap_date
                if prev_was_positive == False:  # Changed from negative to positive
                    change_date = snap_date
            elif v_neg:
                days_negative += 1
                if first_negative_date is None:
                    first_negative_date = snap_date
                if prev_was_positive == True:  # Changed from positive to negative
                    change_date = snap_date

            if v_pos and a_pos:
                days_mutual_positive += 1

            prev_was_positive = v_pos

        # Determine pattern
        total_days = len(history)
        if total_days == 0:
            return {
                'history': [], 'pattern': 'sem_dados', 'days_as_friends': 0,
                'days_as_enemies': 0, 'days_mutual_friends': 0,
                'change_date': None, 'narrative': 'Sem dados histÃ³ricos'
            }

        # Current state (last entry)
        current_positive = history[-1][1] in POSITIVE if history else False

        # Classify the pattern
        if days_positive == total_days:
            pattern = 'sempre_amigos'
            narrative = f"Sempre deu â¤ï¸ ({days_positive} dias). Amizade consistente."
        elif days_negative == total_days:
            pattern = 'sempre_inimigos'
            narrative = f"Inimigos desde o inÃ­cio ({days_negative} dias)."
        elif days_positive > 0 and not current_positive and change_date:
            # Was positive but changed to negative
            days_since_change = sum(1 for d, _, _ in history if d >= change_date)
            if days_since_change <= 2:
                pattern = 'recem_inimigos'
                narrative = f"Eram amigos por {days_positive} dias, mudou hÃ¡ {days_since_change} dia(s)!"
            else:
                pattern = 'ex_amigos'
                narrative = f"Foram amigos por {days_positive} dias, romperam em {change_date}."
        elif days_negative > 0 and current_positive and change_date:
            pattern = 'reconciliados'
            narrative = f"Foram inimigos, reconciliaram em {change_date}."
        else:
            pattern = 'instavel'
            narrative = f"Relacionamento instÃ¡vel: {days_positive}d â¤ï¸, {days_negative}d negativo."

        return {
            'history': history,
            'pattern': pattern,
            'days_as_friends': days_positive,
            'days_as_enemies': days_negative,
            'days_mutual_friends': days_mutual_positive,
            'change_date': change_date,
            'last_positive_date': last_positive_date,
            'first_negative_date': first_negative_date,
            'narrative': narrative,
            'total_days': total_days
        }

    # Analyze each vote
    vote_analysis = []
    relationship_counts = Counter()
    betrayals = []
    blind_spots = []
    expected_votes = []
    temporal_insights = []  # For temporal analysis

    for votante, alvo in votos.items():
        rel_type, rel_label, rel_color = classify_relationship(votante, alvo, matrix)
        rxn_to_alvo = matrix.get((votante, alvo), '')
        rxn_from_alvo = matrix.get((alvo, votante), '')

        # Add temporal analysis
        hist = analyze_relationship_history(votante, alvo, daily_matrices, daily_snapshots, paredao_date)

        entry = {
            'votante': votante,
            'alvo': alvo,
            'tipo': rel_type,
            'label': rel_label,
            'cor': rel_color,
            'emoji_dado': REACTION_EMOJI.get(rxn_to_alvo, '?'),
            'emoji_recebido': REACTION_EMOJI.get(rxn_from_alvo, '?'),
            'grupo_votante': MEMBER_OF.get(votante, '?'),
            'grupo_alvo': MEMBER_OF.get(alvo, '?'),
            # Temporal data
            'hist_pattern': hist['pattern'],
            'hist_narrative': hist['narrative'],
            'days_as_friends': hist['days_as_friends'],
            'days_as_enemies': hist['days_as_enemies'],
            'days_mutual_friends': hist['days_mutual_friends'],
            'change_date': hist['change_date'],
            'total_days': hist['total_days'],
        }
        vote_analysis.append(entry)
        relationship_counts[rel_type] += 1

        # Track notable temporal patterns
        if hist['pattern'] in ('ex_amigos', 'recem_inimigos'):
            temporal_insights.append({
                'votante': votante,
                'alvo': alvo,
                'pattern': hist['pattern'],
                'narrative': hist['narrative'],
                'days_as_friends': hist['days_as_friends'],
                'change_date': hist['change_date'],
            })

        # Track notable votes
        if rel_type in ('falso_amigo', 'aliados_mutuos'):
            betrayals.append(entry)
        elif rel_type == 'ponto_cego':
            blind_spots.append(entry)
        elif rel_type == 'inimigos_declarados':
            expected_votes.append(entry)

    total_votes = len(votos)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NARRATIVA PRINCIPAL â€” O QUE ACONTECEU NESTE PAREDÃƒO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"## ğŸ“– A HistÃ³ria do {paredao['numero']}Âº ParedÃ£o\n")

    # Count key statistics
    n_traicoes = len(betrayals)
    n_pontos_cegos = len(blind_spots)
    n_esperados = len(expected_votes)
    vote_counts = Counter(votos.values())
    mais_votado, n_votos_mais = vote_counts.most_common(1)[0]

    # Opening narrative
    if n_traicoes >= 3:
        print(f"Este paredÃ£o foi marcado por **traiÃ§Ãµes**. Nada menos que **{n_traicoes} votos** "
              f"vieram de pessoas que davam â¤ï¸ ao alvo no queridÃ´metro.\n")
    elif n_pontos_cegos >= 3:
        print(f"Este paredÃ£o revelou **pontos cegos** perigosos. **{n_pontos_cegos} participantes** "
              f"foram votados por pessoas que consideravam amigas.\n")
    elif n_esperados >= total_votes * 0.5:
        print(f"Este paredÃ£o seguiu a lÃ³gica das **hostilidades mÃºtuas**. "
              f"A maioria dos votos ({n_esperados}/{total_votes}) veio de quem jÃ¡ dava reaÃ§Ãµes negativas ao alvo.\n")
    else:
        print(f"Este paredÃ£o foi **estratÃ©gico**. Os votos nÃ£o seguiram simplesmente as emoÃ§Ãµes do queridÃ´metro.\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GRÃFICO: DISTRIBUIÃ‡ÃƒO DOS VOTOS POR TIPO DE RELACIONAMENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("### Anatomia dos Votos\n")
    print("Como os votos se distribuem por tipo de relacionamento?\n")

    rel_order = ['inimigos_declarados', 'hostilidade_forte', 'hostilidade_leve', 'ponto_cego', 'falso_amigo', 'aliados_mutuos', 'neutro']
    rel_labels = {
        'inimigos_declarados': 'âš”ï¸ Hostilidade MÃºtua',
        'hostilidade_forte': 'ğŸ Hostilidade Forte',
        'hostilidade_leve': 'ğŸŒ± Hostilidade Leve',
        'ponto_cego': 'ğŸ¯ Ponto Cego',
        'falso_amigo': 'ğŸ­ Falso Amigo',
        'aliados_mutuos': 'ğŸ’” TraiÃ§Ã£o de Aliado',
        'neutro': 'â“ Neutro'
    }
    rel_colors = {
        'inimigos_declarados': '#3CB44B',
        'hostilidade_forte': '#3CB44B',
        'hostilidade_leve': '#FF9800',
        'ponto_cego': '#f39c12',
        'falso_amigo': '#E6194B',
        'aliados_mutuos': '#9b59b6',
        'neutro': '#999'
    }
    rel_descriptions = {
        'inimigos_declarados': 'Ambos se dÃ£o reaÃ§Ãµes negativas. Voto coerente.',
        'hostilidade_forte': 'Votante deu reaÃ§Ã£o muito negativa (ğŸğŸ¯ğŸ¤®ğŸ¤¥). Voto coerente.',
        'hostilidade_leve': 'Votante deu reaÃ§Ã£o negativa leve (ğŸŒ±ğŸ’¼ğŸªğŸ’”). Voto coerente.',
        'ponto_cego': 'Alvo deu â¤ï¸ ao votante, mas votante o detesta. Alvo nÃ£o viu o perigo.',
        'falso_amigo': 'Votante deu â¤ï¸ ao alvo, mas votou contra. TraiÃ§Ã£o.',
        'aliados_mutuos': 'Ambos trocavam â¤ï¸. TraiÃ§Ã£o grave.',
        'neutro': 'Sem reaÃ§Ã£o clara entre os dois.'
    }

    fig = go.Figure()

    for rel in rel_order:
        count = relationship_counts.get(rel, 0)
        if count > 0:
            pct = count / total_votes * 100
            fig.add_trace(go.Bar(
                y=[rel_labels.get(rel, rel)],
                x=[count],
                orientation='h',
                marker_color=rel_colors.get(rel, '#999'),
                text=f"{count} ({pct:.0f}%)",
                textposition='auto',
                hovertemplate=f'{rel_labels.get(rel, rel)}: {count} votos<br>{rel_descriptions.get(rel, "")}<extra></extra>',
                showlegend=False
            ))

    fig.update_layout(
        title=f"DistribuiÃ§Ã£o dos Votos por Tipo de Relacionamento<br><sup>{paredao['numero']}Âº ParedÃ£o â€” Total: {total_votes} votos</sup>",
        height=350,
        xaxis_title="NÃºmero de votos",
        yaxis_title="",
        margin=dict(l=200, r=30, t=80, b=50),
    )

    fig.show()

    # Interpretation
    coerentes = relationship_counts.get('inimigos_declarados', 0) + relationship_counts.get('hostilidade_forte', 0) + relationship_counts.get('hostilidade_leve', 0)
    incoerentes = relationship_counts.get('falso_amigo', 0) + relationship_counts.get('aliados_mutuos', 0)
    pct_coerente = coerentes / total_votes * 100 if total_votes else 0
    pct_incoerente = incoerentes / total_votes * 100 if total_votes else 0

    print(f"\n**Resumo:**\n")
    print(f"âœ… **{coerentes} votos coerentes** ({pct_coerente:.0f}%)<br>")
    print(f"Votaram em quem davam reaÃ§Ã£o negativa no queridÃ´metro\n")
    print(f"âŒ **{incoerentes} votos incoerentes** ({pct_incoerente:.0f}%)<br>")
    print(f"Votaram em quem davam â¤ï¸ publicamente\n")
    print(f"ğŸ¯ **{n_pontos_cegos} pontos cegos**<br>")
    print(f"Alvos que confiavam no votante (davam â¤ï¸) mas eram odiados por ele\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # AS TRAIÃ‡Ã•ES â€” FALSOS AMIGOS E ALIADOS QUE TRAÃRAM
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Helper function for Portuguese gender agreement
    def genero(nome):
        """Retorna 'f' para feminino, 'm' para masculino baseado no nome."""
        nome_lower = nome.lower().split()[0]  # First name

        # Explicit female names
        female_names = {'maxiane', 'marciele', 'milena', 'gabriela', 'jordana', 'samira',
                       'chaiany', 'solange', 'sarah', 'sol'}
        if nome_lower in female_names:
            return 'f'

        # Common female name endings in Portuguese
        if nome_lower.endswith('a') and not nome_lower.endswith('ba'):  # Babu exception
            return 'f'

        return 'm'

    def artigo(nome, definido=True):
        """Retorna artigo definido/indefinido baseado no gÃªnero."""
        if genero(nome) == 'f':
            return 'a' if definido else 'uma'
        return 'o' if definido else 'um'

    if betrayals:
        print("### ğŸ­ As TraiÃ§Ãµes\n")
        print(f"**{len(betrayals)} voto(s)** de pessoas que davam â¤ï¸ ao alvo â€” contradiÃ§Ã£o entre reaÃ§Ã£o e voto.\n")

        betrayal_targets = Counter([b['alvo'] for b in betrayals])
        if betrayal_targets:
            top_target, top_count = betrayal_targets.most_common(1)[0]
            gen = genero(top_target)
            traido = "traÃ­da" if gen == 'f' else "traÃ­do"
            art = "a" if gen == 'f' else "o"
            print(f"**Principal alvo:** {top_target} ({top_count} voto[s]) â€” {art} mais {traido}\n")

        print('<table class="table table-striped" style="font-size: 1.05rem;">')
        print('<thead><tr><th>Votante</th><th>Alvo</th><th style="text-align:center;">O votante dava</th><th>O alvo retribuÃ­a?</th></tr></thead>')
        print('<tbody>')
        for b in betrayals:
            reciproca = f"Sim, {b['emoji_recebido']}" if b['tipo'] == 'aliados_mutuos' else "NÃ£o"
            print(f'<tr><td>{avatar_html(b["votante"], 32)}</td><td>{avatar_html(b["alvo"], 32)}</td><td style="text-align:center; font-size:1.2em;">{b["emoji_dado"]}</td><td>{reciproca}</td></tr>')
        print('</tbody></table>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # OS PONTOS CEGOS â€” QUEM NÃƒO PERCEBEU O PERIGO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if blind_spots:
        print("### ğŸ¯ Os Pontos Cegos\n")
        print(f"**{len(blind_spots)} voto(s)** de inimigos disfarÃ§ados â€” a vÃ­tima dava â¤ï¸ sem saber que era odiada.\n")

        blind_spot_victims = Counter([bs['alvo'] for bs in blind_spots])
        if blind_spot_victims:
            top_victim, top_count = blind_spot_victims.most_common(1)[0]
            gen_v = genero(top_victim)
            ele_ela = "ela" if gen_v == 'f' else "ele"
            amigas_os = "amigas" if gen_v == 'f' else "amigos"
            print(f"**Maior risco:** {top_victim} â€” {top_count} pessoas que {ele_ela} achava {amigas_os} votaram contra\n")

        print('<table class="table table-striped" style="font-size: 1.05rem;">')
        print('<thead><tr><th>VÃ­tima</th><th>Votante</th><th style="text-align:center;">A vÃ­tima dava</th><th style="text-align:center;">O votante dava</th></tr></thead>')
        print('<tbody>')
        for bs in blind_spots:
            print(f'<tr><td>{avatar_html(bs["alvo"], 32)}</td><td>{avatar_html(bs["votante"], 32)}</td><td style="text-align:center; font-size:1.1em;">{bs["emoji_recebido"]} (confiava)</td><td style="text-align:center; font-size:1.1em;">{bs["emoji_dado"]} (hostil)</td></tr>')
        print('</tbody></table>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EVOLUÃ‡ÃƒO TEMPORAL â€” COMO OS RELACIONAMENTOS MUDARAM
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Count temporal patterns
    ex_amigos = [v for v in vote_analysis if v['hist_pattern'] == 'ex_amigos']
    recem_inimigos = [v for v in vote_analysis if v['hist_pattern'] == 'recem_inimigos']
    sempre_amigos = [v for v in vote_analysis if v['hist_pattern'] == 'sempre_amigos']
    sempre_inimigos = [v for v in vote_analysis if v['hist_pattern'] == 'sempre_inimigos']
    amigos_longa_data = [v for v in vote_analysis if v['days_mutual_friends'] >= 5]

    has_temporal_insights = len(ex_amigos) > 0 or len(recem_inimigos) > 0 or len(sempre_amigos) > 0

    if has_temporal_insights and n_daily >= 3:
        print("### â³ EvoluÃ§Ã£o dos Relacionamentos\n")
        print(f"Analisando o **histÃ³rico de {n_daily} dias** para entender se os votos seguem padrÃµes antigos ou mudanÃ§as recentes.\n")

        # Recent enemies (suspicious timing!)
        if recem_inimigos:
            print("#### ğŸš¨ MudanÃ§a de Ãšltima Hora\n")
            print(f"**{len(recem_inimigos)} voto(s)** de quem mudou de opiniÃ£o nos Ãºltimos 2 dias â€” timing suspeito!\n")
            print('<table class="table table-striped" style="font-size: 1.05rem;">')
            print('<thead><tr><th>Votante</th><th>Alvo</th><th>SituaÃ§Ã£o</th></tr></thead>')
            print('<tbody>')
            for v in recem_inimigos:
                print(f'<tr><td>{avatar_html(v["votante"], 32)}</td><td>{avatar_html(v["alvo"], 32)}</td><td>{v["hist_narrative"]}</td></tr>')
            print('</tbody></table>\n')

        # Ex-friends who became enemies
        if ex_amigos:
            print("#### ğŸ’” Ex-Amigos\n")
            print(f"**{len(ex_amigos)} voto(s)** de quem jÃ¡ deu â¤ï¸ no passado mas depois se afastou:\n")
            print('<table class="table table-striped" style="font-size: 1.05rem;">')
            print('<thead><tr><th>Votante</th><th>Alvo</th><th>SituaÃ§Ã£o</th></tr></thead>')
            print('<tbody>')
            for v in ex_amigos:
                print(f'<tr><td>{avatar_html(v["votante"], 32)}</td><td>{avatar_html(v["alvo"], 32)}</td><td>{v["hist_narrative"]}</td></tr>')
            print('</tbody></table>\n')

        # Voted against consistent friends (big betrayal)
        always_friends_voted = [v for v in sempre_amigos if v['tipo'] in ('falso_amigo', 'aliados_mutuos')]
        if always_friends_voted:
            print("#### ğŸ—¡ï¸ TraiÃ§Ã£o de Amizade de Longa Data\n")
            print(f"**{len(always_friends_voted)} voto(s)** contra quem sempre recebeu â¤ï¸ â€” traiÃ§Ã£o grave:\n")
            print('<table class="table table-striped" style="font-size: 1.05rem;">')
            print('<thead><tr><th>Votante</th><th>Alvo</th><th style="text-align:center;">Dias de amizade</th></tr></thead>')
            print('<tbody>')
            for v in always_friends_voted:
                print(f'<tr><td>{avatar_html(v["votante"], 32)}</td><td>{avatar_html(v["alvo"], 32)}</td><td style="text-align:center; font-weight:bold;">{v["days_as_friends"]} dias de â¤ï¸</td></tr>')
            print('</tbody></table>\n')

        # Long-time enemies (expected votes)
        if sempre_inimigos:
            long_enemies = [v for v in sempre_inimigos if v['days_as_enemies'] >= 5]
            if long_enemies:
                print("#### âš”ï¸ Inimigos de Longa Data\n")
                print(f"**{len(long_enemies)} voto(s)** de rivalidades que jÃ¡ duram â‰¥5 dias â€” votos esperados:\n")
                print('<table class="table table-striped" style="font-size: 1.05rem;">')
                print('<thead><tr><th>Votante</th><th>Alvo</th><th style="text-align:center;">Tempo de rivalidade</th></tr></thead>')
                print('<tbody>')
                for v in long_enemies[:8]:
                    print(f'<tr><td>{avatar_html(v["votante"], 32)}</td><td>{avatar_html(v["alvo"], 32)}</td><td style="text-align:center; font-weight:bold;">{v["days_as_enemies"]} dias</td></tr>')
                print('</tbody></table>\n')

        # Summary statistics
        pattern_counts = Counter([v['hist_pattern'] for v in vote_analysis])

        print("\n#### ğŸ“Š Resumo Temporal\n")
        print("Classifica cada voto pelo **histÃ³rico do relacionamento** entre votante e alvo:\n")
        print("| PadrÃ£o | Votos | O que significa |")
        print("|--------|-------|-----------------|")
        if pattern_counts.get('sempre_amigos', 0):
            print(f"| ğŸ’š **Sempre amigos** | {pattern_counts['sempre_amigos']} | Votante sempre deu â¤ï¸ ao alvo â€” voto inesperado |")
        if pattern_counts.get('sempre_inimigos', 0):
            print(f"| ğŸ’€ **Sempre inimigos** | {pattern_counts['sempre_inimigos']} | Votante nunca deu â¤ï¸ ao alvo â€” voto esperado |")
        if pattern_counts.get('ex_amigos', 0):
            print(f"| ğŸ’” **Ex-amigos** | {pattern_counts['ex_amigos']} | Davam â¤ï¸ no passado, hoje nÃ£o mais |")
        if pattern_counts.get('recem_inimigos', 0):
            print(f"| âš¡ **MudanÃ§a recente** | {pattern_counts['recem_inimigos']} | Mudou de opiniÃ£o nos Ãºltimos 2 dias |")
        if pattern_counts.get('instavel', 0):
            print(f"| ğŸ­ **InstÃ¡veis** | {pattern_counts['instavel']} | RelaÃ§Ã£o oscilou muito ao longo do jogo |")
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # O MAIS VOTADO â€” ANÃLISE APROFUNDADA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"### ğŸ“Š O Caso {mais_votado}\n")

    mv_votos_detalhes = [v for v in vote_analysis if v['alvo'] == mais_votado]
    mv_sentiment = sent_by_name.get(mais_votado, 0)
    mv_neg = neg_count_by_name.get(mais_votado, 0)

    # Classify the votes received
    mv_from_enemies = len([v for v in mv_votos_detalhes if v['tipo'] in ('inimigos_declarados', 'hostilidade_forte', 'hostilidade_leve')])
    mv_from_traitors = len([v for v in mv_votos_detalhes if v['tipo'] in ('falso_amigo', 'aliados_mutuos')])
    mv_from_blind = len([v for v in mv_votos_detalhes if v['tipo'] == 'ponto_cego'])

    gen_mv = genero(mais_votado)
    votado_a = "votada" if gen_mv == 'f' else "votado"
    print(f"**{mais_votado}** foi {artigo(mais_votado)} mais {votado_a} pela casa com **{n_votos_mais} votos**.\n")
    print(f"| MÃ©trica | Valor |")
    print(f"|---------|-------|")
    print(f"| Sentimento total recebido | {mv_sentiment:+.1f} |")
    print(f"| ReaÃ§Ãµes negativas recebidas | {mv_neg} |")
    print(f"| Votos de quem dava negativo | {mv_from_enemies} |")
    print(f"| Votos de \"amigos\" (traiÃ§Ã£o) | {mv_from_traitors} |")
    print(f"| Pontos cegos (votantes hostis) | {mv_from_blind} |\n")

    if mv_from_traitors > n_votos_mais / 2:
        apunhalado_a = "apunhalada" if gen_mv == 'f' else "apunhalado"
        print(f"> ğŸ’” **{mais_votado} foi {apunhalado_a} pelas costas.** "
              f"Mais da metade dos votos ({mv_from_traitors}/{n_votos_mais}) veio de pessoas "
              f"que lhe davam â¤ï¸ no queridÃ´metro.\n")
    elif mv_from_enemies == n_votos_mais:
        print(f"> âš”ï¸ **{mais_votado} era um alvo Ã³bvio.** "
              f"Todos os {n_votos_mais} votos vieram de quem jÃ¡ dava reaÃ§Ã£o negativa.\n")
    elif mv_from_blind >= 2:
        print(f"> ğŸ¯ **{mais_votado} nÃ£o percebia seus inimigos.** "
              f"Dava â¤ï¸ para {mv_from_blind} pessoas que {'a' if gen_mv == 'f' else 'o'} detestavam e votaram contra {'ela' if gen_mv == 'f' else 'ele'}.\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INDICAÃ‡ÃƒO DO LÃDER
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Handle both old format (formacao as string) and new format (formacao as dict)
    formacao = paredao.get('formacao', {})
    if isinstance(formacao, dict):
        lider = formacao.get('lider')
        indicado = formacao.get('indicado_lider')
    else:
        # Old format - try top-level fields
        lider = paredao.get('lider')
        indicado = paredao.get('indicado_lider')

    if lider and indicado:
        rxn_lider = matrix.get((lider, indicado), '')
        rxn_indicado = matrix.get((indicado, lider), '')

        print(f"### ğŸ‘‘ IndicaÃ§Ã£o do LÃ­der\n")
        print(f"**{lider}** indicou **{indicado}** ao paredÃ£o.\n")

        rel_type, rel_label, _ = classify_relationship(lider, indicado, matrix)
        emoji_lider = REACTION_EMOJI.get(rxn_lider, '?')
        emoji_indicado = REACTION_EMOJI.get(rxn_indicado, '?')

        print('<table class="table" style="max-width: 500px; font-size: 1.05rem;">')
        print('<thead><tr><th>De</th><th>Para</th><th style="text-align:center;">ReaÃ§Ã£o</th></tr></thead>')
        print('<tbody>')
        print(f'<tr><td>{avatar_html(lider, 32)}</td><td>{avatar_html(indicado, 32)}</td><td style="text-align:center; font-size:1.3em;">{emoji_lider}</td></tr>')
        print(f'<tr><td>{avatar_html(indicado, 32)}</td><td>{avatar_html(lider, 32)}</td><td style="text-align:center; font-size:1.3em;">{emoji_indicado}</td></tr>')
        print('</tbody></table>\n')

        if rel_type == 'aliados_mutuos':
            print(f"> ğŸ’” **IndicaÃ§Ã£o surpreendente!** {lider} e {indicado} trocavam â¤ï¸ mÃºtuos. "
                  f"A indicaÃ§Ã£o foi uma traiÃ§Ã£o de alianÃ§a.\n")
        elif rel_type == 'falso_amigo':
            print(f"> ğŸ­ **IndicaÃ§Ã£o contraditÃ³ria.** {lider} dava â¤ï¸ para {indicado} no queridÃ´metro. "
                  f"A indicaÃ§Ã£o contradiz a reaÃ§Ã£o dada no queridÃ´metro.\n")
        elif rel_type == 'inimigos_declarados':
            print(f"> âš”ï¸ **IndicaÃ§Ã£o coerente.** {lider} e {indicado} tÃªm hostilidade mÃºtua no queridÃ´metro. "
                  f"O voto estÃ¡ alinhado com a reaÃ§Ã£o.\n")
        elif rel_type == 'ponto_cego':
            print(f"> ğŸ¯ **{indicado} nÃ£o viu a indicaÃ§Ã£o chegando.** "
                  f"Dava â¤ï¸ para {lider}, mas {lider} jÃ¡ mostrava hostilidade.\n")
        else:
            print(f"> O relacionamento entre {lider} e {indicado} era {rel_label.lower()}.\n")

        # Historical analysis of leader's relationship with nominee
        if n_daily >= 2:
            hist_indicado = analyze_relationship_history(lider, indicado, daily_matrices, daily_snapshots, paredao_date)

            # Only show history section if we have data
            if hist_indicado['pattern'] != 'sem_dados':
                print(f"#### ğŸ“… HistÃ³rico: {lider} â†’ {indicado}\n")

                if hist_indicado['pattern'] == 'sempre_inimigos':
                    print(f"**{lider}** nunca deu â¤ï¸ para {indicado} â€” inimizade desde o inÃ­cio ({hist_indicado['days_as_enemies']} dias).\n")
                elif hist_indicado['pattern'] == 'sempre_amigos':
                    print(f"**{lider}** sempre deu â¤ï¸ para {indicado} ({hist_indicado['days_as_friends']} dias). "
                          f"A indicaÃ§Ã£o contradiz o histÃ³rico!\n")
                elif hist_indicado['pattern'] == 'ex_amigos':
                    print(f"**{lider}** deu â¤ï¸ por {hist_indicado['days_as_friends']} dias, "
                          f"mas mudou em **{hist_indicado['change_date']}**. "
                          f"Desde entÃ£o, sÃ£o {hist_indicado['days_as_enemies']} dias de hostilidade.\n")
                elif hist_indicado['pattern'] == 'recem_inimigos':
                    print(f"âš ï¸ **MudanÃ§a recente!** {lider} dava â¤ï¸ por {hist_indicado['days_as_friends']} dias, "
                          f"mas virou inimigo hÃ¡ poucos dias (em {hist_indicado['change_date']}).\n")
                elif hist_indicado['pattern'] == 'instavel':
                    print(f"Relacionamento instÃ¡vel: {hist_indicado['days_as_friends']} dias de â¤ï¸ "
                          f"vs {hist_indicado['days_as_enemies']} dias de hostilidade.\n")
            else:
                # No reaction data for this leader
                print(f"> â„¹ï¸ **{lider}** nÃ£o tem histÃ³rico de reaÃ§Ãµes no queridÃ´metro â€” anÃ¡lise indisponÃ­vel.\n")

        # Check if leader nominated their worst-rated person
        worst_for_leader = None
        worst_w = float('inf')
        second_worst = None
        second_worst_w = float('inf')
        for other in neg_count_by_name:
            if other == lider:
                continue
            w = SENTIMENT_WEIGHTS.get(matrix.get((lider, other), ''), 0)
            if w < worst_w:
                second_worst = worst_for_leader
                second_worst_w = worst_w
                worst_w = w
                worst_for_leader = other
            elif w < second_worst_w:
                second_worst_w = w
                second_worst = other

        # Compare with alternative target (usually the worst enemy)
        # Only show comparison if leader has reaction data
        if worst_for_leader and worst_for_leader != indicado and worst_w < 0:
            emoji_worst = REACTION_EMOJI.get(matrix.get((lider, worst_for_leader), ''), '?')
            emoji_worst_back = REACTION_EMOJI.get(matrix.get((worst_for_leader, lider), ''), '?')

            print(f"#### ğŸ”„ Por que nÃ£o {worst_for_leader}?\n")
            print(f"A pessoa que **{lider}** mais detesta Ã© **{worst_for_leader}** ({emoji_worst}), nÃ£o {indicado}.\n")

            # Compare history with the alternative
            if n_daily >= 2 and hist_indicado['pattern'] != 'sem_dados':
                hist_worst = analyze_relationship_history(lider, worst_for_leader, daily_matrices, daily_snapshots, paredao_date)

                print('<table class="table" style="max-width: 600px; font-size: 1.05rem;">')
                print(f'<thead><tr><th>ComparaÃ§Ã£o</th><th style="text-align:center;">{avatar_html(indicado, 28)}</th><th style="text-align:center;">{avatar_html(worst_for_leader, 28)}</th></tr></thead>')
                print('<tbody>')
                print(f'<tr><td>ReaÃ§Ã£o do lÃ­der</td><td style="text-align:center; font-size:1.2em;">{emoji_lider}</td><td style="text-align:center; font-size:1.2em;">{emoji_worst}</td></tr>')
                print(f'<tr><td>ReaÃ§Ã£o de volta</td><td style="text-align:center; font-size:1.2em;">{emoji_indicado}</td><td style="text-align:center; font-size:1.2em;">{emoji_worst_back}</td></tr>')
                print(f'<tr><td>Dias de â¤ï¸</td><td style="text-align:center; font-weight:bold;">{hist_indicado["days_as_friends"]}</td><td style="text-align:center; font-weight:bold;">{hist_worst["days_as_friends"]}</td></tr>')
                print(f'<tr><td>Dias de hostilidade</td><td style="text-align:center; font-weight:bold;">{hist_indicado["days_as_enemies"]}</td><td style="text-align:center; font-weight:bold;">{hist_worst["days_as_enemies"]}</td></tr>')
                print('</tbody></table>\n')

                # Strategic interpretation
                if hist_worst['days_as_enemies'] > hist_indicado['days_as_enemies']:
                    print(f"> ğŸ§  **Escolha estratÃ©gica.** {worst_for_leader} Ã© inimigo hÃ¡ mais tempo ({hist_worst['days_as_enemies']} dias), "
                          f"mas {lider} escolheu {indicado}.\n")
                elif hist_indicado['pattern'] == 'recem_inimigos':
                    print(f"> âš¡ **Timing suspeito.** {lider} mudou de opiniÃ£o sobre {indicado} recentemente.\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TABELA COMPLETA DE VOTOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("### ğŸ“‹ Tabela Completa de Votos\n")

    # Pattern emoji mapping
    pattern_emoji = {
        'sempre_amigos': 'ğŸ’š',      # Always friends
        'sempre_inimigos': 'ğŸ’€',    # Always enemies
        'ex_amigos': 'ğŸ’”',          # Ex-friends
        'recem_inimigos': 'âš¡',     # Recent change
        'reconciliados': 'ğŸ¤',      # Reconciled
        'instavel': 'ğŸ­',           # Unstable
        'sem_dados': 'â“',          # No data
    }

    # HTML table with avatars
    print('<table class="table table-striped" style="font-size: 1.05rem;">')
    print('<thead><tr>')
    print('<th>Votante</th><th>Votou em</th><th style="text-align:center;">Deu</th><th style="text-align:center;">Recebeu</th><th>Tipo</th><th>HistÃ³rico</th>')
    print('</tr></thead>')
    print('<tbody>')
    for v in vote_analysis:
        hist = f"{pattern_emoji.get(v['hist_pattern'], '?')} {v['days_as_friends']}dâ¤ï¸"
        print(f'<tr>')
        print(f'<td>{avatar_html(v["votante"], 32)}</td>')
        print(f'<td>{avatar_html(v["alvo"], 32)}</td>')
        print(f'<td style="text-align:center; font-size:1.2em;">{v["emoji_dado"]}</td>')
        print(f'<td style="text-align:center; font-size:1.2em;">{v["emoji_recebido"]}</td>')
        print(f'<td>{v["label"]}</td>')
        print(f'<td>{hist}</td>')
        print(f'</tr>')
    print('</tbody></table>')

    print("\n**Legenda histÃ³rico:** ğŸ’š Sempre amigos | ğŸ’€ Sempre inimigos | ğŸ’” Ex-amigos | âš¡ MudanÃ§a recente | ğŸ­ InstÃ¡vel\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SCATTER PLOT: NEGATIVIDADE VS VOTOS RECEBIDOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("\n### ğŸ“ˆ ReaÃ§Ãµes Negativas vs Votos Recebidos\n")

    print("""<p style="font-size: 1.1rem; line-height: 1.6;"><strong>O que este grÃ¡fico mostra?</strong></p>

<p style="font-size: 1.05rem; line-height: 1.6;">
Cada ponto representa um participante. A posiÃ§Ã£o horizontal mostra quantas reaÃ§Ãµes negativas
(ğŸğŸ¯ğŸ¤®ğŸ¤¥ğŸ’”ğŸŒ±ğŸ’¼ğŸª) essa pessoa <strong>recebeu</strong> dos colegas. A posiÃ§Ã£o vertical mostra quantos
<strong>votos</strong> essa pessoa recebeu na votaÃ§Ã£o da casa.
</p>

<p style="font-size: 1.05rem; line-height: 1.6;">
Se os participantes votassem de acordo com o que registraram no queridÃ´metro, verÃ­amos os pontos
seguindo uma linha diagonal: quanto mais reaÃ§Ãµes negativas recebeu, mais votos receberia.
</p>

<p style="font-size: 1.05rem; line-height: 1.6;">
A <strong>correlaÃ§Ã£o (r)</strong> mede essa relaÃ§Ã£o:<br>
â€¢ <strong>r prÃ³ximo de 1</strong>: forte relaÃ§Ã£o (quem recebe mais negatividade recebe mais votos)<br>
â€¢ <strong>r prÃ³ximo de 0</strong>: sem relaÃ§Ã£o (votos sÃ£o estratÃ©gicos, nÃ£o seguem o queridÃ´metro)<br>
â€¢ <strong>r negativo</strong>: relaÃ§Ã£o inversa (quem Ã© mais odiado recebe menos votos â€” raro)
</p>

""")

    vote_counts_all = Counter(votos.values())
    scatter_data = []
    for name in set(list(vote_counts_all.keys()) + list(neg_count_by_name.keys())):
        if name in neg_count_by_name:
            scatter_data.append({
                'nome': name,
                'neg_recebidas': neg_count_by_name.get(name, 0),
                'votos_recebidos': vote_counts_all.get(name, 0),
                'grupo': MEMBER_OF.get(name, '?'),
            })

    df_scatter = pd.DataFrame(scatter_data)

    if len(df_scatter) > 2:
        corr_val = df_scatter['neg_recebidas'].corr(df_scatter['votos_recebidos'])

        fig = px.scatter(
            df_scatter, x='neg_recebidas', y='votos_recebidos',
            text='nome', color='grupo', color_discrete_map=GROUP_COLORS,
            title=f"Quem Ã© mais detestado recebe mais votos? (r = {corr_val:.2f})",
            labels={'neg_recebidas': 'ReaÃ§Ãµes negativas recebidas', 'votos_recebidos': 'Votos na casa'}
        )
        fig.update_traces(textposition='top center', textfont_size=10, marker_size=14)
        fig.update_layout(height=500, font=dict(size=13))

        if df_scatter['neg_recebidas'].std() > 0:
            z = np.polyfit(df_scatter['neg_recebidas'], df_scatter['votos_recebidos'], 1)
            x_line = np.linspace(df_scatter['neg_recebidas'].min(), df_scatter['neg_recebidas'].max(), 50)
            fig.add_trace(go.Scatter(x=x_line, y=np.polyval(z, x_line), mode='lines',
                                     line=dict(dash='dash', color='gray'), name='TendÃªncia'))

        fig.show()

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # BUILD LIST OF PEOPLE WHO COULDN'T RECEIVE HOUSE VOTES
        # (In the flattened paredÃ£o structure: lider, anjo, imunizado are at top level)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        nao_votaveis = set()

        # LÃ­der can't be voted
        if ultimo.get('lider'):
            nao_votaveis.add(ultimo['lider'])

        # Imunizado can't be voted
        if ultimo.get('imunizado') and isinstance(ultimo['imunizado'], dict):
            nao_votaveis.add(ultimo['imunizado'].get('quem', ''))

        # Anjo autoimune can't be voted
        if ultimo.get('anjo_autoimune') and ultimo.get('anjo'):
            nao_votaveis.add(ultimo['anjo'])

        # People already indicated to paredÃ£o can't receive house votes
        # (they're already nominated via LÃ­der, DinÃ¢mica, Big Fone, etc.)
        for p in ultimo.get('participantes', []):
            if p.get('como') and p['como'] != 'Casa':  # Casa = nominated by house vote
                nao_votaveis.add(p['nome'])

        # Find examples that align and don't align
        df_sorted = df_scatter.sort_values('neg_recebidas', ascending=False)
        most_hated = df_sorted.iloc[0] if len(df_sorted) > 0 else None
        most_voted_name = vote_counts_all.most_common(1)[0][0] if vote_counts_all else None

        # Filter out people who couldn't be voted for "nÃ£o alinhado" analysis
        df_votaveis = df_scatter[~df_scatter['nome'].isin(nao_votaveis)]

        # Find someone with high negativity but low votes (doesn't align) - ONLY among voteable people
        high_neg_low_votes = df_votaveis[(df_votaveis['neg_recebidas'] > df_votaveis['neg_recebidas'].median()) &
                                          (df_votaveis['votos_recebidos'] <= 1)]

        # Find someone with low negativity but high votes (doesn't align)
        low_neg_high_votes = df_votaveis[(df_votaveis['neg_recebidas'] <= df_votaveis['neg_recebidas'].median()) &
                                          (df_votaveis['votos_recebidos'] >= 3)]

        print("\n#### O que os dados mostram?\n")

        if abs(corr_val) < 0.3:
            print(f'<p style="font-size: 1.05rem;"><strong>CorrelaÃ§Ã£o fraca (r = {corr_val:.2f})</strong> â€” Os votos <strong>nÃ£o seguem</strong> as reaÃ§Ãµes do queridÃ´metro.</p>')
            print('<p style="font-size: 1.05rem;">Isso significa que os participantes estÃ£o votando de forma <strong>estratÃ©gica</strong>, nÃ£o de acordo com suas reaÃ§Ãµes. '
                  'AlguÃ©m pode receber muitas reaÃ§Ãµes negativas no queridÃ´metro mas poucos votos (estÃ¡ sendo protegido ou Ã© Ãºtil como aliado), '
                  'enquanto alguÃ©m com poucas negativas pode receber muitos votos (Ã© visto como ameaÃ§a no jogo).</p>\n')
        elif corr_val > 0.5:
            print(f'<p style="font-size: 1.05rem;"><strong>CorrelaÃ§Ã£o forte (r = {corr_val:.2f})</strong> â€” Os votos <strong>seguem</strong> o queridÃ´metro.</p>')
            print('<p style="font-size: 1.05rem;">Os participantes estÃ£o votando de acordo com o que registraram no queridÃ´metro. '
                  'Quem recebe mais reaÃ§Ãµes negativas tende a receber mais votos. '
                  'Isso indica que as relaÃ§Ãµes pessoais estÃ£o pesando mais que a estratÃ©gia de jogo.</p>\n')
        else:
            print(f'<p style="font-size: 1.05rem;"><strong>CorrelaÃ§Ã£o moderada (r = {corr_val:.2f})</strong> â€” Mistura de queridÃ´metro e estratÃ©gia.</p>')
            print('<p style="font-size: 1.05rem;">Existe alguma relaÃ§Ã£o entre negatividade no queridÃ´metro e votos recebidos, mas nÃ£o Ã© perfeita. '
                  'Alguns votos seguem as reaÃ§Ãµes negativas, outros seguem estratÃ©gia de jogo.</p>\n')

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # POUPADOS SUSPEITOS (High negativity, low votes, but COULD be voted)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        poupados = high_neg_low_votes.sort_values('neg_recebidas', ascending=False).head(5)

        if len(poupados) > 0:
            print("\n#### ğŸ›¡ï¸ Poupados Suspeitos\n")
            print('<p style="font-size: 1.05rem;">Participantes com muitas reaÃ§Ãµes negativas no queridÃ´metro mas que receberam poucos ou nenhum voto. '
                  'Podem estar sendo <strong>protegidos estrategicamente</strong> pela casa.</p>\n')

            print('<table style="font-size: 1.05rem; width: 100%;">')
            print('<thead><tr><th>Participante</th><th style="text-align:center;">Negativas</th><th style="text-align:center;">Votos</th><th>ObservaÃ§Ã£o</th></tr></thead>')
            print('<tbody>')
            for _, row in poupados.iterrows():
                obs = "Recebeu muita negatividade mas nenhum voto" if row['votos_recebidos'] == 0 else f"SÃ³ {int(row['votos_recebidos'])} voto apesar da negatividade"
                print(f'<tr>')
                print(f'<td>{avatar_html(row["nome"], 28)}</td>')
                print(f'<td style="text-align:center; font-size:1.2em;">{int(row["neg_recebidas"])}</td>')
                print(f'<td style="text-align:center; font-size:1.2em;">{int(row["votos_recebidos"])}</td>')
                print(f'<td>{obs}</td>')
                print(f'</tr>')
            print('</tbody></table>\n')

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ALVOS SURPREENDENTES (Low negativity, high votes)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        alvos = low_neg_high_votes.sort_values('votos_recebidos', ascending=False).head(5)

        if len(alvos) > 0:
            print("\n#### âš ï¸ Alvos Surpreendentes\n")
            print('<p style="font-size: 1.05rem;">Participantes com poucas reaÃ§Ãµes negativas no queridÃ´metro mas que receberam muitos votos. '
                  'EstÃ£o sendo <strong>votados por estratÃ©gia</strong>, nÃ£o por antipatia declarada.</p>\n')

            print('<table style="font-size: 1.05rem; width: 100%;">')
            print('<thead><tr><th>Participante</th><th style="text-align:center;">Negativas</th><th style="text-align:center;">Votos</th><th>ObservaÃ§Ã£o</th></tr></thead>')
            print('<tbody>')
            for _, row in alvos.iterrows():
                obs = f"Recebeu {int(row['votos_recebidos'])} votos mas sÃ³ {int(row['neg_recebidas'])} negativas â€” alvo estratÃ©gico"
                print(f'<tr>')
                print(f'<td>{avatar_html(row["nome"], 28)}</td>')
                print(f'<td style="text-align:center; font-size:1.2em;">{int(row["neg_recebidas"])}</td>')
                print(f'<td style="text-align:center; font-size:1.2em;">{int(row["votos_recebidos"])}</td>')
                print(f'<td>{obs}</td>')
                print(f'</tr>')
            print('</tbody></table>\n')

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # EXEMPLOS CONCRETOS
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        print("\n#### Exemplos concretos\n")

        # Example that aligns
        if most_hated is not None and most_voted_name:
            if most_hated['nome'] == most_voted_name:
                print(f'<p style="font-size: 1.05rem;">âœ… <strong>Alinhado:</strong> {avatar_html(most_hated["nome"], 28)} Ã© quem recebeu mais reaÃ§Ãµes negativas '
                      f'({int(most_hated["neg_recebidas"])}) e tambÃ©m mais votos '
                      f'({int(most_hated["votos_recebidos"])}). Os votos seguiram o queridÃ´metro.</p>\n')
            else:
                most_voted_data = df_scatter[df_scatter['nome'] == most_voted_name].iloc[0] if most_voted_name in df_scatter['nome'].values else None
                if most_voted_data is not None:
                    print(f'<p style="font-size: 1.05rem;">âš ï¸ <strong>Parcialmente alinhado:</strong> O mais votado foi {avatar_html(most_voted_name, 28)} '
                          f'({int(most_voted_data["votos_recebidos"])} votos, {int(most_voted_data["neg_recebidas"])} negativas), '
                          f'mas quem recebeu mais negatividade no queridÃ´metro Ã© {avatar_html(most_hated["nome"], 28)} '
                          f'({int(most_hated["neg_recebidas"])} negativas, {int(most_hated["votos_recebidos"])} votos).</p>\n')

        # Show who couldn't be voted (for context)
        if nao_votaveis:
            nao_votaveis_list = [n for n in nao_votaveis if n]
            if nao_votaveis_list:
                # Separate by reason
                indicados_nomes = [p['nome'] for p in ultimo.get('participantes', []) if p.get('como') and p['como'] != 'Casa']
                outros_nomes = [n for n in nao_votaveis_list if n not in indicados_nomes]

                print('<p style="font-size: 1.05rem; color: #aaa;">')
                if indicados_nomes:
                    indicados_str = ", ".join([f'{avatar_html(n, 24)}' for n in indicados_nomes])
                    print(f'<em>Nota: {indicados_str} jÃ¡ estava(m) indicado(s) ao paredÃ£o (por LÃ­der ou DinÃ¢mica), entÃ£o nÃ£o podia(m) receber votos da casa.</em>')
                if outros_nomes:
                    outros_str = ", ".join([f'{avatar_html(n, 24)}' for n in outros_nomes])
                    print(f'<br><em>{outros_str} nÃ£o podia(m) receber votos (lÃ­der, imunizado ou anjo autoimune).</em>')
                print('</p>\n')

        # Compare with previous paredÃ£o if available
        if len(paredoes) > 1:
            prev_paredao = paredoes[-2]
            if prev_paredao.get('votos_casa'):
                print("\n#### ComparaÃ§Ã£o com o paredÃ£o anterior\n")
                print(f'<p style="font-size: 1.05rem;">No <strong>{prev_paredao.get("titulo", "paredÃ£o anterior")}</strong>, a dinÃ¢mica pode ter sido diferente. ')
                if abs(corr_val) < 0.3:
                    print('Neste paredÃ£o, a correlaÃ§Ã£o Ã© <strong>fraca</strong> â€” os participantes estÃ£o votando mais estrategicamente.</p>\n')
                else:
                    print('Neste paredÃ£o, a correlaÃ§Ã£o Ã© mais forte â€” os votos estÃ£o mais alinhados com o queridÃ´metro.</p>\n')

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ANÃLISE DA DINÃ‚MICA (if there was one)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        dinamica = ultimo.get('dinamica')
        if dinamica and dinamica.get('indicaram') and dinamica.get('indicado'):
            indicaram = dinamica['indicaram']
            indicado = dinamica['indicado']

            print(f"\n#### ğŸ² A DecisÃ£o da DinÃ¢mica: {dinamica.get('nome', 'DinÃ¢mica')}\n")

            print(f'<p style="font-size: 1.05rem;">')
            print(f'{", ".join([avatar_html(n, 28) for n in indicaram])} escolheram indicar {avatar_html(indicado, 28)} ao paredÃ£o.')
            print(f'</p>\n')

            print(f'<p style="font-size: 1.05rem;"><strong>O que o queridÃ´metro diz sobre essa escolha?</strong></p>\n')

            # Helper function to analyze historical relationship
            def get_hist_summary(giver, receiver):
                """Analyze historical relationship between giver and receiver."""
                days_positive = 0
                days_negative = 0
                last_change = None
                prev_positive = None

                for i, mat in enumerate(daily_matrices):
                    rxn = mat.get((giver, receiver), '')
                    is_positive = rxn in POSITIVE
                    is_negative = rxn in (STRONG_NEGATIVE | MILD_NEGATIVE)

                    if is_positive:
                        days_positive += 1
                    elif is_negative:
                        days_negative += 1

                    if prev_positive is not None and prev_positive != is_positive:
                        last_change = daily_snapshots[i]['date']
                    prev_positive = is_positive

                total = days_positive + days_negative
                if total == 0:
                    return {'pattern': 'sem_dados', 'days_pos': 0, 'days_neg': 0, 'change': None}

                if days_positive == total:
                    pattern = 'sempre_amigos'
                elif days_negative == total:
                    pattern = 'sempre_inimigos'
                elif days_positive > 0 and days_negative > 0 and last_change:
                    # Check if recent change (last 2 days)
                    if days_negative <= 2:
                        pattern = 'recem_inimigos'
                    else:
                        pattern = 'ex_amigos'
                else:
                    pattern = 'instavel'

                return {'pattern': pattern, 'days_pos': days_positive, 'days_neg': days_negative, 'change': last_change}

            pattern_emoji = {'sempre_amigos': 'ğŸ’š', 'sempre_inimigos': 'ğŸ’€', 'ex_amigos': 'ğŸ’”', 'recem_inimigos': 'âš¡', 'instavel': 'ğŸ­', 'sem_dados': 'â€”'}

            # Build analysis table with historical data
            print('<table style="font-size: 1.05rem; width: 100%;">')
            print('<thead><tr><th>Quem decidiu</th><th style="text-align:center;">Deu</th><th style="text-align:center;">Recebeu</th><th>HistÃ³rico</th><th>InterpretaÃ§Ã£o</th></tr></thead>')
            print('<tbody>')

            for decisor in indicaram:
                # What did decisor give to indicado?
                dado = matrix.get((decisor, indicado), '')
                emoji_dado = REACTION_EMOJI.get(dado, 'â€”')

                # What did indicado give to decisor?
                recebido = matrix.get((indicado, decisor), '')
                emoji_recebido = REACTION_EMOJI.get(recebido, 'â€”')

                # Get historical relationship data
                hist = get_hist_summary(decisor, indicado)
                hist_str = f"{pattern_emoji.get(hist['pattern'], '?')} {hist['days_pos']}dâ¤ï¸ / {hist['days_neg']}dğŸ‘"

                # Interpretation based on current + historical
                if dado in (STRONG_NEGATIVE | MILD_NEGATIVE):
                    if hist['pattern'] == 'sempre_inimigos':
                        interp = f"Inimigos desde o inÃ­cio ({hist['days_neg']} dias)"
                    elif hist['pattern'] == 'ex_amigos':
                        interp = f"Ex-amigos â€” virou inimigo em {hist['change']}"
                    elif hist['pattern'] == 'recem_inimigos':
                        interp = f"âš ï¸ MudanÃ§a recente! Era amigo atÃ© {hist['change']}"
                    else:
                        interp = "NÃ£o gostava do indicado"
                elif dado == 'CoraÃ§Ã£o':
                    if hist['pattern'] == 'sempre_amigos':
                        interp = f"Sempre foram amigos ({hist['days_pos']} dias) â€” surpreendente!"
                    else:
                        interp = "Gostava do indicado â€” escolha inesperada"
                else:
                    interp = "â€”"

                print(f'<tr>')
                print(f'<td>{avatar_html(decisor, 28)}</td>')
                print(f'<td style="text-align:center; font-size:1.3em;">{emoji_dado}</td>')
                print(f'<td style="text-align:center; font-size:1.3em;">{emoji_recebido}</td>')
                print(f'<td>{hist_str}</td>')
                print(f'<td>{interp}</td>')
                print(f'</tr>')

            print('</tbody></table>\n')
            print('<p style="font-size: 1.05rem; color: #aaa;"><em>Legenda histÃ³rico: ğŸ’š Sempre amigos | ğŸ’€ Sempre inimigos | ğŸ’” Ex-amigos | âš¡ MudanÃ§a recente | ğŸ­ InstÃ¡vel</em></p>\n')

            # Summary
            all_gave_negative = all(
                matrix.get((d, indicado), '') in (STRONG_NEGATIVE | MILD_NEGATIVE)
                for d in indicaram
            )
            if all_gave_negative:
                print(f'<p style="font-size: 1.05rem;">âœ… <strong>Escolha coerente:</strong> Quem decidiu jÃ¡ dava reaÃ§Ãµes negativas para {avatar_html(indicado, 28)} no queridÃ´metro.</p>\n')
            else:
                print(f'<p style="font-size: 1.05rem;">âš ï¸ <strong>Escolha estratÃ©gica:</strong> A indicaÃ§Ã£o nÃ£o seguiu necessariamente as reaÃ§Ãµes do queridÃ´metro â€” pode ter sido por estratÃ©gia de jogo.</p>\n')

else:
    print("*Aguardando votaÃ§Ã£o da casa para anÃ¡lise estratÃ©gica.*")
```

---

::: {.callout-note title="ğŸ“š Ver mais" appearance="simple"}
Quer ver os paredÃµes anteriores? Acesse o **[Arquivo de ParedÃµes](paredoes.html)** com votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o.
:::

::: {.callout-caution title="â„¹ï¸ Sobre os dados" appearance="minimal" collapse="true"}
Os resultados do ParedÃ£o sÃ£o atualizados apÃ³s cada eliminaÃ§Ã£o com base em informaÃ§Ãµes oficiais (GShow, transmissÃ£o ao vivo). A anÃ¡lise de votos usa os dados do queridÃ´metro mais prÃ³ximos da data do paredÃ£o.
:::

::: {.callout-tip title="ğŸ§­ NavegaÃ§Ã£o"}
- [ğŸ“Š Painel](index.html) â€” Estado atual das reaÃ§Ãµes
- [ğŸ“… O Que Mudou](mudancas.html) â€” MudanÃ§as do dia anterior
- [ğŸ“ˆ TrajetÃ³ria](trajetoria.html) â€” EvoluÃ§Ã£o ao longo da temporada
- [ğŸ“š Arquivo](paredoes.html) â€” HistÃ³rico de paredÃµes
:::
