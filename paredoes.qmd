---
title: "BBB 26 â€” HistÃ³rico de ParedÃµes"
subtitle: "Resultado, votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime
from IPython.display import display, HTML

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    load_snapshot, get_all_snapshots, build_reaction_matrix,
    load_votalhada_polls, get_poll_for_paredao, calculate_poll_accuracy,
    require_clean_manual_events, calc_sentiment, setup_bbb_dark_theme,
    genero, artigo, get_nominee_badge,
    MONTH_MAP_PT, parse_votalhada_hora, make_poll_timeseries,
    avatar_html, avatar_img,
    REACTION_EMOJI, SENTIMENT_WEIGHTS,
    POSITIVE, MILD_NEGATIVE, STRONG_NEGATIVE, GROUP_COLORS,
)

require_clean_manual_events()
setup_bbb_dark_theme()

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")

# Load precomputed paredÃ£o analysis
_pa_path = Path("data/derived/paredao_analysis.json")
PAREDAO_ANALYSIS = json.load(open(_pa_path, encoding="utf-8")) if _pa_path.exists() else {}

# Load vote prediction data
_vp_path = Path("data/derived/vote_prediction.json")
VOTE_PRED = json.loads(_vp_path.read_text(encoding="utf-8")) if _vp_path.exists() else {}

MEMBER_OF = {}
```

```{python}
#| label: load-data
#| include: false

def get_snapshot_for_date(target_date, snapshots_list, matrices_list):
    closest_idx = 0
    for i, snap in enumerate(snapshots_list):
        if snap['date'] <= target_date:
            closest_idx = i
    return snapshots_list[closest_idx], matrices_list[closest_idx], closest_idx

all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

AVATARS = {}
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

# Build daily snapshots (one per date, last capture of the day)
daily_snapshots = []
seen_dates = set()
for snap in reversed(snapshots):
    if snap['date'] not in seen_dates:
        seen_dates.add(snap['date'])
        daily_snapshots.append(snap)
daily_snapshots.reverse()
n_daily = len(daily_snapshots)

# classify_relationship and genero imported from data_utils
```

```{python}
#| label: paredao-data
#| include: false

PAREDOES_FILE = Path("data/paredoes.json")

def load_paredoes():
    if not PAREDOES_FILE.exists():
        return []
    with open(PAREDOES_FILE, encoding="utf-8") as f:
        data = json.load(f)

    paredoes = []
    for p in data.get('paredoes', []):
        entry = {
            'numero': p['numero'],
            'status': p['status'],
            'data': p['data'],
            'data_formacao': p.get('data_formacao'),
            'titulo': p['titulo'],
            'lider': p.get('formacao', {}).get('lider'),
            'indicado_lider': p.get('formacao', {}).get('indicado_lider'),
            'motivo_lider': p.get('formacao', {}).get('motivo_lider'),
            'formacao': p.get('formacao', {}).get('resumo', ''),
            'dinamica': p.get('formacao', {}).get('dinamica'),
            'big_fone': p.get('formacao', {}).get('big_fone'),
            'contragolpe': p.get('formacao', {}).get('contragolpe'),
            'bate_volta': p.get('formacao', {}).get('bate_volta'),
            'votos_casa': p.get('votos_casa', {}),
            'fontes': p.get('fontes', []),
        }

        im = p.get('formacao', {}).get('imunizado')
        if im:
            entry['imunizado'] = im

        if p.get('resultado'):
            entry['resultado'] = p['resultado']

        if p['status'] == 'finalizado' and p.get('resultado'):
            entry['participantes'] = []
            for ind in p.get('indicados_finais', []):
                part = {
                    'nome': ind['nome'],
                    'grupo': ind.get('grupo', MEMBER_OF.get(ind['nome'], '?')),
                    'como': ind.get('como', ''),
                }
                votos = p['resultado'].get('votos', {}).get(ind['nome'], {})
                if votos:
                    part['voto_unico'] = votos.get('voto_unico', 0)
                    part['voto_torcida'] = votos.get('voto_torcida', 0)
                    part['voto_total'] = votos.get('voto_total', 0)
                    part['resultado'] = 'ELIMINADA' if ind['nome'] == p['resultado'].get('eliminado') else 'Salva'
                entry['participantes'].append(part)
        else:
            entry['participantes'] = [
                {'nome': ind['nome'], 'grupo': ind.get('grupo', '?'), 'como': ind.get('como', '')}
                for ind in p.get('indicados_finais', [])
            ]
            entry['total_esperado'] = 3

        paredoes.append(entry)

    return paredoes

paredoes = load_paredoes()
polls_data = load_votalhada_polls()

missing_formacao = [p for p in paredoes if p.get('status') == 'finalizado' and not p.get('data_formacao')]
if missing_formacao:
    print("::: {.callout-warning title=\"âš ï¸ data_formacao ausente\" appearance=\"minimal\"}")
    print("HÃ¡ paredÃµes finalizados sem `data_formacao`. A anÃ¡lise de coerÃªncia social pode ficar menos precisa.")
    print("Preencha `data_formacao` em `data/paredoes.json`.")
    print(":::\n")
```

## Resumo das EliminaÃ§Ãµes

```{python}
#| label: paredao-summary
#| output: asis

paredoes_finalizados = [p for p in paredoes if p.get('status') == 'finalizado']

if len(paredoes_finalizados) >= 1:
    hist_rows = []
    for p in paredoes_finalizados:
        eliminado = next((x for x in p['participantes'] if x['resultado'] == 'ELIMINADA'), None)
        salvos = [x for x in p['participantes'] if x['resultado'] != 'ELIMINADA']

        row = {
            'NÂº': f"{p['numero']}Âº",
            'Data': p['data'],
            'Eliminado(a)': eliminado['nome'] if eliminado else 'â€”',
            'Grupo': eliminado['grupo'] if eliminado else 'â€”',
            'Voto Ãšnico': f"{eliminado['voto_unico']:.1f}%" if eliminado and eliminado.get('voto_unico') else 'â€”',
            'Voto Torcida': f"{eliminado['voto_torcida']:.1f}%" if eliminado and eliminado.get('voto_torcida') else 'â€”',
            'MÃ©dia Final': f"{eliminado['voto_total']:.1f}%" if eliminado else 'â€”',
            'Salvos': ', '.join(s['nome'] for s in salvos),
        }
        hist_rows.append(row)

    df_hist = pd.DataFrame(hist_rows)
    print(df_hist.to_markdown(index=False))
```

## PrecisÃ£o das Enquetes (Votalhada)

```{python}
#| label: poll-accuracy-summary
#| output: asis

all_polls = polls_data.get('paredoes', [])
finalized_polls = [p for p in all_polls if p.get('resultado_real')]

if len(finalized_polls) >= 1:
    total_correct = sum(1 for p in finalized_polls if p['resultado_real'].get('predicao_correta'))
    total_polls = len(finalized_polls)

    # Collect data for analysis
    poll_vs_votes = []  # For comparing poll vs each vote type
    platform_errors = {'sites': [], 'youtube': [], 'twitter': [], 'instagram': []}

    for poll in finalized_polls:
        elim = poll['resultado_real'].get('eliminado')
        poll_val = poll['consolidado'].get(elim, 0)
        real_val = poll['resultado_real'].get(elim, 0)

        # Get vote breakdown from paredoes data
        par = next((p for p in paredoes_finalizados if p['numero'] == poll['numero']), None)
        if par:
            elim_data = next((x for x in par['participantes'] if x['nome'] == elim), None)
            if elim_data and 'voto_total' in elim_data:
                poll_vs_votes.append({
                    'paredao': poll['numero'],
                    'eliminado': elim,
                    'enquete': poll_val,
                    'voto_unico': elim_data['voto_unico'],
                    'voto_torcida': elim_data['voto_torcida'],
                    'voto_total': elim_data['voto_total'],
                })

        # Platform errors
        for plat in platform_errors:
            if plat in poll.get('plataformas', {}):
                plat_val = poll['plataformas'][plat].get(elim, 0)
                platform_errors[plat].append({
                    'paredao': poll['numero'],
                    'erro': abs(plat_val - real_val),
                    'valor': plat_val,
                    'real': real_val,
                })

    # Calculate averages
    avg_errors = {
        'enquete_vs_total': np.mean([abs(r['enquete'] - r['voto_total']) for r in poll_vs_votes]) if poll_vs_votes else 0,
        'enquete_vs_unico': np.mean([abs(r['enquete'] - r['voto_unico']) for r in poll_vs_votes]) if poll_vs_votes else 0,
        'enquete_vs_torcida': np.mean([abs(r['enquete'] - r['voto_torcida']) for r in poll_vs_votes]) if poll_vs_votes else 0,
    }

    # Find best vote type match
    best_vote_type = min(avg_errors, key=avg_errors.get)
    best_vote_label = {'enquete_vs_total': 'MÃ©dia Final', 'enquete_vs_unico': 'Voto Ãšnico', 'enquete_vs_torcida': 'Voto Torcida'}

    # Platform averages
    platform_avg = {plat: np.mean([e['erro'] for e in errs]) for plat, errs in platform_errors.items() if errs}
    best_platform = min(platform_avg, key=platform_avg.get) if platform_avg else None

    platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

    # Summary cards
    print(f'<div style="background:rgba(155,89,182,0.1); border-radius:12px; padding:1.5rem; margin:1rem 0;">')
    print(f'<h4 style="margin:0 0 1rem 0;">ğŸ“Š Resumo da PrecisÃ£o ({total_polls} paredÃµes)</h4>')
    print(f'<div style="display:flex; flex-wrap:wrap; gap:1.5rem;">')

    pct = 100 * total_correct / total_polls
    color = '#3CB44B' if pct >= 75 else '#f39c12' if pct >= 50 else '#E6194B'
    print(f'<div style="min-width:120px;"><strong>Taxa de acerto</strong><br><span style="font-size:2em; color:{color}; font-weight:bold;">{total_correct}/{total_polls}</span><br><span style="color:#888;">({pct:.0f}%)</span></div>')

    print(f'<div style="min-width:120px;"><strong>Erro mÃ©dio</strong><br><span style="font-size:2em; color:#f39c12; font-weight:bold;">{avg_errors["enquete_vs_total"]:.1f}</span><br><span style="color:#888;">p.p. vs MÃ©dia Final</span></div>')

    print(f'<div style="min-width:150px;"><strong>Mais prÃ³ximo de</strong><br><span style="font-size:1.3em; font-weight:bold;">{best_vote_label[best_vote_type]}</span><br><span style="color:#888;">erro: {avg_errors[best_vote_type]:.1f} p.p.</span></div>')

    if best_platform:
        print(f'<div style="min-width:150px;"><strong>Plataforma mais precisa</strong><br><span style="font-size:1.3em;">{platform_names.get(best_platform, best_platform)}</span><br><span style="color:#888;">erro: {platform_avg[best_platform]:.1f} p.p.</span></div>')

    print(f'</div></div>\n')

    # Detailed comparison table: Enquete vs Vote Types
    print("\n### ğŸ“Š Enquetes vs Tipos de Voto\n")
    print('<table class="table table-striped table-sm" style="max-width:900px;">')
    print('<thead><tr><th>ParedÃ£o</th><th>Eliminado</th><th style="text-align:center;">Enquete</th>')
    print('<th style="text-align:center;">Voto Ãšnico</th><th style="text-align:center;">Voto Torcida</th><th style="text-align:center;">MÃ©dia Final</th>')
    print('<th style="text-align:center;">Melhor Match</th></tr></thead>')
    print('<tbody>')

    for r in poll_vs_votes:
        err_unico = abs(r['enquete'] - r['voto_unico'])
        err_torcida = abs(r['enquete'] - r['voto_torcida'])
        err_total = abs(r['enquete'] - r['voto_total'])

        best = 'Ãšnico' if err_unico <= err_torcida and err_unico <= err_total else 'Torcida' if err_torcida <= err_total else 'Final'
        best_err = min(err_unico, err_torcida, err_total)

        print(f'<tr><td>{r["paredao"]}Âº</td><td>{r["eliminado"]}</td>')
        print(f'<td style="text-align:center; font-weight:bold; color:#9b59b6;">{r["enquete"]:.1f}%</td>')

        # Highlight cells based on error
        for val, err in [(r['voto_unico'], err_unico), (r['voto_torcida'], err_torcida), (r['voto_total'], err_total)]:
            cell_color = '#3CB44B' if err < 10 else '#f39c12' if err < 20 else '#E6194B'
            print(f'<td style="text-align:center;">{val:.1f}% <span style="color:{cell_color}; font-size:0.8em;">({err:+.1f})</span></td>')

        print(f'<td style="text-align:center; font-weight:bold;">ğŸ¯ {best}</td>')
        print('</tr>')

    print('</tbody></table>\n')

    # Platform accuracy table
    print("\n### ğŸ† PrecisÃ£o por Plataforma\n")
    print('<table class="table table-striped table-sm" style="max-width:700px;">')
    print('<thead><tr><th>Plataforma</th>')
    for poll in finalized_polls:
        print(f'<th style="text-align:center;">{poll["numero"]}Âº Par.</th>')
    print('<th style="text-align:center; font-weight:bold;">MÃ©dia</th><th style="text-align:center;">Rank</th></tr></thead>')
    print('<tbody>')

    platform_order = ['twitter', 'sites', 'instagram', 'youtube']
    ranked_platforms = sorted(platform_avg.items(), key=lambda x: x[1])
    rank_map = {plat: i+1 for i, (plat, _) in enumerate(ranked_platforms)}

    for plat in platform_order:
        if plat not in platform_avg:
            continue
        medal = 'ğŸ¥‡' if rank_map[plat] == 1 else 'ğŸ¥ˆ' if rank_map[plat] == 2 else 'ğŸ¥‰' if rank_map[plat] == 3 else f'{rank_map[plat]}Âº'
        row_style = 'background:rgba(60,180,75,0.15);' if rank_map[plat] == 1 else ''

        print(f'<tr style="{row_style}"><td>{platform_names.get(plat, plat)}</td>')

        for poll in finalized_polls:
            err_data = next((e for e in platform_errors[plat] if e['paredao'] == poll['numero']), None)
            if err_data:
                err_color = '#3CB44B' if err_data['erro'] < 10 else '#f39c12' if err_data['erro'] < 20 else '#E6194B'
                print(f'<td style="text-align:center;"><span style="color:{err_color};">{err_data["erro"]:.1f}</span></td>')
            else:
                print('<td style="text-align:center;">â€”</td>')

        print(f'<td style="text-align:center; font-weight:bold;">{platform_avg[plat]:.1f}</td>')
        print(f'<td style="text-align:center;">{medal}</td>')
        print('</tr>')

    # Add consolidado row
    consolidado_errs = [abs(r['enquete'] - r['voto_total']) for r in poll_vs_votes]
    print(f'<tr style="background:rgba(155,89,182,0.2);"><td><strong>ğŸ“Š Consolidado</strong></td>')
    for err in consolidado_errs:
        err_color = '#3CB44B' if err < 10 else '#f39c12' if err < 20 else '#E6194B'
        print(f'<td style="text-align:center;"><span style="color:{err_color};">{err:.1f}</span></td>')
    avg_consol = np.mean(consolidado_errs)
    print(f'<td style="text-align:center; font-weight:bold;">{avg_consol:.1f}</td>')
    print('<td style="text-align:center;">â€”</td>')
    print('</tr>')

    print('</tbody></table>')
    print('<p class="text-muted small">Erro = diferenÃ§a em pontos percentuais entre previsÃ£o e resultado real (MÃ©dia Final)</p>\n')

    # â”€â”€ Platform Average Error Bar Chart â”€â”€
    platform_colors = {'sites': '#3498db', 'youtube': '#e74c3c', 'twitter': '#1da1f2', 'instagram': '#e1306c'}
    sorted_plats = sorted(platform_avg.items(), key=lambda x: x[1])  # best first
    plat_labels = [platform_names.get(p, p) for p, _ in sorted_plats]
    plat_errs = [e for _, e in sorted_plats]
    plat_colors = [platform_colors.get(p, '#999') for p, _ in sorted_plats]

    fig_bar = go.Figure()
    fig_bar.add_trace(go.Bar(
        y=plat_labels, x=plat_errs, orientation='h',
        marker_color=plat_colors,
        text=[f"{e:.1f} p.p." for e in plat_errs],
        textposition='outside',
        hovertemplate='%{y}: %{x:.1f} p.p.<extra></extra>',
    ))
    fig_bar.add_vline(x=avg_consol, line_dash='dash', line_width=2, line_color='#9b59b6',
                      annotation_text=f"Consolidado: {avg_consol:.1f}",
                      annotation_position='top right',
                      annotation_font=dict(size=10, color='#9b59b6'))
    fig_bar.update_layout(
        title="Erro MÃ©dio por Plataforma (p.p.)",
        xaxis_title="Erro mÃ©dio (pontos percentuais)",
        height=280, margin=dict(l=120, t=60, b=40),
        showlegend=False,
    )
    fig_bar.show()

    # â”€â”€ Per-ParedÃ£o Error Line Chart (only if â‰¥2 finalized) â”€â”€
    if len(finalized_polls) >= 2:
        fig_lines = go.Figure()
        paredao_labels = [f"{p['numero']}Âº" for p in finalized_polls]

        for plat in ['sites', 'youtube', 'twitter', 'instagram']:
            if plat not in platform_errors or not platform_errors[plat]:
                continue
            errs_by_par = {e['paredao']: e['erro'] for e in platform_errors[plat]}
            y_vals = [errs_by_par.get(p['numero'], None) for p in finalized_polls]
            fig_lines.add_trace(go.Scatter(
                x=paredao_labels, y=y_vals, mode='lines+markers',
                name=platform_names.get(plat, plat),
                line=dict(width=2.5, color=platform_colors.get(plat, '#999')),
                marker=dict(size=8),
                hovertemplate=f'{platform_names.get(plat, plat)}: ' + '%{y:.1f} p.p.<extra></extra>',
                connectgaps=True,
            ))

        # Add consolidado line
        fig_lines.add_trace(go.Scatter(
            x=paredao_labels, y=consolidado_errs, mode='lines+markers',
            name='ğŸ“Š Consolidado',
            line=dict(width=2.5, color='#9b59b6', dash='dash'),
            marker=dict(size=8, symbol='diamond'),
            hovertemplate='Consolidado: %{y:.1f} p.p.<extra></extra>',
        ))

        fig_lines.update_layout(
            title="EvoluÃ§Ã£o do Erro por Plataforma",
            xaxis_title="ParedÃ£o", yaxis_title="Erro (p.p.)",
            height=350, hovermode='x unified',
            legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
        )
        fig_lines.show()

        # â”€â”€ Grouped Bar Chart: Platform Error by ParedÃ£o â”€â”€
        fig_grouped = go.Figure()
        paredao_colors = px.colors.qualitative.Set2
        platforms_order = ['sites', 'youtube', 'twitter', 'instagram']

        for i, poll in enumerate(finalized_polls):
            par_num = poll['numero']
            par_label = f"{par_num}Âº ParedÃ£o"
            # Get errors for each platform for this paredÃ£o
            errs = []
            for plat in platforms_order:
                err_data = next((e for e in platform_errors.get(plat, []) if e['paredao'] == par_num), None)
                errs.append(err_data['erro'] if err_data else 0)

            fig_grouped.add_trace(go.Bar(
                name=par_label,
                x=[platform_names.get(p, p) for p in platforms_order],
                y=errs,
                marker_color=paredao_colors[i % len(paredao_colors)],
                text=[f"{e:.1f}" for e in errs],
                textposition='outside',
                hovertemplate=f'{par_label}: ' + '%{y:.1f} p.p.<extra></extra>',
            ))

        fig_grouped.update_layout(
            title="Erro por Plataforma Ã— ParedÃ£o",
            xaxis_title="Plataforma", yaxis_title="Erro (p.p.)",
            barmode='group',
            height=400,
            legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
        )
        fig_grouped.show()

    # Pattern observation
    underest = np.mean([r['enquete'] - r['voto_total'] for r in poll_vs_votes])
    pattern = "subestimam" if underest < 0 else "superestimam"
    print(f'<div style="background:rgba(52,152,219,0.1); border-radius:8px; padding:1rem; margin:1rem 0;">')
    print(f'<strong>ğŸ“‰ PadrÃ£o observado:</strong> As enquetes consistentemente <strong>{pattern}</strong> o eliminado em <strong>{abs(underest):.1f} p.p.</strong> em mÃ©dia.')
    print(f'<br><span style="color:#888;">Isso ocorre porque enquetes online sobre-representam fÃ£s engajados que votam estrategicamente.</span>')
    print(f'</div>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # IMPACTO DO PESO 70/30 VS CENÃRIO 50/50 (RETROATIVO)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    rows_5050 = []
    n_changed = 0
    poll_err_total = []
    poll_err_5050 = []

    for p in paredoes_finalizados:
        parts = []
        for part in p.get('participantes', []):
            if part.get('voto_unico') is None or part.get('voto_torcida') is None:
                continue
            vu = float(part.get('voto_unico', 0))
            vt = float(part.get('voto_torcida', 0))
            v7030 = float(part.get('voto_total', 0))
            v5050 = 0.5 * vu + 0.5 * vt
            parts.append({
                'nome': part.get('nome'),
                'v7030': v7030,
                'v5050': v5050,
            })

        if not parts:
            continue

        atual = max(parts, key=lambda x: x['v7030'])
        hipot = max(parts, key=lambda x: x['v5050'])
        mudou = atual['nome'] != hipot['nome']
        if mudou:
            n_changed += 1

        rows_5050.append({
            'ParedÃ£o': f"{p.get('numero')}Âº",
            'Eliminado (70/30)': atual['nome'],
            'Eliminado (50/50)': hipot['nome'],
            'Mudaria?': 'ğŸ” Sim' if mudou else 'âœ… NÃ£o',
            'Voto 70/30 (elim.)': f"{atual['v7030']:.2f}%",
            'Voto 50/50 (elim.)': f"{atual['v5050']:.2f}%",
            'Î” p.p. (70/30 âˆ’ 50/50)': f"{(atual['v7030'] - atual['v5050']):+.2f}",
        })

        poll = next((po for po in finalized_polls if po.get('numero') == p.get('numero')), None)
        if poll and poll.get('consolidado'):
            poll_val = poll['consolidado'].get(atual['nome'])
            if poll_val is not None:
                poll_err_total.append(abs(poll_val - atual['v7030']))
                poll_err_5050.append(abs(poll_val - atual['v5050']))

    if rows_5050:
        avg_delta = np.mean([
            abs(float(r['Î” p.p. (70/30 âˆ’ 50/50)'].replace('+', '')))
            for r in rows_5050
        ]) if rows_5050 else 0.0

        print('<h4 style="margin-top:1.8rem;">âš–ï¸ Impacto do peso 70/30 vs cenÃ¡rio 50/50</h4>')
        print('<p class="text-muted" style="margin-bottom:0.6rem;">')
        print('AtÃ© 2025, o peso era <strong>50% Voto Ãšnico + 50% Voto Torcida</strong>.')
        print('Em 2026, o BBB mudou para <strong>70% Voto Ãšnico + 30% Voto Torcida</strong>, apÃ³s forte backlash do pÃºblico: a vencedora de 2025 teve baixÃ­ssima popularidade, e houve crÃ­tica de que mutirÃµes de torcida sequestravam o resultado, impondo-se sobre o voto Ãºnico do pÃºblico geral.')
        print('Abaixo, simulamos retroativamente como ficariam os paredÃµes finalizados no cenÃ¡rio antigo <strong>50/50</strong>.')
        print('</p>')

        print(f'<div style="background:rgba(241,196,15,0.12); border-radius:10px; padding:0.9rem 1rem; margin:0.8rem 0 1rem 0;">')
        print(f'<strong>Resumo retroativo:</strong> {n_changed}/{len(rows_5050)} paredÃµes mudariam de eliminado com 50/50.')
        print(f' DiferenÃ§a mÃ©dia no percentual do eliminado: <strong>{avg_delta:.2f} p.p.</strong>.')
        if poll_err_total and poll_err_5050:
            print(f' Erro mÃ©dio das enquetes vs eliminado: <strong>{np.mean(poll_err_total):.2f} p.p.</strong> (70/30) ')
            print(f'vs <strong>{np.mean(poll_err_5050):.2f} p.p.</strong> (50/50 simulado).')
        print('</div>')

        df_5050 = pd.DataFrame(rows_5050)
        print(df_5050.to_markdown(index=False))
```

---

## Arquivo de ParedÃµes

```{python}
#| label: data-freshness
#| output: asis

n_snapshots = len(snapshots)
latest = snapshots[-1]
print(f'<p class="text-muted small">ğŸ“… Dados disponÃ­veis: <strong>{snapshots[0]["label"]}</strong> â†’ <strong>{latest["label"]}</strong> ({n_snapshots} coletas)</p>')

# Generate Bootstrap nav-tabs
tabs_html = '<ul class="nav nav-tabs" id="paredaoTabs" role="tablist">'
for i, paredao in enumerate(reversed(paredoes_finalizados)):
    par_num = paredao['numero']
    eliminado = next((x for x in paredao['participantes'] if x['resultado'] == 'ELIMINADA'), None)
    elim_name = eliminado['nome'].split()[0] if eliminado else '?'
    active = 'active' if i == 0 else ''
    selected = 'true' if i == 0 else 'false'
    tabs_html += f'''
    <li class="nav-item" role="presentation">
        <button class="nav-link {active}" id="tab-{par_num}" data-bs-toggle="tab" data-bs-target="#paredao-{par_num}"
                type="button" role="tab" aria-controls="paredao-{par_num}" aria-selected="{selected}">
            {par_num}Âº ParedÃ£o ({elim_name})
        </button>
    </li>'''
tabs_html += '</ul>'
print(tabs_html)
```

```{python}
#| label: paredao-tabs-content
#| output: asis

# Generate tab content for each finalized paredÃ£o
print('<div class="tab-content" id="paredaoTabsContent">')

for i, paredao in enumerate(reversed(paredoes_finalizados)):  # Most recent first
    par_num = paredao['numero']
    par_date = paredao['data']

    analysis_date = paredao.get('data_formacao') or par_date
    snap_p, matrix_p, idx_p = get_snapshot_for_date(analysis_date, snapshots, all_matrices)
    snap_participants = snap_p['participants']

    eliminado = next((x for x in paredao['participantes'] if x['resultado'] == 'ELIMINADA'), None)
    salvos = [x for x in paredao['participantes'] if x['resultado'] != 'ELIMINADA']

    # Tab pane wrapper
    active = 'show active' if i == 0 else ''
    print(f'<div class="tab-pane fade {active}" id="paredao-{par_num}" role="tabpanel" aria-labelledby="tab-{par_num}">')
    print(f'<h3 style="margin-top:1.5rem;">{par_num}Âº ParedÃ£o â€” {paredao["data"]}</h3>')
    print(f'<p class="text-muted small">ğŸ“… CoerÃªncia social usa queridÃ´metro do dia <strong>{analysis_date}</strong> (formaÃ§Ã£o). Score base: 70% janela reativa + 30% memÃ³ria de sequÃªncia.</p>')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # HEADER WITH RESULT CARDS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; margin: 1rem 0 1.5rem 0;">')
    for part in paredao['participantes']:
        nome = part['nome']
        grupo = part.get('grupo', MEMBER_OF.get(nome, '?'))
        resultado = part.get('resultado', '')
        voto_total = part.get('voto_total', 0)
        avatar_url = AVATARS.get(nome, '')
        cor_grupo = GROUP_COLORS.get(grupo, '#666')

        if resultado == 'ELIMINADA':
            border_color = '#E6194B'
            badge_bg = '#E6194B'
            badge_text = 'ELIMINADO(A)'
            img_filter = 'grayscale(100%)'
        else:
            border_color = '#3CB44B'
            badge_bg = '#3CB44B'
            badge_text = 'SALVO(A)'
            img_filter = 'none'

        print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 12px; padding: 1rem; text-align: center; width: 130px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); border: 2px solid {border_color};">')
        if avatar_url:
            print(f'<img src="{avatar_url}" alt="{nome}" style="width: 70px; height: 70px; border-radius: 50%; object-fit: cover; border: 2px solid {border_color}; margin-bottom: 0.5rem; filter: {img_filter};">')
        print(f'<div style="color: #fff; font-size: 0.9em; font-weight:bold;">{nome.split()[0]}</div>')
        print(f'<span style="display: inline-block; padding: 0.15rem 0.4rem; background: {badge_bg}; color: #fff; border-radius: 8px; font-size: 0.65em; margin: 0.3rem 0;">{badge_text}</span>')
        print(f'<div style="color: #fff; font-size: 1.2em; font-weight: bold;">{voto_total:.1f}%</div>')
        print('</div>')
    print('</div>')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # RESULT CHART
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    df_p = pd.DataFrame(paredao['participantes'])
    has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

    fig = go.Figure()

    if has_breakdown:
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_unico'],
            text=[f"{v:.1f}%" for v in df_p['voto_unico']],
            textposition='outside', name='Voto Ãšnico (70%)',
            marker_color='#1976D2',
        ))
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_torcida'],
            text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
            textposition='outside', name='Voto Torcida (30%)',
            marker_color='#FF9800',
        ))

    colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
    fig.add_trace(go.Bar(
        x=df_p['nome'], y=df_p['voto_total'],
        text=[f"{v:.1f}%" for v in df_p['voto_total']],
        textposition='outside', name='MÃ©dia Final',
        marker_color=colors_total,
    ))

    fig.update_layout(
        title=dict(text=f"Resultado: {par_num}Âº ParedÃ£o", y=0.95, x=0.5, xanchor='center'),
        xaxis_title="", yaxis_title="Votos (%)",
        yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
        barmode='group',
        height=400,
        margin=dict(t=80),
        legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
    )
    fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # COERÃŠNCIA SOCIAL (votos + indicaÃ§Ãµes vs queridÃ´metro da formaÃ§Ã£o)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    votos = paredao.get('votos_casa', {})
    def alignment_from_reaction(label):
        if label in (MILD_NEGATIVE | STRONG_NEGATIVE):
            return "alinhado"
        if label in POSITIVE:
            return "contraditorio"
        return "neutro"

    vote_align = Counter()
    for votante, alvo in votos.items():
        label = matrix_p.get((votante, alvo), '')
        vote_align[alignment_from_reaction(label)] += 1

    indicacoes = []
    if paredao.get('lider') and paredao.get('indicado_lider'):
        indicacoes.append(('LÃ­der', paredao.get('lider'), paredao.get('indicado_lider')))
    if paredao.get('big_fone'):
        bf = paredao.get('big_fone')
        if bf.get('atendeu') and bf.get('indicou'):
            indicacoes.append(('Big Fone', bf.get('atendeu'), bf.get('indicou')))
    if paredao.get('contragolpe'):
        cg = paredao.get('contragolpe')
        if cg.get('de') and cg.get('para'):
            indicacoes.append(('Contragolpe', cg.get('de'), cg.get('para')))
    if paredao.get('dinamica'):
        din = paredao.get('dinamica')
        indicados = din.get('indicaram') or []
        alvo = din.get('indicado')
        for ator in indicados:
            indicacoes.append((din.get('nome', 'DinÃ¢mica'), ator, alvo))

    ind_align = Counter()
    for origem, ator, alvo in indicacoes:
        label = matrix_p.get((ator, alvo), '')
        ind_align[alignment_from_reaction(label)] += 1

    total_votes = max(1, len(votos))
    aligned_pct = vote_align["alinhado"] / total_votes * 100
    contrad_pct = vote_align["contraditorio"] / total_votes * 100

    print("<h4 style='margin-top:1.2rem;'>ğŸ§­ CoerÃªncia social</h4>")
    print(f"<p style='font-size:0.98rem;'>Votos: <strong>{aligned_pct:.0f}% alinhados</strong> vs <strong>{contrad_pct:.0f}% contraditÃ³rios</strong> com o queridÃ´metro da formaÃ§Ã£o.</p>")
    if indicacoes:
        total_ind = len(indicacoes)
        print(f"<p style='font-size:0.95rem;'>IndicaÃ§Ãµes pÃºblicas coerentes: {ind_align['alinhado']}/{total_ind}.</p>")

    # Badge vs realidade (contradiÃ§Ãµes)
        if paredao.get('votos_casa'):
            votos = paredao['votos_casa']
        # compute false friends + votes per participant
        active_names = [p['name'] for p in snap_participants if not p.get('characteristics', {}).get('eliminated')]
        false_friends = {}
        for name in active_names:
            ff = 0
            for other in active_names:
                if other == name:
                    continue
                my = matrix_p.get((name, other), '')
                their = matrix_p.get((other, name), '')
                if my in POSITIVE and their and their not in POSITIVE:
                    ff += 1
            false_friends[name] = ff

        # indicacoes publicas / elegibilidade
        ineligible = set()
        indicacoes = Counter()
        if paredao.get('indicado_lider'):
            ineligible.add(paredao.get('indicado_lider'))
            indicacoes[paredao.get('indicado_lider')] += 1
        if paredao.get('big_fone'):
            bf = paredao.get('big_fone')
            if bf.get('indicou'):
                ineligible.add(bf.get('indicou'))
                indicacoes[bf.get('indicou')] += 1
        if paredao.get('contragolpe'):
            cg = paredao.get('contragolpe')
            if cg.get('para'):
                ineligible.add(cg.get('para'))
                indicacoes[cg.get('para')] += 1
        if paredao.get('dinamica'):
            din = paredao.get('dinamica')
            alvo = din.get('indicado')
            if alvo:
                ineligible.add(alvo)
                indicacoes[alvo] += 1
        if paredao.get('imunizado'):
            im = paredao.get('imunizado')
            if im.get('quem'):
                ineligible.add(im.get('quem'))

        vuln_no_votes = []
        prot_with_votes = []
        for name in active_names:
            votes_count = sum(1 for v, a in votos.items() if a == name)
            ff = false_friends.get(name, 0)
            if ff >= 5:
                vuln = 'ğŸ”´ MUITO VULNERÃVEL'
            elif ff >= 3:
                vuln = 'ğŸŸ  VULNERÃVEL'
            elif ff >= 1:
                vuln = 'ğŸŸ¡ ATENÃ‡ÃƒO'
            else:
                vuln = 'ğŸŸ¢ PROTEGIDO'

            eligible = name not in ineligible
            if votes_count == 0 and indicacoes.get(name, 0) == 0 and eligible and vuln in ['ğŸŸ  VULNERÃVEL', 'ğŸ”´ MUITO VULNERÃVEL']:
                vuln_no_votes.append((name, vuln, votes_count))
            if votes_count >= 3 and eligible and vuln in ['ğŸŸ¢ PROTEGIDO', 'ğŸŸ¡ ATENÃ‡ÃƒO']:
                prot_with_votes.append((name, vuln, votes_count))

        if vuln_no_votes or prot_with_votes:
            print("<div style='margin-top:0.6rem;'>")
            print("<p style='font-size:0.95rem;'><strong>ContradiÃ§Ãµes (badge vs realidade)</strong></p>")
            if vuln_no_votes:
                print("<p class='text-muted'>VulnerÃ¡veis sem votos (surpresa nÃ£o se confirmou):</p>")
                print('<ul>')
                for name, vuln, votes_count in vuln_no_votes:
                    print(f"<li>{name} â€” {vuln} (0 votos)</li>")
                print('</ul>')
            if prot_with_votes:
                print("<p class='text-muted'>Protegidos/atenÃ§Ã£o com muitos votos (voto coletivo/bloco):</p>")
                print('<ul>')
                for name, vuln, votes_count in prot_with_votes:
                    print(f"<li>{name} â€” {vuln} ({votes_count} votos)</li>")
                print('</ul>')
            print("</div>")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ENQUETES VS RESULTADO (compact)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    poll = get_poll_for_paredao(polls_data, par_num)

    if poll and poll.get('resultado_real'):
        participantes_poll = poll.get('participantes', [])
        consolidado = poll.get('consolidado', {})
        plataformas = poll.get('plataformas', {})
        resultado = poll['resultado_real']
        accuracy = calculate_poll_accuracy(poll)

        print("\n### Enquetes vs Resultado\n")

        if accuracy and accuracy['predicao_correta']:
            status_html = '<span style="background:#3CB44B; color:#fff; padding:0.2rem 0.6rem; border-radius:10px; font-size:0.85em;">âœ… PrevisÃ£o correta</span>'
        else:
            status_html = '<span style="background:#E6194B; color:#fff; padding:0.2rem 0.6rem; border-radius:10px; font-size:0.85em;">âŒ PrevisÃ£o errada</span>'

        print(f'{status_html} <span style="color:#888; font-size:0.9em;">Erro mÃ©dio: {accuracy["erro_medio"]:.1f} p.p.</span>\n')

        # Compact platform table
        print('<table class="table table-sm" style="max-width: 100%; font-size: 0.85rem;">')
        print('<thead><tr><th>Fonte</th>')
        for nome in participantes_poll:
            print(f'<th style="text-align:center;">{nome.split()[0]}</th>')
        print('</tr></thead><tbody>')

        platform_order = ['sites', 'youtube', 'twitter', 'instagram']
        plat_names = {'sites': 'Sites', 'youtube': 'YouTube', 'twitter': 'Twitter', 'instagram': 'Instagram'}

        for plat in platform_order:
            if plat in plataformas:
                pdata = plataformas[plat]
                print(f'<tr><td>{plat_names.get(plat, plat)}</td>')
                for nome in participantes_poll:
                    val = pdata.get(nome, 0)
                    is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                    style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                    print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
                print('</tr>')

        print(f'<tr style="background:rgba(155,89,182,0.2);"><td><strong>Consolidado</strong></td>')
        for nome in participantes_poll:
            print(f'<td style="text-align:center; font-weight:bold;">{consolidado.get(nome, 0):.1f}%</td>')
        print('</tr>')

        print(f'<tr style="background:rgba(52,152,219,0.2);"><td><strong>Resultado</strong></td>')
        for nome in participantes_poll:
            val = resultado.get(nome, 0)
            is_elim = nome == resultado.get('eliminado')
            style = 'font-weight:bold; color:#E6194B;' if is_elim else 'font-weight:bold; color:#3CB44B;'
            print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
        print('</tr>')
        print('</tbody></table>\n')

        # Time series chart (archive)
        if poll.get('serie_temporal'):
            fig_ts = make_poll_timeseries(poll, resultado_real=resultado, compact=True)
            if fig_ts:
                fig_ts.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FORMAÃ‡ÃƒO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"### Como foi formado\n")
    print(f"{paredao['formacao']}\n")

    if paredao.get('imunizado'):
        im = paredao['imunizado']
        print(f"**ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # VOTAÃ‡ÃƒO DA CASA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        votos = paredao['votos_casa']
        contagem = Counter(votos.values())
        ranking = contagem.most_common()

        print(f"### VotaÃ§Ã£o da Casa\n")
        print(f"**Mais votado:** {ranking[0][0]} ({ranking[0][1]} votos)\n")

        print('<table class="table table-striped" style="font-size: 1.05rem;">')
        print('<thead><tr><th>Alvo</th><th style="text-align:center;">Votos</th><th>Votantes</th></tr></thead>')
        print('<tbody>')
        for alvo, n in ranking:
            votantes = sorted([v for v, a in votos.items() if a == alvo])
            votantes_html = ' '.join([avatar_img(v, AVATARS, 42) for v in votantes])
            print(f'<tr><td>{avatar_html(alvo, AVATARS, 42)}</td><td style="text-align:center; font-weight:bold; font-size:1.1em;">{n}</td><td>{votantes_html}</td></tr>')
        print('</tbody></table>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # VOTO VS REAÃ‡ÃƒO (compact summary)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        votos = paredao['votos_casa']
        n_incoerente = 0
        n_coerente = 0

        for votante, alvo in votos.items():
            reacao_ao_alvo = matrix_p.get((votante, alvo), '')
            if reacao_ao_alvo in POSITIVE:
                n_incoerente += 1
            elif reacao_ao_alvo in MILD_NEGATIVE or reacao_ao_alvo in STRONG_NEGATIVE:
                n_coerente += 1

        total = len(votos)
        print(f"### CoerÃªncia Voto vs ReaÃ§Ã£o\n")
        print(f"**{n_coerente}/{total}** votos coerentes (votou em quem deu reaÃ§Ã£o negativa)")
        print(f"<br>**{n_incoerente}/{total}** incoerentes (deu â¤ï¸ mas votou contra)\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # RANKING DE SENTIMENTO (compact)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    sentiment_data = []
    for p in snap_participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        score = calc_sentiment(p)
        member_of = p.get('characteristics', {}).get('memberOf', '?')
        sentiment_data.append({'name': name, 'score': score, 'memberOf': member_of})

    df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

    print(f"\n### Ranking de Sentimento ({snap_p['label']})\n")

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_sent['name'],
        x=df_sent['score'],
        orientation='h',
        marker_color=[GROUP_COLORS.get(m, '#999') for m in df_sent['memberOf']],
        text=[f"{s:+.1f}" for s in df_sent['score']],
        textposition='outside',
    ))

    fig.update_layout(
        xaxis_title="Score",
        yaxis_title="",
        height=max(400, len(df_sent) * 22),
        margin=dict(l=120, t=30),
        shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                     line=dict(color='red', dash='dash', width=1))]
    )

    fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PER-NOMINEE ANALYSIS â€” Structured storytelling per nominee
    # Uses precomputed data from paredao_analysis.json
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    votos = paredao.get('votos_casa', {})
    _pa_entry = PAREDAO_ANALYSIS.get("by_paredao", {}).get(str(par_num), {})
    va = _pa_entry.get("vote_analysis", [])
    vagg = _pa_entry.get("vote_aggregates", {})
    per_nominee_data = _pa_entry.get("per_nominee", {})
    indicator_reactions = _pa_entry.get("indicator_reactions", [])
    rh_data = _pa_entry.get("relationship_history", {})
    qi = _pa_entry.get("quick_insights", {})
    indicados_stats = qi.get("indicados_stats", [])

    # Vote prediction data for this paredÃ£o
    vp_entry = VOTE_PRED.get("by_paredao", {}).get(str(par_num), {})
    vp_predictions = vp_entry.get("predictions", {})
    vp_aggregate = vp_entry.get("aggregate", {})
    vp_retro = vp_entry.get("retrospective", {})

    betrayals = [v for v in va if v["tipo"] in ("falso_amigo", "aliados_mutuos")]
    blind_spots = [v for v in va if v["tipo"] == "ponto_cego"]
    total_votes = vagg.get("total_votes", 0)
    n_traicoes = vagg.get("n_traicoes", 0)
    n_pontos_cegos = vagg.get("n_pontos_cegos", 0)
    n_esperados = vagg.get("n_esperados", 0)
    rel_counts = vagg.get("relationship_counts", {})

    if votos and va:
        # â”€â”€ Section 1: Global Narrative â”€â”€
        print(f"### ğŸ“– A HistÃ³ria do {par_num}Âº ParedÃ£o\n")
        if n_traicoes >= 3:
            print(f"ParedÃ£o marcado por **{n_traicoes} traiÃ§Ãµes** â€” votos de quem dava â¤ï¸ ao alvo.\n")
        elif n_pontos_cegos >= 3:
            print(f"ParedÃ£o de **pontos cegos** â€” {n_pontos_cegos} votos de quem o alvo considerava aliado.\n")
        elif n_esperados >= total_votes * 0.5:
            print(f"VotaÃ§Ã£o **previsÃ­vel**: {n_esperados}/{total_votes} votos de quem jÃ¡ dava negativo.\n")
        else:
            print(f"VotaÃ§Ã£o **estratÃ©gica** â€” mistura de traiÃ§Ãµes ({n_traicoes}), pontos cegos ({n_pontos_cegos}) e votos esperados ({n_esperados}).\n")

        # Coherence one-liner
        n_aligned = sum(1 for v in va if v["tipo"] in ("inimigos_declarados", "hostilidade_forte", "hostilidade_leve"))
        pct_aligned = (n_aligned / total_votes * 100) if total_votes else 0
        print(f"**CoerÃªncia:** {n_aligned}/{total_votes} votos ({pct_aligned:.0f}%) alinhados com o queridÃ´metro.\n")

        # Model accuracy summary (compact)
        if vp_retro:
            vp_ind = vp_retro.get("individual", {})
            vp_hc = vp_retro.get("high_confidence", {})
            if vp_ind.get("total", 0) > 0:
                hc_str = f" Â· Alta confianÃ§a: {vp_hc['correct']}/{vp_hc['total']} ({vp_hc['pct']:.1f}%)" if vp_hc.get("total", 0) > 0 else ""
                print(f"ğŸ¤– **PrevisÃ£o do modelo:** acertou {vp_ind['correct']}/{vp_ind['total']} votos ({vp_ind['pct']:.1f}%){hc_str}\n")

        # Anatomia dos Votos chart
        print("#### Anatomia dos Votos\n")
        rel_order_chart = [
            ('aliados_mutuos', 'ğŸ’” TraiÃ§Ã£o', '#9b59b6'),
            ('falso_amigo', 'ğŸ­ Falso Amigo', '#E6194B'),
            ('ponto_cego', 'ğŸ¯ Ponto Cego', '#f39c12'),
            ('inimigos_declarados', 'âš”ï¸ MÃºtua', '#3CB44B'),
            ('hostilidade_forte', 'ğŸ Forte', '#3CB44B'),
            ('hostilidade_leve', 'ğŸŒ± Leve', '#FF9800'),
            ('neutro', 'â“ Neutro', '#999'),
        ]
        labels_c, vals_c, colors_c = [], [], []
        for tipo, lab, cor in rel_order_chart:
            cnt = rel_counts.get(tipo, 0)
            if cnt > 0:
                labels_c.append(lab)
                vals_c.append(cnt)
                colors_c.append(cor)
        if labels_c:
            fig_rel = go.Figure(go.Bar(
                y=labels_c[::-1], x=vals_c[::-1], orientation='h',
                marker_color=colors_c[::-1],
                text=[str(v) for v in vals_c[::-1]], textposition='auto',
                textfont=dict(size=13, color='white'),
            ))
            fig_rel.update_layout(
                title=f"DistribuiÃ§Ã£o dos Votos<br><sup>Total: {total_votes}</sup>",
                height=max(220, 50 * len(labels_c)),
                xaxis_title="Votos", margin=dict(l=160, t=70), showlegend=False,
            )
            fig_rel.show()
            print()

        # â”€â”€ Section 2: Per-Nominee Loop â”€â”€
        all_nominees = list(paredao.get('participantes', []))
        bv = paredao.get('bate_volta') or {}
        bv_survivors = set()
        if bv and bv.get('vencedor'):
            bv_survivors.add(bv['vencedor'])
            existing = {p['nome'] for p in all_nominees}
            if bv['vencedor'] not in existing:
                all_nominees.append({
                    'nome': bv['vencedor'],
                    'grupo': MEMBER_OF.get(bv['vencedor'], '?'),
                    'como': 'Bate e Volta (escapou)',
                    '_bv_escapee': True,
                })

        resultado_p = paredao.get('resultado', {})
        eliminado_p = resultado_p.get('eliminado', '')

        def _sort_key(p):
            nm = p['nome']
            if nm == eliminado_p:
                return (0, 0, nm)
            if p.get('_bv_escapee'):
                return (2, 0, nm)
            return (1, -per_nominee_data.get(nm, {}).get('n_votes', 0), nm)

        all_nominees.sort(key=_sort_key)

        for nominee in all_nominees:
            nome = nominee['nome']
            grupo = nominee.get('grupo', MEMBER_OF.get(nome, '?'))
            como = nominee.get('como', '')
            is_bv = nominee.get('_bv_escapee', False)
            pn = per_nominee_data.get(nome, {})

            # Header + badge
            badge_text, badge_color, badge_emoji = get_nominee_badge(nome, paredao, bv_survivors)
            grupo_color = GROUP_COLORS.get(grupo, '#888')

            print(f"\n#### {badge_emoji} O Caso {nome}\n")
            print(f'<div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">')
            print(f'{avatar_img(nome, AVATARS, 48)}')
            print(f'<div>')
            print(f'<span style="background:{badge_color}; color:#fff; padding:3px 10px; border-radius:5px; font-weight:bold; font-size:0.9em;">{badge_text}</span>')
            print(f' <span style="color:{grupo_color}; font-weight:500; margin-left:6px;">{grupo}</span>')
            print(f'</div></div>\n')

            if como:
                print(f"**Como chegou:** {como}\n")

            # Vote percentages
            if not is_bv:
                votos_part = resultado_p.get('votos', {}).get(nome, {})
                if votos_part:
                    vu = votos_part.get('voto_unico', 0)
                    vt = votos_part.get('voto_torcida', 0)
                    vtotal = votos_part.get('voto_total', 0)
                    print(f"Voto Ãšnico {vu:.2f}% Â· Torcida {vt:.2f}% Â· **MÃ©dia {vtotal:.2f}%**\n")

            # Indicator analysis
            nom_indicators = [ir for ir in indicator_reactions if ir['target'] == nome]
            if nom_indicators:
                for ir in nom_indicators:
                    actor = ir['actor']
                    type_labels = {'lider': 'ğŸ‘‘ LÃ­der', 'contragolpe': 'ğŸŒ€ Contragolpe',
                                   'big_fone': 'ğŸ“ Big Fone', 'dinamica': 'ğŸ² DinÃ¢mica'}
                    tl = type_labels.get(ir['type'], ir['type'])
                    a2t = ir.get('actor_to_target', '?')
                    t2a = ir.get('target_to_actor', '?')
                    print(f"**{tl}:** {actor} indicou {nome} ({actor} deu {a2t}, {nome} deu {t2a})")

                    # Classification
                    a2t_raw = ir.get('actor_to_target_raw', '')
                    t2a_raw = ir.get('target_to_actor_raw', '')
                    a_pos = a2t_raw in POSITIVE
                    t_pos = t2a_raw in POSITIVE
                    a_neg = a2t_raw in (MILD_NEGATIVE | STRONG_NEGATIVE)
                    t_neg = t2a_raw in (MILD_NEGATIVE | STRONG_NEGATIVE)
                    if a_pos and t_pos:
                        print(f" â€” ğŸ’” Aliados mÃºtuos, indicaÃ§Ã£o surpreendente")
                    elif a_neg and t_neg:
                        print(f" â€” âš”ï¸ Hostilidade mÃºtua, indicaÃ§Ã£o esperada")
                    elif a_neg and t_pos:
                        print(f" â€” ğŸ¯ Ponto cego de {nome}")
                    elif a_pos and t_neg:
                        print(f" â€” ğŸ­ Falso amigo: {actor} dava â¤ï¸")
                    print()

                    key_fwd = f"{actor}â†’{nome}"
                    hist = rh_data.get(key_fwd, {})
                    if hist.get('pattern') and hist['pattern'] != 'sem_dados':
                        print(f"*HistÃ³rico: {hist.get('narrative', '')}*\n")

            # QueridÃ´metro snapshot
            stat = next((s for s in indicados_stats if s['nome'] == nome), None)
            if stat:
                sent_val = stat['sentimento']
                sc = '#4CAF50' if sent_val >= 0 else '#E6194B'
                delta = stat.get('delta_3d', 'â€”')
                dc = '#4CAF50' if 'â–²' in str(delta) or '+' in str(delta) else ('#E6194B' if 'â–¼' in str(delta) else '#888')
                print(f'<span style="color:{sc}; font-weight:bold;">Sentimento: {sent_val:+.1f}</span>'
                      f' Â· Rank {stat.get("rank", "â€”")}'
                      f' Â· <span style="color:{dc};">Î”3d {delta}</span>'
                      f' Â· Top5: {stat.get("dias_top5", 0)}d Â· Bottom5: {stat.get("dias_bottom5", 0)}d'
                      f' Â· Negativos: {stat.get("dias_negativos", "â€”")}\n')

            # Voters table
            votes_for = [v for v in va if v['alvo'] == nome]
            n_votes = pn.get('n_votes', len(votes_for))
            n_enemies = pn.get('from_enemies', 0)
            n_traitors = pn.get('from_traitors', 0)
            n_blind = pn.get('from_blind', 0)

            # Pre-compute prediction metrics (used in summary + conclusion)
            vp_predicted_votes_for = vp_aggregate.get("vote_concentration", {}).get(nome, 0) if vp_predictions else 0
            vp_correct_for_nominee = sum(
                1 for v in votes_for
                if vp_predictions.get(v['votante'], {}).get('predicted') == nome
            ) if vp_predictions else 0
            vp_surprise_votes = n_votes - vp_correct_for_nominee

            if n_votes > 0:
                parts = []
                if n_enemies: parts.append(f"{n_enemies} inimigos")
                if n_traitors: parts.append(f"{n_traitors} traiÃ§Ãµes")
                if n_blind: parts.append(f"{n_blind} pontos cegos")
                summary = f" â€” {', '.join(parts)}" if parts else ""

                print(f"**{n_votes} votos recebidos**{summary}\n")

                # Per-nominee prediction summary
                if vp_predictions and (vp_predicted_votes_for > 0 or vp_correct_for_nominee > 0):
                    if vp_predicted_votes_for == n_votes:
                        print(f"Modelo previa {vp_predicted_votes_for} votos (real: {n_votes}) â€” acertou {vp_correct_for_nominee} votantes.\n")
                    elif vp_predicted_votes_for > n_votes:
                        print(f"Modelo previa {vp_predicted_votes_for} votos (real: {n_votes}) â€” superestimou.\n")
                    elif vp_surprise_votes > 0:
                        print(f"Modelo previa {vp_predicted_votes_for} votos (real: {n_votes}) â€” {vp_surprise_votes} surpresa(s).\n")

                has_vp = bool(vp_predictions)
                print('<table class="table table-striped" style="font-size:0.9rem;">')
                print('<thead><tr><th>Votante</th><th style="text-align:center;">Deu</th><th style="text-align:center;">Recebeu</th><th>Tipo</th><th>HistÃ³rico</th>', end="")
                if has_vp:
                    print('<th style="text-align:center;">Prev.</th>', end="")
                print('</tr></thead><tbody>')
                pat_emoji = {'sempre_amigos': 'ğŸ’š', 'sempre_inimigos': 'ğŸ’€', 'ex_amigos': 'ğŸ’”',
                             'recem_inimigos': 'âš¡', 'reconciliados': 'ğŸ•Šï¸', 'instavel': 'ğŸ”„', 'sem_dados': 'â€”'}
                for v in votes_for:
                    he = pat_emoji.get(v.get('hist_pattern', ''), 'â€”')
                    # Build prediction cell
                    vp_cell = ""
                    if has_vp:
                        pred = vp_predictions.get(v['votante'], {})
                        if not pred:
                            vp_cell = '<td style="text-align:center; color:#666;">â€”</td>'
                        elif pred.get('predicted') == nome:
                            conf = pred.get('confidence', '')
                            vp_cell = f'<td style="text-align:center; color:#3CB44B; font-size:0.8em;">âœ… {conf}</td>'
                        else:
                            short = pred.get('predicted', '?').split()[0]
                            vp_cell = f'<td style="text-align:center; color:#E6194B; font-size:0.8em;">âŒâ†’{short}</td>'
                    print(f'<tr><td>{avatar_html(v["votante"], AVATARS, 24)}</td>'
                          f'<td style="text-align:center; font-size:1.1em;">{v.get("emoji_dado","?")}</td>'
                          f'<td style="text-align:center; font-size:1.1em;">{v.get("emoji_recebido","?")}</td>'
                          f'<td style="font-size:0.85em;">{v.get("label","?")}</td>'
                          f'<td style="font-size:0.8em;">{he} {v.get("hist_narrative","")}</td>'
                          f'{vp_cell}</tr>')
                print('</tbody></table>\n')

                # Highlights
                nom_betrayals = [v for v in betrayals if v['alvo'] == nome]
                nom_blind = [v for v in blind_spots if v['alvo'] == nome]
                already_shown = {v['votante'] for v in nom_betrayals} | {v['votante'] for v in nom_blind}
                nom_temporal = [v for v in votes_for if v.get('hist_pattern') in ('ex_amigos', 'recem_inimigos')
                                and v['votante'] not in already_shown]
                if nom_betrayals or nom_blind or nom_temporal:
                    for b in nom_betrayals:
                        cd = b.get('change_date') or ''
                        if b.get('hist_pattern') == 'sempre_amigos':
                            print(f"- ğŸ—¡ï¸ **TraiÃ§Ã£o de longa data:** {b['votante']} dava â¤ï¸ por {b.get('days_as_friends','?')} dias")
                        elif b.get('hist_pattern') == 'ex_amigos' and cd:
                            print(f"- ğŸ’” **Ex-amigos:** {b['votante']} e {nome} romperam em {cd}")
                        else:
                            print(f"- ğŸ’” **TraiÃ§Ã£o:** {b['votante']} dava â¤ï¸ mas votou contra")
                    for bs_item in nom_blind:
                        print(f"- ğŸ¯ **Ponto cego:** {nome} dava â¤ï¸ a {bs_item['votante']}")
                    # Temporal: summarize if many, list if few
                    if len(nom_temporal) > 3:
                        ex_names = [v['votante'] for v in nom_temporal if v.get('hist_pattern') == 'ex_amigos']
                        rec_names = [v['votante'] for v in nom_temporal if v.get('hist_pattern') == 'recem_inimigos']
                        if ex_names:
                            print(f"- ğŸ’” **{len(ex_names)} ex-amigos** votaram contra: {', '.join(ex_names)}")
                        if rec_names:
                            print(f"- âš¡ **{len(rec_names)} mudanÃ§as recentes**: {', '.join(rec_names)}")
                    else:
                        for t in nom_temporal:
                            cd = t.get('change_date') or ''
                            if t.get('hist_pattern') == 'recem_inimigos':
                                print(f"- âš¡ **MudanÃ§a recente:** {t['votante']} mudou de â¤ï¸ para negativo")
                            elif cd:
                                print(f"- ğŸ’” **Ex-amigos:** {t['votante']} rompeu com {nome} em {cd}")
                            else:
                                print(f"- ğŸ’” **Ex-amigos:** {t['votante']} e {nome} se afastaram")
                    print()

                # Conclusion
                if n_traitors >= n_votes * 0.5 and n_traitors >= 2:
                    suf = 'a' if genero(nome) == 'f' else 'o'
                    print(f"**{nome} foi apunhalad{suf} pelas costas** â€” mais da metade dos votos de quem dava â¤ï¸.\n")
                elif n_blind >= 2:
                    print(f"**{nome} nÃ£o viu seus inimigos chegando** â€” {n_blind} pontos cegos.\n")
                elif n_enemies >= n_votes * 0.7:
                    print(f"**{nome} foi alvo previsÃ­vel** â€” maioria dos votos de quem jÃ¡ dava negativo.\n")
                else:
                    print(f"VotaÃ§Ã£o mista para {nome}.\n")

                # Prediction context
                if vp_predictions:
                    if vp_correct_for_nominee >= n_votes * 0.8:
                        print(f"*ğŸ¤– Modelo previu com precisÃ£o â€” resultado coerente com o queridÃ´metro.*\n")
                    elif vp_surprise_votes >= 3:
                        print(f"*ğŸ¤– {vp_surprise_votes} votos nÃ£o previstos sugerem coordenaÃ§Ã£o estratÃ©gica.*\n")
                    elif vp_predicted_votes_for > n_votes + 2:
                        over = vp_predicted_votes_for - n_votes
                        print(f"*ğŸ¤– Modelo superestimou â€” {over} votantes escolheram outro alvo.*\n")
            elif is_bv:
                suf = 'a' if genero(nome) == 'f' else 'o'
                print(f"**{nome} escapou pelo Bate e Volta** â€” indicad{suf} mas venceu a prova.\n")
            else:
                print(f"*{nome} nÃ£o recebeu votos da casa â€” indicaÃ§Ã£o direta.*\n")

    # Close tab-pane div
    print('</div>')  # Close tab-pane

# Close tab-content div
print('</div>')  # Close tab-content
```

<div class="alert alert-info" role="alert" style="margin-top:2rem;">
<strong>Voltar:</strong> <a href="index.html">Painel Principal</a>
</div>
