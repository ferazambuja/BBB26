---
title: "BBB 26 â€” HistÃ³rico de ParedÃµes"
subtitle: "Resultado, votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime
from IPython.display import display, HTML

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0,
    'CoraÃ§Ã£o partido': -0.5  # Mild negative (disappointment, not hostility)
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito', 'CoraÃ§Ã£o partido'}  # ğŸ’” = disappointment, not hostility
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Plotly Dark Theme Configuration (matches Bootswatch darkly)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PLOT_BG = '#303030'
PAPER_BG = '#303030'
GRID_COLOR = '#444444'
TEXT_COLOR = '#fff'

import plotly.io as pio

pio.templates['bbb_dark'] = go.layout.Template(
    layout=go.Layout(
        paper_bgcolor=PAPER_BG,
        plot_bgcolor=PLOT_BG,
        font=dict(color=TEXT_COLOR, family='Lato, -apple-system, sans-serif', size=13),
        title=dict(font=dict(size=16), x=0.5, xanchor='center', y=0.95),
        margin=dict(l=70, r=30, t=70, b=60),
        xaxis=dict(gridcolor=GRID_COLOR, linecolor=GRID_COLOR, zerolinecolor=GRID_COLOR),
        yaxis=dict(gridcolor=GRID_COLOR, linecolor=GRID_COLOR, zerolinecolor=GRID_COLOR),
        legend=dict(bgcolor='rgba(0,0,0,0)', bordercolor='rgba(0,0,0,0)'),
        colorway=['#00bc8c', '#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6'],
    )
)
pio.templates.default = 'bbb_dark'
```

```{python}
#| label: load-data
#| include: false

def load_snapshot(filepath):
    """Carrega um snapshot JSON (formato novo ou antigo)."""
    with open(filepath, encoding="utf-8") as f:
        data = json.load(f)
    if isinstance(data, dict) and "participants" in data:
        return data["participants"], data.get("_metadata")
    return data, None

def get_all_snapshots():
    """Retorna lista de (filepath, date_str) ordenada cronologicamente."""
    if not DATA_DIR.exists():
        return []
    snapshots = sorted(DATA_DIR.glob("*.json"))
    result = []
    for fp in snapshots:
        parts = fp.stem.split("_")
        date_str = parts[0]
        result.append((fp, date_str))
    return result

def build_reaction_matrix(participants):
    """ConstrÃ³i dicionÃ¡rio {(giver_name, receiver_name): reaction_label}."""
    matrix = {}
    for receiver in participants:
        rname = receiver['name']
        for rxn in receiver.get('characteristics', {}).get('receivedReactions', []):
            label = rxn.get('label', '')
            for giver in rxn.get('participants', []):
                gname = giver['name']
                matrix[(gname, rname)] = label
    return matrix

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total

def get_snapshot_for_date(target_date, snapshots_list, matrices_list):
    """Retorna (snapshot, matrix, index) do snapshot mais prÃ³ximo antes/em target_date."""
    closest_idx = 0
    for i, snap in enumerate(snapshots_list):
        if snap['date'] <= target_date:
            closest_idx = i
    return snapshots_list[closest_idx], matrices_list[closest_idx], closest_idx

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label legÃ­vel
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic
```

```{python}
#| label: paredao-data
#| include: false

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  CARREGAR DADOS DE PAREDÃƒO DO JSON                          â•‘
# â•‘  Fonte: data/paredoes.json (atualizado manualmente)         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAREDOES_FILE = Path("data/paredoes.json")

def load_paredoes():
    """Carrega dados de paredÃ£o do arquivo JSON."""
    if not PAREDOES_FILE.exists():
        return []
    with open(PAREDOES_FILE, encoding="utf-8") as f:
        data = json.load(f)

    # Convert JSON structure to the format expected by the dashboard
    paredoes = []
    for p in data.get('paredoes', []):
        entry = {
            'numero': p['numero'],
            'status': p['status'],
            'data': p['data'],
            'titulo': p['titulo'],
            'lider': p.get('formacao', {}).get('lider'),
            'indicado_lider': p.get('formacao', {}).get('indicado_lider'),
            'motivo_lider': p.get('formacao', {}).get('motivo_lider'),
            'formacao': p.get('formacao', {}).get('resumo', ''),
            'votos_casa': p.get('votos_casa', {}),
            'fontes': p.get('fontes', []),
        }

        # Handle imunizado
        im = p.get('formacao', {}).get('imunizado')
        if im:
            entry['imunizado'] = im

        # Handle participantes based on status
        if p['status'] == 'finalizado' and p.get('resultado'):
            entry['participantes'] = []
            for ind in p.get('indicados_finais', []):
                part = {
                    'nome': ind['nome'],
                    'grupo': ind.get('grupo', MEMBER_OF.get(ind['nome'], '?')),
                    'como': ind.get('como', ''),
                }
                # Add vote data if available
                votos = p['resultado'].get('votos', {}).get(ind['nome'], {})
                if votos:
                    part['voto_unico'] = votos.get('voto_unico', 0)
                    part['voto_torcida'] = votos.get('voto_torcida', 0)
                    part['voto_total'] = votos.get('voto_total', 0)
                    part['resultado'] = 'ELIMINADA' if ind['nome'] == p['resultado'].get('eliminado') else 'Salva'
                entry['participantes'].append(part)
        else:
            entry['participantes'] = [
                {'nome': ind['nome'], 'grupo': ind.get('grupo', '?'), 'como': ind.get('como', '')}
                for ind in p.get('indicados_finais', [])
            ]
            entry['total_esperado'] = 3

        paredoes.append(entry)

    return paredoes

paredoes = load_paredoes()
```

## Resumo das EliminaÃ§Ãµes

```{python}
#| label: paredao-summary
#| output: asis

paredoes_finalizados = [p for p in paredoes if p.get('status') == 'finalizado']

if len(paredoes_finalizados) >= 1:
    hist_rows = []
    for p in paredoes_finalizados:
        eliminado = next((x for x in p['participantes'] if x['resultado'] == 'ELIMINADA'), None)
        salvos = [x for x in p['participantes'] if x['resultado'] != 'ELIMINADA']

        row = {
            'NÂº': f"{p['numero']}Âº",
            'Data': p['data'],
            'Eliminado(a)': eliminado['nome'] if eliminado else 'â€”',
            'Grupo': eliminado['grupo'] if eliminado else 'â€”',
            'Voto Ãšnico': f"{eliminado['voto_unico']:.1f}%" if eliminado and eliminado.get('voto_unico') else 'â€”',
            'Voto Torcida': f"{eliminado['voto_torcida']:.1f}%" if eliminado and eliminado.get('voto_torcida') else 'â€”',
            'MÃ©dia Final': f"{eliminado['voto_total']:.1f}%" if eliminado else 'â€”',
            'Salvos': ', '.join(s['nome'] for s in salvos),
            'LÃ­der': p.get('lider', 'â€”'),
        }
        hist_rows.append(row)

    df_hist = pd.DataFrame(hist_rows)
    print(df_hist.to_markdown(index=False))
```

---

Abaixo vocÃª encontra a anÃ¡lise completa de cada ParedÃ£o: resultado da votaÃ§Ã£o, formaÃ§Ã£o, votaÃ§Ã£o da casa, comparaÃ§Ã£o com reaÃ§Ãµes do queridÃ´metro e anÃ¡lise de coerÃªncia.

```{python}
#| label: data-freshness
#| output: asis

n_snapshots = len(snapshots)
latest = snapshots[-1]
print(f'<p class="text-muted small">ğŸ“… Dados disponÃ­veis: <strong>{snapshots[0]["label"]}</strong> â†’ <strong>{latest["label"]}</strong> ({n_snapshots} coletas)</p>')
```

```{python}
#| label: paredao-content
#| output: asis

# Generate all the charts and analysis for each FINALIZED paredÃ£o
# (paredÃµes em andamento nÃ£o sÃ£o exibidos no arquivo - ainda nÃ£o hÃ¡ resultado)
paredoes_finalizados = [p for p in paredoes if p.get('status') == 'finalizado']
for i, paredao in enumerate(paredoes_finalizados):
    par_num = paredao['numero']
    par_date = paredao['data']

    # Get snapshot for this paredÃ£o
    snap_p, matrix_p, idx_p = get_snapshot_for_date(par_date, snapshots, all_matrices)
    snap_participants = snap_p['participants']

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # HEADER WITH RESULT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    eliminado = next((x for x in paredao['participantes'] if x['resultado'] == 'ELIMINADA'), None)
    salvos = [x for x in paredao['participantes'] if x['resultado'] != 'ELIMINADA']

    print(f"\n# {paredao['titulo']}\n")

    # â”€â”€ Visual: Cards com fotos e resultado â”€â”€
    print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 1.5rem 0 2rem 0;">')
    for part in paredao['participantes']:
        nome = part['nome']
        grupo = part.get('grupo', MEMBER_OF.get(nome, '?'))
        resultado = part.get('resultado', '')
        voto_total = part.get('voto_total', 0)
        avatar_url = AVATARS.get(nome, '')
        cor_grupo = GROUP_COLORS.get(grupo, '#666')

        # Card styling based on result
        if resultado == 'ELIMINADA':
            border_color = '#E6194B'
            badge_bg = '#E6194B'
            badge_text = 'ELIMINADO(A)'
            img_filter = 'grayscale(100%)'  # B&W for eliminated
        else:
            border_color = '#3CB44B'
            badge_bg = '#3CB44B'
            badge_text = 'SALVO(A)'
            img_filter = 'none'

        print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 3px solid {border_color};">')
        if avatar_url:
            print(f'<img src="{avatar_url}" alt="{nome}" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid {border_color}; margin-bottom: 0.75rem; filter: {img_filter};">')
        print(f'<h4 style="margin: 0 0 0.25rem 0; color: #fff; font-size: 1em;">{nome}</h4>')
        print(f'<span style="display: block; color: {cor_grupo}; font-size: 0.8em; margin-bottom: 0.5rem;">{grupo}</span>')
        print(f'<span style="display: inline-block; padding: 0.25rem 0.6rem; background: {badge_bg}; color: #fff; border-radius: 10px; font-size: 0.75em; font-weight: bold;">{badge_text}</span>')
        print(f'<div style="color: #fff; font-size: 1.3em; font-weight: bold; margin-top: 0.5rem;">{voto_total:.1f}%</div>')
        print('</div>')
    print('</div>')

    print(f"**Coleta usada:** {snap_p['label']} ({snap_p['timestamp']})\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. GRÃFICO DE RESULTADO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    df_p = pd.DataFrame(paredao['participantes'])
    has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

    fig = go.Figure()

    if has_breakdown:
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_unico'],
            text=[f"{v:.1f}%" for v in df_p['voto_unico']],
            textposition='outside', name='Voto Ãšnico (70%)',
            marker_color='#1976D2',
        ))
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_torcida'],
            text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
            textposition='outside', name='Voto Torcida (30%)',
            marker_color='#FF9800',
        ))

    colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
    fig.add_trace(go.Bar(
        x=df_p['nome'], y=df_p['voto_total'],
        text=[f"{v:.1f}%" for v in df_p['voto_total']],
        textposition='outside', name='MÃ©dia Final',
        marker_color=colors_total,
    ))

    fig.update_layout(
        title=dict(text=f"Resultado: {paredao['titulo']}", y=0.95, x=0.5, xanchor='center'),
        xaxis_title="", yaxis_title="Votos (%)",
        yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
        barmode='group',
                height=500,
        margin=dict(t=100),
        legend=dict(orientation='h', yanchor='bottom', y=1.08, xanchor='center', x=0.5),
    )
    fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. FORMAÃ‡ÃƒO E IMUNIZAÃ‡ÃƒO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"## Como foi formado\n")
    print(f"{paredao['formacao']}\n")

    if paredao.get('imunizado'):
        im = paredao['imunizado']
        print(f"**ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. VOTAÃ‡ÃƒO DA CASA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        votos = paredao['votos_casa']
        contagem = Counter(votos.values())
        ranking = contagem.most_common()

        print(f"## VotaÃ§Ã£o da Casa\n")
        print(f"**Mais votado:** {ranking[0][0]} ({ranking[0][1]} votos)\n")

        for alvo, n in ranking:
            votantes = sorted([v for v, a in votos.items() if a == alvo])
            print(f"- **{alvo}** ({n}): {', '.join(votantes)}")
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 4. VOTO DA CASA VS REAÃ‡Ã•ES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        print(f"## Voto da Casa vs QueridÃ´metro\n")
        print("ComparaÃ§Ã£o entre o voto no confessionÃ¡rio e a reaÃ§Ã£o pÃºblica.\n")

        votos = paredao['votos_casa']
        match_rows = []

        for votante, alvo in sorted(votos.items()):
            reacao_ao_alvo = matrix_p.get((votante, alvo), '')
            emoji_alvo = REACTION_EMOJI.get(reacao_ao_alvo, '?')
            coerente = 'â€”'
            if reacao_ao_alvo in POSITIVE:
                coerente = 'â¤ï¸â†’ğŸ‘ Incoerente'
            elif reacao_ao_alvo in MILD_NEGATIVE:
                coerente = 'âœ… Leve'
            elif reacao_ao_alvo in STRONG_NEGATIVE:
                coerente = 'âœ… Forte'

            match_rows.append({
                'Votante': votante,
                'Votou em': alvo,
                'ReaÃ§Ã£o': emoji_alvo,
                'CoerÃªncia': coerente,
            })

        df_match = pd.DataFrame(match_rows)
        n_incoerente = sum(1 for r in match_rows if 'Incoerente' in r['CoerÃªncia'])
        n_coerente = sum(1 for r in match_rows if r['CoerÃªncia'].startswith('âœ…'))
        total = len(match_rows)

        print(f"**Resultado:** {n_coerente}/{total} votos coerentes, "
              f"{n_incoerente}/{total} incoerentes (deu â¤ï¸ mas votou contra).\n")
        print(df_match.to_markdown(index=False))
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 5. REAÃ‡Ã•ES PREVEEM VOTOS?
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        print(f"## ReaÃ§Ãµes Preveem Votos?\n")

        votos = paredao['votos_casa']
        vote_counts = Counter(votos.values())

        sent_by_name = {}
        neg_count_by_name = {}
        for p in snap_participants:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            name = p['name']
            sent_by_name[name] = calc_sentiment(p)
            neg_count_by_name[name] = sum(
                r['amount'] for r in p.get('characteristics', {}).get('receivedReactions', [])
                if r['label'] != 'CoraÃ§Ã£o'
            )

        # Scatter: negatividade recebida vs votos recebidos
        scatter_data = []
        for name in set(list(vote_counts.keys()) + list(neg_count_by_name.keys())):
            if name in neg_count_by_name:
                scatter_data.append({
                    'nome': name,
                    'neg_recebidas': neg_count_by_name.get(name, 0),
                    'votos_recebidos': vote_counts.get(name, 0),
                    'grupo': MEMBER_OF.get(name, '?'),
                })

        df_scatter = pd.DataFrame(scatter_data)

        if len(df_scatter) > 2:
            corr_val = df_scatter['neg_recebidas'].corr(df_scatter['votos_recebidos'])

            fig = px.scatter(
                df_scatter, x='neg_recebidas', y='votos_recebidos',
                text='nome', color='grupo', color_discrete_map=GROUP_COLORS,
                title=f"ReaÃ§Ãµes Negativas vs Votos na Casa (r = {corr_val:.2f})",
                labels={'neg_recebidas': 'ReaÃ§Ãµes negativas recebidas', 'votos_recebidos': 'Votos recebidos'}
            )
            fig.update_traces(textposition='top center', textfont_size=9, marker_size=12)
            fig.update_layout(height=450)

            if df_scatter['neg_recebidas'].std() > 0:
                z = np.polyfit(df_scatter['neg_recebidas'], df_scatter['votos_recebidos'], 1)
                x_line = np.linspace(df_scatter['neg_recebidas'].min(), df_scatter['neg_recebidas'].max(), 50)
                fig.add_trace(go.Scatter(x=x_line, y=np.polyval(z, x_line), mode='lines',
                                         line=dict(dash='dash', color='gray'), name='TendÃªncia'))
            fig.show()

            if abs(corr_val) < 0.3:
                print(f"\n> **CorrelaÃ§Ã£o fraca (r = {corr_val:.2f}):** As reaÃ§Ãµes do queridÃ´metro "
                      "**nÃ£o preveem** quem serÃ¡ votado. Votos sÃ£o estratÃ©gicos.\n")
            elif corr_val > 0.3:
                print(f"\n> **CorrelaÃ§Ã£o moderada (r = {corr_val:.2f}):** Quem recebe mais "
                      "reaÃ§Ãµes negativas tende a receber mais votos.\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 6. VOTARAM NO QUE MAIS DETESTAM?
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        print(f"## Votaram no participante que mais detestam?\n")

        votos = paredao['votos_casa']
        voted_worst = 0
        voter_analysis = []

        for votante, alvo in votos.items():
            worst_target = None
            worst_score = float('inf')
            for other_name in neg_count_by_name:
                if other_name == votante:
                    continue
                rxn = matrix_p.get((votante, other_name), '')
                weight = SENTIMENT_WEIGHTS.get(rxn, 0)
                if weight < worst_score:
                    worst_score = weight
                    worst_target = other_name

            match = alvo == worst_target
            if match:
                voted_worst += 1
            rxn_to_target = matrix_p.get((votante, alvo), '')
            emoji_to_target = REACTION_EMOJI.get(rxn_to_target, '?')
            voter_analysis.append({
                'votante': votante, 'alvo': alvo, 'emoji': emoji_to_target,
                'pior_avaliado': worst_target, 'votou_no_pior': match
            })

        pct_worst = voted_worst / len(votos) * 100
        print(f"Apenas **{voted_worst}/{len(votos)} ({pct_worst:.0f}%)** votaram na pessoa que "
              f"avaliaram mais negativamente. Os votos sÃ£o **estratÃ©gicos**.\n")

        # Pie chart de coerÃªncia
        coerencia_data = []
        for va in voter_analysis:
            rxn = matrix_p.get((va['votante'], va['alvo']), '')
            if rxn in POSITIVE:
                tipo = 'Deu â¤ï¸ mas votou contra'
            elif rxn in MILD_NEGATIVE:
                tipo = 'Coerente (negativa leve)'
            elif rxn in STRONG_NEGATIVE:
                tipo = 'Coerente (negativa forte)'
            else:
                tipo = 'Sem reaÃ§Ã£o'
            coerencia_data.append({'Tipo': tipo})

        df_coer = pd.DataFrame(coerencia_data)
        tipo_colors = {
            'Deu â¤ï¸ mas votou contra': '#E6194B',
            'Coerente (negativa leve)': '#FF9800',
            'Coerente (negativa forte)': '#3CB44B',
            'Sem reaÃ§Ã£o': '#999'
        }
        tipo_counts = df_coer['Tipo'].value_counts()
        total_votes = len(votos)

        # Horizontal bar chart instead of pie
        fig = go.Figure()

        for tipo in tipo_counts.index:
            count = tipo_counts[tipo]
            pct = count / total_votes * 100
            fig.add_trace(go.Bar(
                y=[tipo],
                x=[count],
                orientation='h',
                marker_color=tipo_colors.get(tipo, '#999'),
                text=f"{count} ({pct:.0f}%)",
                textposition='auto',
                hovertemplate=f'{tipo}: {count} votantes ({pct:.0f}%)<extra></extra>',
                showlegend=False
            ))

        fig.update_layout(
            title=f"CoerÃªncia: ReaÃ§Ã£o vs Voto â€” {par_num}Âº ParedÃ£o<br><sup>Total: {total_votes} votos</sup>",
            height=250,
            xaxis_title="NÃºmero de votantes",
            yaxis_title="",
            margin=dict(l=200),
            barmode='stack'
        )
        fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 7. O CASO DO MAIS VOTADO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        votos = paredao['votos_casa']
        vote_counts = Counter(votos.values())
        mais_votado = vote_counts.most_common(1)[0]
        mv_name, mv_votes = mais_votado
        mv_sentiment = sent_by_name.get(mv_name, 0)
        mv_neg = neg_count_by_name.get(mv_name, 0)

        votantes_dele = [v for v, a in votos.items() if a == mv_name]
        hearts_from_voters = sum(1 for v in votantes_dele if matrix_p.get((v, mv_name), '') in POSITIVE)

        print(f"## O caso {mv_name}\n")
        print(f"**{mv_name}** foi o mais votado pela casa com **{mv_votes} votos**.\n")
        print(f"- Sentimento recebido: **{mv_sentiment:+.1f}** (reaÃ§Ãµes negativas: {mv_neg})")
        print(f"- Dos {mv_votes} que votaram nele, **{hearts_from_voters}** tinham lhe dado â¤ï¸ publicamente")

        if hearts_from_voters > mv_votes / 2:
            print(f"- **{hearts_from_voters}/{mv_votes} = {hearts_from_voters/mv_votes*100:.0f}%** dos votos "
                  "foram \"duas caras\" â€” afeto pÃºblico, voto privado contra")
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 8. INDICAÃ‡ÃƒO DO LÃDER
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('lider') and paredao.get('indicado_lider'):
        lider = paredao['lider']
        indicado = paredao['indicado_lider']
        rxn_lider = matrix_p.get((lider, indicado), '')
        emoji_lider = REACTION_EMOJI.get(rxn_lider, '?')
        weight_lider = SENTIMENT_WEIGHTS.get(rxn_lider, 0)

        worst_for_leader = None
        worst_w = float('inf')
        for other in neg_count_by_name:
            if other == lider:
                continue
            w = SENTIMENT_WEIGHTS.get(matrix_p.get((lider, other), ''), 0)
            if w < worst_w:
                worst_w = w
                worst_for_leader = other

        print(f"## IndicaÃ§Ã£o do LÃ­der\n")
        print(f"**{lider}** (LÃ­der) indicou **{indicado}** ao paredÃ£o.\n")
        print(f"- ReaÃ§Ã£o do lÃ­der ao indicado: {emoji_lider} ({rxn_lider}, peso {weight_lider:+.1f})")

        if worst_for_leader == indicado:
            print(f"- **Coerente:** {indicado} era quem {lider} avaliou mais negativamente")
        else:
            emoji_worst = REACTION_EMOJI.get(matrix_p.get((lider, worst_for_leader), ''), '?')
            print(f"- Pior avaliado por {lider}: {worst_for_leader} ({emoji_worst})")
            if weight_lider < 0:
                print(f"- Parcialmente coerente: deu reaÃ§Ã£o negativa, mas nÃ£o era o pior")
            else:
                print(f"- **Incoerente:** deu {emoji_lider} ao indicado â€” decisÃ£o estratÃ©gica")
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 9. RANKING DE SENTIMENTO NO DIA DO PAREDÃƒO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"## Ranking de Sentimento â€” {snap_p['label']}\n")

    sentiment_data = []
    for p in snap_participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        score = calc_sentiment(p)
        hearts = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                     if r['label'] == 'CoraÃ§Ã£o')
        neg = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                  if r['label'] != 'CoraÃ§Ã£o')
        member_of = p.get('characteristics', {}).get('memberOf', '?')
        sentiment_data.append({
            'name': name, 'score': score, 'hearts': hearts,
            'negative': neg, 'memberOf': member_of
        })

    df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

    color_map = {name: GROUP_COLORS.get(m, '#999')
                 for name, m in zip(df_sent['name'], df_sent['memberOf'])}

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_sent['name'],
        x=df_sent['score'],
        orientation='h',
        marker_color=[color_map[n] for n in df_sent['name']],
        text=[f"{s:+.1f}" for s in df_sent['score']],
        textposition='outside',
        hovertemplate='%{y}: %{x:+.1f}<br>â¤ï¸: %{customdata[0]} | Neg: %{customdata[1]}<extra></extra>',
        customdata=list(zip(df_sent['hearts'], df_sent['negative'])),
    ))

    fig.update_layout(
        title=f"Ranking de Sentimento â€” {par_num}Âº ParedÃ£o",
        xaxis_title="Score de Sentimento",
        yaxis_title="",
                height=max(500, len(df_sent) * 28),
        margin=dict(l=150),
        shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                     line=dict(color='red', dash='dash', width=1))]
    )

    for group, color in GROUP_COLORS.items():
        fig.add_trace(go.Scatter(
            x=[None], y=[None], mode='markers',
            marker=dict(size=10, color=color),
            name=group, showlegend=True
        ))

    fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 10. REAÃ‡Ã•ES RECEBIDAS (TABELA)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"\n## ReaÃ§Ãµes Recebidas â€” {par_num}Âº ParedÃ£o\n")

    summary_rows = []
    emoji_cols = ['â¤ï¸', 'ğŸŒ±', 'ğŸ’¼', 'ğŸª', 'ğŸ', 'ğŸ¯', 'ğŸ¤®', 'ğŸ¤¥', 'ğŸ’”']

    for p in sorted(snap_participants, key=lambda x: calc_sentiment(x), reverse=True):
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        rxn_counts = {}
        for rxn in p.get('characteristics', {}).get('receivedReactions', []):
            emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
            rxn_counts[emoji] = rxn['amount']
        score = calc_sentiment(p)

        row = {'Participante': name}
        for e in emoji_cols:
            row[e] = rxn_counts.get(e, 0)
        row['Score'] = f"{score:+.1f}"
        summary_rows.append(row)

    df_summary = pd.DataFrame(summary_rows)
    print(df_summary.to_markdown(index=False))

    print("\n---\n")
```

<div class="alert alert-info" role="alert">
<strong>Voltar:</strong> <a href="index.html">Painel Principal</a>
</div>
