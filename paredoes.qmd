---
title: "BBB 26 â€” HistÃ³rico de ParedÃµes"
subtitle: "Resultado, votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime
from IPython.display import display, HTML

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import load_snapshot, get_all_snapshots, build_reaction_matrix, load_votalhada_polls, get_poll_for_paredao, calculate_poll_accuracy

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0,
    'CoraÃ§Ã£o partido': -0.5  # Mild negative (disappointment, not hostility)
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito', 'CoraÃ§Ã£o partido'}  # ğŸ’” = disappointment, not hostility
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Plotly Dark Theme Configuration (matches Bootswatch darkly)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PLOT_BG = '#303030'
PAPER_BG = '#303030'
GRID_COLOR = '#444444'
TEXT_COLOR = '#fff'

import plotly.io as pio

pio.templates['bbb_dark'] = go.layout.Template(
    layout=go.Layout(
        paper_bgcolor=PAPER_BG,
        plot_bgcolor=PLOT_BG,
        font=dict(color=TEXT_COLOR, family='Lato, -apple-system, sans-serif', size=13),
        title=dict(font=dict(size=16), x=0.5, xanchor='center', y=0.95),
        margin=dict(l=70, r=30, t=70, b=60),
        xaxis=dict(gridcolor=GRID_COLOR, linecolor=GRID_COLOR, zerolinecolor=GRID_COLOR),
        yaxis=dict(gridcolor=GRID_COLOR, linecolor=GRID_COLOR, zerolinecolor=GRID_COLOR),
        legend=dict(bgcolor='rgba(0,0,0,0)', bordercolor='rgba(0,0,0,0)'),
        colorway=['#00bc8c', '#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6'],
    )
)
pio.templates.default = 'bbb_dark'
```

```{python}
#| label: load-data
#| include: false

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total

def get_snapshot_for_date(target_date, snapshots_list, matrices_list):
    """Retorna (snapshot, matrix, index) do snapshot mais prÃ³ximo antes/em target_date."""
    closest_idx = 0
    for i, snap in enumerate(snapshots_list):
        if snap['date'] <= target_date:
            closest_idx = i
    return snapshots_list[closest_idx], matrices_list[closest_idx], closest_idx

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label legÃ­vel
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic
```

```{python}
#| label: paredao-data
#| include: false

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  CARREGAR DADOS DE PAREDÃƒO DO JSON                          â•‘
# â•‘  Fonte: data/paredoes.json (atualizado manualmente)         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PAREDOES_FILE = Path("data/paredoes.json")

def load_paredoes():
    """Carrega dados de paredÃ£o do arquivo JSON."""
    if not PAREDOES_FILE.exists():
        return []
    with open(PAREDOES_FILE, encoding="utf-8") as f:
        data = json.load(f)

    # Convert JSON structure to the format expected by the dashboard
    paredoes = []
    for p in data.get('paredoes', []):
        entry = {
            'numero': p['numero'],
            'status': p['status'],
            'data': p['data'],
            'titulo': p['titulo'],
            'lider': p.get('formacao', {}).get('lider'),
            'indicado_lider': p.get('formacao', {}).get('indicado_lider'),
            'motivo_lider': p.get('formacao', {}).get('motivo_lider'),
            'formacao': p.get('formacao', {}).get('resumo', ''),
            'votos_casa': p.get('votos_casa', {}),
            'fontes': p.get('fontes', []),
        }

        # Handle imunizado
        im = p.get('formacao', {}).get('imunizado')
        if im:
            entry['imunizado'] = im

        # Handle participantes based on status
        if p['status'] == 'finalizado' and p.get('resultado'):
            entry['participantes'] = []
            for ind in p.get('indicados_finais', []):
                part = {
                    'nome': ind['nome'],
                    'grupo': ind.get('grupo', MEMBER_OF.get(ind['nome'], '?')),
                    'como': ind.get('como', ''),
                }
                # Add vote data if available
                votos = p['resultado'].get('votos', {}).get(ind['nome'], {})
                if votos:
                    part['voto_unico'] = votos.get('voto_unico', 0)
                    part['voto_torcida'] = votos.get('voto_torcida', 0)
                    part['voto_total'] = votos.get('voto_total', 0)
                    part['resultado'] = 'ELIMINADA' if ind['nome'] == p['resultado'].get('eliminado') else 'Salva'
                entry['participantes'].append(part)
        else:
            entry['participantes'] = [
                {'nome': ind['nome'], 'grupo': ind.get('grupo', '?'), 'como': ind.get('como', '')}
                for ind in p.get('indicados_finais', [])
            ]
            entry['total_esperado'] = 3

        paredoes.append(entry)

    return paredoes

paredoes = load_paredoes()
```

## Resumo das EliminaÃ§Ãµes

```{python}
#| label: paredao-summary
#| output: asis

paredoes_finalizados = [p for p in paredoes if p.get('status') == 'finalizado']

if len(paredoes_finalizados) >= 1:
    hist_rows = []
    for p in paredoes_finalizados:
        eliminado = next((x for x in p['participantes'] if x['resultado'] == 'ELIMINADA'), None)
        salvos = [x for x in p['participantes'] if x['resultado'] != 'ELIMINADA']

        row = {
            'NÂº': f"{p['numero']}Âº",
            'Data': p['data'],
            'Eliminado(a)': eliminado['nome'] if eliminado else 'â€”',
            'Grupo': eliminado['grupo'] if eliminado else 'â€”',
            'Voto Ãšnico': f"{eliminado['voto_unico']:.1f}%" if eliminado and eliminado.get('voto_unico') else 'â€”',
            'Voto Torcida': f"{eliminado['voto_torcida']:.1f}%" if eliminado and eliminado.get('voto_torcida') else 'â€”',
            'MÃ©dia Final': f"{eliminado['voto_total']:.1f}%" if eliminado else 'â€”',
            'Salvos': ', '.join(s['nome'] for s in salvos),
            'LÃ­der': p.get('lider', 'â€”'),
        }
        hist_rows.append(row)

    df_hist = pd.DataFrame(hist_rows)
    print(df_hist.to_markdown(index=False))
```

---

Abaixo vocÃª encontra a anÃ¡lise completa de cada ParedÃ£o: resultado da votaÃ§Ã£o, formaÃ§Ã£o, votaÃ§Ã£o da casa, comparaÃ§Ã£o com reaÃ§Ãµes do queridÃ´metro e anÃ¡lise de coerÃªncia.

```{python}
#| label: data-freshness
#| output: asis

n_snapshots = len(snapshots)
latest = snapshots[-1]
print(f'<p class="text-muted small">ğŸ“… Dados disponÃ­veis: <strong>{snapshots[0]["label"]}</strong> â†’ <strong>{latest["label"]}</strong> ({n_snapshots} coletas)</p>')
```

```{python}
#| label: paredao-content
#| output: asis

# Generate all the charts and analysis for each FINALIZED paredÃ£o
# (paredÃµes em andamento nÃ£o sÃ£o exibidos no arquivo - ainda nÃ£o hÃ¡ resultado)
paredoes_finalizados = [p for p in paredoes if p.get('status') == 'finalizado']
for i, paredao in enumerate(paredoes_finalizados):
    par_num = paredao['numero']
    par_date = paredao['data']

    # Get snapshot for this paredÃ£o
    snap_p, matrix_p, idx_p = get_snapshot_for_date(par_date, snapshots, all_matrices)
    snap_participants = snap_p['participants']

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # HEADER WITH RESULT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    eliminado = next((x for x in paredao['participantes'] if x['resultado'] == 'ELIMINADA'), None)
    salvos = [x for x in paredao['participantes'] if x['resultado'] != 'ELIMINADA']

    print(f"\n# {paredao['titulo']}\n")

    # â”€â”€ Visual: Cards com fotos e resultado â”€â”€
    print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; margin: 1.5rem 0 2rem 0;">')
    for part in paredao['participantes']:
        nome = part['nome']
        grupo = part.get('grupo', MEMBER_OF.get(nome, '?'))
        resultado = part.get('resultado', '')
        voto_total = part.get('voto_total', 0)
        avatar_url = AVATARS.get(nome, '')
        cor_grupo = GROUP_COLORS.get(grupo, '#666')

        # Card styling based on result
        if resultado == 'ELIMINADA':
            border_color = '#E6194B'
            badge_bg = '#E6194B'
            badge_text = 'ELIMINADO(A)'
            img_filter = 'grayscale(100%)'  # B&W for eliminated
        else:
            border_color = '#3CB44B'
            badge_bg = '#3CB44B'
            badge_text = 'SALVO(A)'
            img_filter = 'none'

        print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 16px; padding: 1.5rem; text-align: center; width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 3px solid {border_color};">')
        if avatar_url:
            print(f'<img src="{avatar_url}" alt="{nome}" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid {border_color}; margin-bottom: 0.75rem; filter: {img_filter};">')
        print(f'<h4 style="margin: 0 0 0.25rem 0; color: #fff; font-size: 1em;">{nome}</h4>')
        print(f'<span style="display: block; color: {cor_grupo}; font-size: 0.8em; margin-bottom: 0.5rem;">{grupo}</span>')
        print(f'<span style="display: inline-block; padding: 0.25rem 0.6rem; background: {badge_bg}; color: #fff; border-radius: 10px; font-size: 0.75em; font-weight: bold;">{badge_text}</span>')
        print(f'<div style="color: #fff; font-size: 1.3em; font-weight: bold; margin-top: 0.5rem;">{voto_total:.1f}%</div>')
        print('</div>')
    print('</div>')

    print(f"**Coleta usada:** {snap_p['label']} ({snap_p['timestamp']})\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. GRÃFICO DE RESULTADO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    df_p = pd.DataFrame(paredao['participantes'])
    has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

    fig = go.Figure()

    if has_breakdown:
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_unico'],
            text=[f"{v:.1f}%" for v in df_p['voto_unico']],
            textposition='outside', name='Voto Ãšnico (70%)',
            marker_color='#1976D2',
        ))
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_torcida'],
            text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
            textposition='outside', name='Voto Torcida (30%)',
            marker_color='#FF9800',
        ))

    colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
    fig.add_trace(go.Bar(
        x=df_p['nome'], y=df_p['voto_total'],
        text=[f"{v:.1f}%" for v in df_p['voto_total']],
        textposition='outside', name='MÃ©dia Final',
        marker_color=colors_total,
    ))

    fig.update_layout(
        title=dict(text=f"Resultado: {paredao['titulo']}", y=0.95, x=0.5, xanchor='center'),
        xaxis_title="", yaxis_title="Votos (%)",
        yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
        barmode='group',
                height=500,
        margin=dict(t=100),
        legend=dict(orientation='h', yanchor='bottom', y=1.08, xanchor='center', x=0.5),
    )
    fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1b. ENQUETES VS RESULTADO (Votalhada)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    polls_data = load_votalhada_polls()
    poll = get_poll_for_paredao(polls_data, par_num)

    if poll and poll.get('resultado_real'):
        participantes_poll = poll.get('participantes', [])
        consolidado = poll.get('consolidado', {})
        plataformas = poll.get('plataformas', {})
        resultado = poll['resultado_real']
        accuracy = calculate_poll_accuracy(poll)

        print("\n## Enquetes vs Resultado\n")
        print(f'<p class="text-muted small">Dados agregados de <a href="https://votalhada.blogspot.com/" target="_blank">Votalhada</a> â€” coleta em {poll.get("data_coleta", "?")[:10]}</p>\n')

        # Status badge
        if accuracy and accuracy['predicao_correta']:
            status_html = '<span style="background:#3CB44B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âœ… PrevisÃ£o correta</span>'
        else:
            status_html = '<span style="background:#E6194B; color:#fff; padding:0.3rem 0.8rem; border-radius:12px; font-weight:bold;">âŒ PrevisÃ£o errada</span>'

        erro_medio = accuracy['erro_medio'] if accuracy else 0
        print(f'<div style="text-align:center; margin-bottom:1.5rem;">')
        print(f'{status_html}')
        print(f'<span style="margin-left:1rem; color:#888;">Erro mÃ©dio: <strong>{erro_medio:.1f}</strong> pontos percentuais</span>')
        print(f'</div>\n')

        # Grouped bar chart: Enquetes vs Resultado Real
        fig_poll = go.Figure()

        # Enquete bars
        enquete_vals = [consolidado.get(n, 0) for n in participantes_poll]
        fig_poll.add_trace(go.Bar(
            x=participantes_poll, y=enquete_vals,
            text=[f"{v:.1f}%" for v in enquete_vals],
            textposition='outside', name='Enquete (Consolidado)',
            marker_color='#9b59b6',
            hovertemplate='%{x}: %{y:.1f}% (Enquete)<extra></extra>',
        ))

        # Resultado Real bars
        resultado_vals = [resultado.get(n, 0) for n in participantes_poll]
        colors_real = ['#E6194B' if n == resultado.get('eliminado') else '#3CB44B' for n in participantes_poll]
        fig_poll.add_trace(go.Bar(
            x=participantes_poll, y=resultado_vals,
            text=[f"{v:.1f}%" for v in resultado_vals],
            textposition='outside', name='Resultado Real',
            marker_color=colors_real,
            hovertemplate='%{x}: %{y:.1f}% (Real)<extra></extra>',
        ))

        fig_poll.update_layout(
            title=dict(text='Enquetes Agregadas vs Resultado Real', y=0.95, x=0.5, xanchor='center'),
            xaxis_title="", yaxis_title="Votos (%)",
            yaxis_range=[0, max(max(enquete_vals), max(resultado_vals)) * 1.25],
            barmode='group',
            height=400,
            margin=dict(t=80, b=60),
            legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
        )

        fig_poll.show()

        # Compact platform table
        print("\n### Por Plataforma\n")
        print('<table class="table table-striped table-sm" style="max-width: 100%; font-size: 0.9rem;">')
        print('<thead><tr><th>Plataforma</th>')
        for nome in participantes_poll:
            print(f'<th style="text-align:center;">{nome.split()[0]}</th>')
        print('</tr></thead><tbody>')

        platform_order = ['sites', 'youtube', 'twitter', 'instagram']
        platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

        for plat in platform_order:
            if plat in plataformas:
                pdata = plataformas[plat]
                print(f'<tr><td>{platform_names.get(plat, plat)}</td>')
                for nome in participantes_poll:
                    val = pdata.get(nome, 0)
                    is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                    style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                    print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
                print('</tr>')

        # Consolidado row
        print(f'<tr style="background:rgba(155,89,182,0.2);"><td><strong>Consolidado</strong></td>')
        for nome in participantes_poll:
            val = consolidado.get(nome, 0)
            print(f'<td style="text-align:center; font-weight:bold;">{val:.1f}%</td>')
        print('</tr>')

        # Real result row
        print(f'<tr style="background:rgba(52,152,219,0.2);"><td><strong>Resultado Real</strong></td>')
        for nome in participantes_poll:
            val = resultado.get(nome, 0)
            is_elim = nome == resultado.get('eliminado')
            style = 'font-weight:bold; color:#E6194B;' if is_elim else 'font-weight:bold; color:#3CB44B;'
            print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
        print('</tr>')

        print('</tbody></table>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. FORMAÃ‡ÃƒO E IMUNIZAÃ‡ÃƒO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"## Como foi formado\n")
    print(f"{paredao['formacao']}\n")

    if paredao.get('imunizado'):
        im = paredao['imunizado']
        print(f"**ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. VOTAÃ‡ÃƒO DA CASA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        votos = paredao['votos_casa']
        contagem = Counter(votos.values())
        ranking = contagem.most_common()

        print(f"## VotaÃ§Ã£o da Casa\n")
        print(f"**Mais votado:** {ranking[0][0]} ({ranking[0][1]} votos)\n")

        for alvo, n in ranking:
            votantes = sorted([v for v, a in votos.items() if a == alvo])
            print(f"- **{alvo}** ({n}): {', '.join(votantes)}")
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 4. VOTO DA CASA VS REAÃ‡Ã•ES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        print(f"## Voto da Casa vs QueridÃ´metro\n")
        print("ComparaÃ§Ã£o entre o voto no confessionÃ¡rio e a reaÃ§Ã£o pÃºblica.\n")

        votos = paredao['votos_casa']
        match_rows = []

        for votante, alvo in sorted(votos.items()):
            reacao_ao_alvo = matrix_p.get((votante, alvo), '')
            emoji_alvo = REACTION_EMOJI.get(reacao_ao_alvo, '?')
            coerente = 'â€”'
            if reacao_ao_alvo in POSITIVE:
                coerente = 'â¤ï¸â†’ğŸ‘ Incoerente'
            elif reacao_ao_alvo in MILD_NEGATIVE:
                coerente = 'âœ… Leve'
            elif reacao_ao_alvo in STRONG_NEGATIVE:
                coerente = 'âœ… Forte'

            match_rows.append({
                'Votante': votante,
                'Votou em': alvo,
                'ReaÃ§Ã£o': emoji_alvo,
                'CoerÃªncia': coerente,
            })

        df_match = pd.DataFrame(match_rows)
        n_incoerente = sum(1 for r in match_rows if 'Incoerente' in r['CoerÃªncia'])
        n_coerente = sum(1 for r in match_rows if r['CoerÃªncia'].startswith('âœ…'))
        total = len(match_rows)

        print(f"**Resultado:** {n_coerente}/{total} votos coerentes, "
              f"{n_incoerente}/{total} incoerentes (deu â¤ï¸ mas votou contra).\n")
        print(df_match.to_markdown(index=False))
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 5. REAÃ‡Ã•ES PREVEEM VOTOS?
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        print(f"## ReaÃ§Ãµes Preveem Votos?\n")

        print("""**Como ler este grÃ¡fico:**

Cada ponto Ã© um participante. No eixo horizontal: quantas reaÃ§Ãµes negativas (ğŸğŸ¯ğŸ¤®ğŸ¤¥ğŸ’”ğŸŒ±ğŸ’¼ğŸª)
essa pessoa **recebeu** dos colegas no queridÃ´metro. No eixo vertical: quantos **votos**
essa pessoa recebeu na votaÃ§Ã£o da casa.

A **correlaÃ§Ã£o (r)** mede se existe relaÃ§Ã£o entre ser odiado e ser votado:
- **r = 1**: perfeita relaÃ§Ã£o (todos votam em quem odeiam)
- **r = 0**: nenhuma relaÃ§Ã£o (votos sÃ£o estratÃ©gicos)
- **r negativo**: relaÃ§Ã£o inversa (protegem quem odeiam)

""")

        votos = paredao['votos_casa']
        vote_counts = Counter(votos.values())

        sent_by_name = {}
        neg_count_by_name = {}
        for p in snap_participants:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            name = p['name']
            sent_by_name[name] = calc_sentiment(p)
            neg_count_by_name[name] = sum(
                r['amount'] for r in p.get('characteristics', {}).get('receivedReactions', [])
                if r['label'] != 'CoraÃ§Ã£o'
            )

        # Scatter: negatividade recebida vs votos recebidos
        scatter_data = []
        for name in set(list(vote_counts.keys()) + list(neg_count_by_name.keys())):
            if name in neg_count_by_name:
                scatter_data.append({
                    'nome': name,
                    'neg_recebidas': neg_count_by_name.get(name, 0),
                    'votos_recebidos': vote_counts.get(name, 0),
                    'grupo': MEMBER_OF.get(name, '?'),
                })

        df_scatter = pd.DataFrame(scatter_data)

        if len(df_scatter) > 2:
            corr_val = df_scatter['neg_recebidas'].corr(df_scatter['votos_recebidos'])

            print("""<p style="font-size: 1.05rem; line-height: 1.6;">
<strong>O que este grÃ¡fico mostra?</strong> Cada ponto representa um participante.
A posiÃ§Ã£o horizontal mostra quantas reaÃ§Ãµes negativas essa pessoa <strong>recebeu</strong>.
A posiÃ§Ã£o vertical mostra quantos <strong>votos</strong> recebeu na votaÃ§Ã£o da casa.
Se os participantes votassem de acordo com o que registraram no queridÃ´metro, verÃ­amos uma diagonal:
quanto mais negatividade recebida, mais votos recebidos.
</p>
""")

            fig = px.scatter(
                df_scatter, x='neg_recebidas', y='votos_recebidos',
                text='nome', color='grupo', color_discrete_map=GROUP_COLORS,
                title=f"ReaÃ§Ãµes Negativas vs Votos na Casa (r = {corr_val:.2f})",
                labels={'neg_recebidas': 'ReaÃ§Ãµes negativas recebidas', 'votos_recebidos': 'Votos recebidos'}
            )
            fig.update_traces(textposition='top center', textfont_size=10, marker_size=14)
            fig.update_layout(height=450, font=dict(size=13))

            if df_scatter['neg_recebidas'].std() > 0:
                z = np.polyfit(df_scatter['neg_recebidas'], df_scatter['votos_recebidos'], 1)
                x_line = np.linspace(df_scatter['neg_recebidas'].min(), df_scatter['neg_recebidas'].max(), 50)
                fig.add_trace(go.Scatter(x=x_line, y=np.polyval(z, x_line), mode='lines',
                                         line=dict(dash='dash', color='gray'), name='TendÃªncia'))
            fig.show()

            # Build list of people who couldn't receive house votes
            # (In the flattened paredÃ£o structure: lider, anjo, imunizado are at top level)
            nao_votaveis = set()

            # LÃ­der can't be voted
            if paredao.get('lider'):
                nao_votaveis.add(paredao['lider'])

            # Imunizado can't be voted
            if paredao.get('imunizado') and isinstance(paredao['imunizado'], dict):
                nao_votaveis.add(paredao['imunizado'].get('quem', ''))

            # Anjo autoimune can't be voted
            if paredao.get('anjo_autoimune') and paredao.get('anjo'):
                nao_votaveis.add(paredao['anjo'])

            # People already indicated to paredÃ£o can't receive house votes
            for p in paredao.get('participantes', []):
                if p.get('como') and p['como'] != 'Casa':
                    nao_votaveis.add(p['nome'])

            # Find examples
            df_sorted = df_scatter.sort_values('neg_recebidas', ascending=False)
            most_hated = df_sorted.iloc[0] if len(df_sorted) > 0 else None
            most_voted_name = vote_counts.most_common(1)[0][0] if vote_counts else None

            # Filter out people who couldn't be voted
            df_votaveis = df_scatter[~df_scatter['nome'].isin(nao_votaveis)]

            # High negativity, low votes (only among voteable people)
            high_neg_low_votes = df_votaveis[(df_votaveis['neg_recebidas'] > df_votaveis['neg_recebidas'].median()) &
                                              (df_votaveis['votos_recebidos'] <= 1)]

            # Low negativity, high votes
            low_neg_high_votes = df_votaveis[(df_votaveis['neg_recebidas'] <= df_votaveis['neg_recebidas'].median()) &
                                              (df_votaveis['votos_recebidos'] >= 3)]

            print("\n### InterpretaÃ§Ã£o\n")

            if abs(corr_val) < 0.3:
                print(f'<p style="font-size: 1.05rem;"><strong>CorrelaÃ§Ã£o fraca (r = {corr_val:.2f})</strong> â€” Votos <strong>nÃ£o seguem</strong> o queridÃ´metro.</p>')
                print('<p style="font-size: 1.05rem;">Os participantes votaram de forma <strong>estratÃ©gica</strong>, nÃ£o de acordo com suas reaÃ§Ãµes. '
                      'Ser odiado no queridÃ´metro nÃ£o significou ser votado. '
                      'AlianÃ§as, acordos e estratÃ©gia de jogo pesaram mais que as reaÃ§Ãµes registradas.</p>\n')
            elif corr_val > 0.5:
                print(f'<p style="font-size: 1.05rem;"><strong>CorrelaÃ§Ã£o forte (r = {corr_val:.2f})</strong> â€” Votos <strong>seguem</strong> o queridÃ´metro.</p>')
                print('<p style="font-size: 1.05rem;">Os participantes votaram de acordo com o que registraram no queridÃ´metro. '
                      'As relaÃ§Ãµes pessoais dominaram a votaÃ§Ã£o.</p>\n')
            else:
                print(f'<p style="font-size: 1.05rem;"><strong>CorrelaÃ§Ã£o moderada (r = {corr_val:.2f})</strong> â€” Mistura de queridÃ´metro e estratÃ©gia.</p>')
                print('<p style="font-size: 1.05rem;">Houve alguma relaÃ§Ã£o entre ser odiado e ser votado, mas nÃ£o foi determinante. '
                      'Alguns votos seguiram as reaÃ§Ãµes, outros seguiram estratÃ©gia.</p>\n')

            # Poupados Suspeitos table
            poupados = high_neg_low_votes.sort_values('neg_recebidas', ascending=False).head(5)
            if len(poupados) > 0:
                print("\n### ğŸ›¡ï¸ Poupados Suspeitos\n")
                print('<p style="font-size: 1.05rem;">Participantes com muitas reaÃ§Ãµes negativas mas poucos votos â€” podem ter sido protegidos estrategicamente.</p>\n')
                print('<table style="font-size: 1.05rem; width: 100%;">')
                print('<thead><tr><th>Participante</th><th style="text-align:center;">Negativas</th><th style="text-align:center;">Votos</th></tr></thead>')
                print('<tbody>')
                for _, row in poupados.iterrows():
                    print(f'<tr><td><strong>{row["nome"]}</strong></td>'
                          f'<td style="text-align:center;">{int(row["neg_recebidas"])}</td>'
                          f'<td style="text-align:center;">{int(row["votos_recebidos"])}</td></tr>')
                print('</tbody></table>\n')

            # Alvos Surpreendentes table
            alvos = low_neg_high_votes.sort_values('votos_recebidos', ascending=False).head(5)
            if len(alvos) > 0:
                print("\n### âš ï¸ Alvos Surpreendentes\n")
                print('<p style="font-size: 1.05rem;">Participantes com poucas reaÃ§Ãµes negativas mas muitos votos â€” foram votados por estratÃ©gia, nÃ£o por antipatia.</p>\n')
                print('<table style="font-size: 1.05rem; width: 100%;">')
                print('<thead><tr><th>Participante</th><th style="text-align:center;">Negativas</th><th style="text-align:center;">Votos</th></tr></thead>')
                print('<tbody>')
                for _, row in alvos.iterrows():
                    print(f'<tr><td><strong>{row["nome"]}</strong></td>'
                          f'<td style="text-align:center;">{int(row["neg_recebidas"])}</td>'
                          f'<td style="text-align:center;">{int(row["votos_recebidos"])}</td></tr>')
                print('</tbody></table>\n')

            print("### Exemplos deste paredÃ£o\n")

            # Example that aligns
            if most_hated is not None and most_voted_name:
                most_voted_data = df_scatter[df_scatter['nome'] == most_voted_name].iloc[0] if most_voted_name in df_scatter['nome'].values else None
                if most_hated['nome'] == most_voted_name:
                    print(f'<p style="font-size: 1.05rem;">âœ… <strong>Alinhado:</strong> <strong>{most_hated["nome"]}</strong> foi quem recebeu mais reaÃ§Ãµes negativas '
                          f'({int(most_hated["neg_recebidas"])}) e tambÃ©m mais votos '
                          f'({int(most_hated["votos_recebidos"])}). Os votos seguiram o queridÃ´metro.</p>\n')
                elif most_voted_data is not None:
                    print(f'<p style="font-size: 1.05rem;">âš ï¸ <strong>Desalinhado:</strong> O mais votado foi <strong>{most_voted_name}</strong> '
                          f'({int(most_voted_data["votos_recebidos"])} votos, {int(most_voted_data["neg_recebidas"])} negativas), '
                          f'mas quem recebeu mais negatividade era <strong>{most_hated["nome"]}</strong> '
                          f'({int(most_hated["neg_recebidas"])} negativas, {int(most_hated["votos_recebidos"])} votos).</p>\n')

            # Show who couldn't be voted (for context)
            if nao_votaveis:
                nao_votaveis_list = [n for n in nao_votaveis if n]
                if nao_votaveis_list:
                    nao_votaveis_str = ", ".join([f'<strong>{n}</strong>' for n in nao_votaveis_list])
                    print(f'<p style="font-size: 0.95rem; color: #888;"><em>Nota: {nao_votaveis_str} nÃ£o podia(m) receber votos neste paredÃ£o (lÃ­der, imunizado ou anjo autoimune).</em></p>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 6. VOTARAM NO QUE MAIS DETESTAM?
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        print(f"## Votaram no participante que mais detestam?\n")

        votos = paredao['votos_casa']
        voted_worst = 0
        voter_analysis = []

        for votante, alvo in votos.items():
            worst_target = None
            worst_score = float('inf')
            for other_name in neg_count_by_name:
                if other_name == votante:
                    continue
                rxn = matrix_p.get((votante, other_name), '')
                weight = SENTIMENT_WEIGHTS.get(rxn, 0)
                if weight < worst_score:
                    worst_score = weight
                    worst_target = other_name

            match = alvo == worst_target
            if match:
                voted_worst += 1
            rxn_to_target = matrix_p.get((votante, alvo), '')
            emoji_to_target = REACTION_EMOJI.get(rxn_to_target, '?')
            voter_analysis.append({
                'votante': votante, 'alvo': alvo, 'emoji': emoji_to_target,
                'pior_avaliado': worst_target, 'votou_no_pior': match
            })

        pct_worst = voted_worst / len(votos) * 100
        print(f"Apenas **{voted_worst}/{len(votos)} ({pct_worst:.0f}%)** votaram na pessoa que "
              f"avaliaram mais negativamente. Os votos sÃ£o **estratÃ©gicos**.\n")

        # Pie chart de coerÃªncia
        coerencia_data = []
        for va in voter_analysis:
            rxn = matrix_p.get((va['votante'], va['alvo']), '')
            if rxn in POSITIVE:
                tipo = 'Deu â¤ï¸ mas votou contra'
            elif rxn in MILD_NEGATIVE:
                tipo = 'Coerente (negativa leve)'
            elif rxn in STRONG_NEGATIVE:
                tipo = 'Coerente (negativa forte)'
            else:
                tipo = 'Sem reaÃ§Ã£o'
            coerencia_data.append({'Tipo': tipo})

        df_coer = pd.DataFrame(coerencia_data)
        tipo_colors = {
            'Deu â¤ï¸ mas votou contra': '#E6194B',
            'Coerente (negativa leve)': '#FF9800',
            'Coerente (negativa forte)': '#3CB44B',
            'Sem reaÃ§Ã£o': '#999'
        }
        tipo_counts = df_coer['Tipo'].value_counts()
        total_votes = len(votos)

        # Horizontal bar chart instead of pie
        fig = go.Figure()

        for tipo in tipo_counts.index:
            count = tipo_counts[tipo]
            pct = count / total_votes * 100
            fig.add_trace(go.Bar(
                y=[tipo],
                x=[count],
                orientation='h',
                marker_color=tipo_colors.get(tipo, '#999'),
                text=f"{count} ({pct:.0f}%)",
                textposition='auto',
                hovertemplate=f'{tipo}: {count} votantes ({pct:.0f}%)<extra></extra>',
                showlegend=False
            ))

        fig.update_layout(
            title=f"CoerÃªncia: ReaÃ§Ã£o vs Voto â€” {par_num}Âº ParedÃ£o<br><sup>Total: {total_votes} votos</sup>",
            height=250,
            xaxis_title="NÃºmero de votantes",
            yaxis_title="",
            margin=dict(l=200),
            barmode='stack'
        )
        fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 7. O CASO DO MAIS VOTADO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        votos = paredao['votos_casa']
        vote_counts = Counter(votos.values())
        mais_votado = vote_counts.most_common(1)[0]
        mv_name, mv_votes = mais_votado
        mv_sentiment = sent_by_name.get(mv_name, 0)
        mv_neg = neg_count_by_name.get(mv_name, 0)

        votantes_dele = [v for v, a in votos.items() if a == mv_name]
        hearts_from_voters = sum(1 for v in votantes_dele if matrix_p.get((v, mv_name), '') in POSITIVE)

        print(f"## O caso {mv_name}\n")
        print(f"**{mv_name}** foi o mais votado pela casa com **{mv_votes} votos**.\n")
        print(f"- Sentimento recebido: **{mv_sentiment:+.1f}** (reaÃ§Ãµes negativas: {mv_neg})")
        print(f"- Dos {mv_votes} que votaram nele, **{hearts_from_voters}** tinham lhe dado â¤ï¸ publicamente")

        if hearts_from_voters > mv_votes / 2:
            print(f"- **{hearts_from_voters}/{mv_votes} = {hearts_from_voters/mv_votes*100:.0f}%** dos votos "
                  "foram \"duas caras\" â€” afeto pÃºblico, voto privado contra")
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 8. INDICAÃ‡ÃƒO DO LÃDER
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('lider') and paredao.get('indicado_lider'):
        lider = paredao['lider']
        indicado = paredao['indicado_lider']
        rxn_lider = matrix_p.get((lider, indicado), '')
        emoji_lider = REACTION_EMOJI.get(rxn_lider, '?')
        weight_lider = SENTIMENT_WEIGHTS.get(rxn_lider, 0)

        worst_for_leader = None
        worst_w = float('inf')
        for other in neg_count_by_name:
            if other == lider:
                continue
            w = SENTIMENT_WEIGHTS.get(matrix_p.get((lider, other), ''), 0)
            if w < worst_w:
                worst_w = w
                worst_for_leader = other

        print(f"## IndicaÃ§Ã£o do LÃ­der\n")
        print(f"**{lider}** (LÃ­der) indicou **{indicado}** ao paredÃ£o.\n")
        print(f"- ReaÃ§Ã£o do lÃ­der ao indicado: {emoji_lider} ({rxn_lider}, peso {weight_lider:+.1f})")

        if worst_for_leader == indicado:
            print(f"- **Coerente:** {indicado} era quem {lider} avaliou mais negativamente")
        else:
            emoji_worst = REACTION_EMOJI.get(matrix_p.get((lider, worst_for_leader), ''), '?')
            print(f"- Pior avaliado por {lider}: {worst_for_leader} ({emoji_worst})")
            if weight_lider < 0:
                print(f"- Parcialmente coerente: deu reaÃ§Ã£o negativa, mas nÃ£o era o pior")
            else:
                print(f"- **Incoerente:** deu {emoji_lider} ao indicado â€” decisÃ£o estratÃ©gica")
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 9. RANKING DE SENTIMENTO NO DIA DO PAREDÃƒO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"## Ranking de Sentimento â€” {snap_p['label']}\n")

    sentiment_data = []
    for p in snap_participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        score = calc_sentiment(p)
        hearts = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                     if r['label'] == 'CoraÃ§Ã£o')
        neg = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                  if r['label'] != 'CoraÃ§Ã£o')
        member_of = p.get('characteristics', {}).get('memberOf', '?')
        sentiment_data.append({
            'name': name, 'score': score, 'hearts': hearts,
            'negative': neg, 'memberOf': member_of
        })

    df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

    color_map = {name: GROUP_COLORS.get(m, '#999')
                 for name, m in zip(df_sent['name'], df_sent['memberOf'])}

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_sent['name'],
        x=df_sent['score'],
        orientation='h',
        marker_color=[color_map[n] for n in df_sent['name']],
        text=[f"{s:+.1f}" for s in df_sent['score']],
        textposition='outside',
        hovertemplate='%{y}: %{x:+.1f}<br>â¤ï¸: %{customdata[0]} | Neg: %{customdata[1]}<extra></extra>',
        customdata=list(zip(df_sent['hearts'], df_sent['negative'])),
    ))

    fig.update_layout(
        title=f"Ranking de Sentimento â€” {par_num}Âº ParedÃ£o",
        xaxis_title="Score de Sentimento",
        yaxis_title="",
                height=max(500, len(df_sent) * 28),
        margin=dict(l=150),
        shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                     line=dict(color='red', dash='dash', width=1))]
    )

    for group, color in GROUP_COLORS.items():
        fig.add_trace(go.Scatter(
            x=[None], y=[None], mode='markers',
            marker=dict(size=10, color=color),
            name=group, showlegend=True
        ))

    fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 10. REAÃ‡Ã•ES RECEBIDAS (TABELA)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"\n## ReaÃ§Ãµes Recebidas â€” {par_num}Âº ParedÃ£o\n")

    summary_rows = []
    emoji_cols = ['â¤ï¸', 'ğŸŒ±', 'ğŸ’¼', 'ğŸª', 'ğŸ', 'ğŸ¯', 'ğŸ¤®', 'ğŸ¤¥', 'ğŸ’”']

    for p in sorted(snap_participants, key=lambda x: calc_sentiment(x), reverse=True):
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        rxn_counts = {}
        for rxn in p.get('characteristics', {}).get('receivedReactions', []):
            emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
            rxn_counts[emoji] = rxn['amount']
        score = calc_sentiment(p)

        row = {'Participante': name}
        for e in emoji_cols:
            row[e] = rxn_counts.get(e, 0)
        row['Score'] = f"{score:+.1f}"
        summary_rows.append(row)

    df_summary = pd.DataFrame(summary_rows)
    print(df_summary.to_markdown(index=False))

    print("\n---\n")
```

<div class="alert alert-info" role="alert">
<strong>Voltar:</strong> <a href="index.html">Painel Principal</a>
</div>
