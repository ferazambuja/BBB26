---
title: "BBB 26 â€” HistÃ³rico de ParedÃµes"
subtitle: "Resultado, votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia e reaÃ§Ãµes de cada eliminaÃ§Ã£o"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime
from IPython.display import display, HTML

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    load_snapshot, get_all_snapshots, build_reaction_matrix,
    load_votalhada_polls, get_poll_for_paredao, calculate_poll_accuracy,
    require_clean_manual_events, calc_sentiment, setup_bbb_dark_theme,
    REACTION_EMOJI, SENTIMENT_WEIGHTS,
    POSITIVE, MILD_NEGATIVE, STRONG_NEGATIVE, GROUP_COLORS,
)

require_clean_manual_events()
setup_bbb_dark_theme()

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")

MEMBER_OF = {}
```

```{python}
#| label: load-data
#| include: false

def get_snapshot_for_date(target_date, snapshots_list, matrices_list):
    closest_idx = 0
    for i, snap in enumerate(snapshots_list):
        if snap['date'] <= target_date:
            closest_idx = i
    return snapshots_list[closest_idx], matrices_list[closest_idx], closest_idx

all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

AVATARS = {}
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

# Build daily snapshots (one per date, last capture of the day)
daily_snapshots = []
daily_matrices = []
seen_dates = set()
for snap, mat in zip(reversed(snapshots), reversed(all_matrices)):
    if snap['date'] not in seen_dates:
        seen_dates.add(snap['date'])
        daily_snapshots.append(snap)
        daily_matrices.append(mat)
daily_snapshots.reverse()
daily_matrices.reverse()
n_daily = len(daily_snapshots)

def avatar_html(name, size=24):
    url = AVATARS.get(name, '')
    if url:
        return f'<img src="{url}" width="{size}" height="{size}" style="border-radius:50%; vertical-align:middle; margin-right:6px;" alt="{name}">{name}'
    return name

def classify_relationship(votante, alvo, matrix):
    """Classifica o relacionamento entre votante e alvo no queridÃ´metro."""
    rxn_v = matrix.get((votante, alvo), '')
    rxn_a = matrix.get((alvo, votante), '')
    v_pos = rxn_v in POSITIVE
    a_pos = rxn_a in POSITIVE
    v_neg = rxn_v in (MILD_NEGATIVE | STRONG_NEGATIVE)
    a_neg = rxn_a in (MILD_NEGATIVE | STRONG_NEGATIVE)
    v_strong = rxn_v in STRONG_NEGATIVE

    if v_pos and a_pos:
        return 'aliados_mutuos', 'ğŸ’” TraiÃ§Ã£o de Aliado', '#9b59b6'
    if v_pos and not a_pos:
        return 'falso_amigo', 'ğŸ­ Falso Amigo', '#E6194B'
    if v_neg and a_neg:
        return 'inimigos_declarados', 'âš”ï¸ Hostilidade MÃºtua', '#3CB44B'
    if v_neg and a_pos:
        return 'ponto_cego', 'ğŸ¯ Ponto Cego do Alvo', '#f39c12'
    if v_strong:
        return 'hostilidade_forte', 'ğŸ Hostilidade Forte', '#3CB44B'
    if v_neg:
        return 'hostilidade_leve', 'ğŸŒ± Hostilidade Leve', '#FF9800'
    return 'neutro', 'â“ Neutro', '#999'

def analyze_relationship_history(votante, alvo, daily_mats, daily_snaps, analysis_date):
    """Analisa a evoluÃ§Ã£o do relacionamento entre votante e alvo ao longo do tempo."""
    history = []
    days_positive = 0
    days_negative = 0
    days_mutual_positive = 0
    change_date = None
    prev_was_positive = None

    for i, mat in enumerate(daily_mats):
        snap_date = daily_snaps[i]['date']
        if snap_date > analysis_date:
            break
        rxn_v = mat.get((votante, alvo), '')
        if not rxn_v:
            continue
        rxn_a = mat.get((alvo, votante), '')
        v_pos = rxn_v in POSITIVE
        v_neg = rxn_v in (MILD_NEGATIVE | STRONG_NEGATIVE)
        history.append((snap_date, rxn_v, rxn_a))
        if v_pos:
            days_positive += 1
            if prev_was_positive == False:
                change_date = snap_date
        elif v_neg:
            days_negative += 1
            if prev_was_positive == True:
                change_date = snap_date
        if v_pos and rxn_a in POSITIVE:
            days_mutual_positive += 1
        prev_was_positive = v_pos

    total_days = len(history)
    if total_days == 0:
        return {'pattern': 'sem_dados', 'days_as_friends': 0, 'days_as_enemies': 0,
                'days_mutual_friends': 0, 'change_date': None, 'narrative': 'Sem dados', 'total_days': 0}

    current_positive = history[-1][1] in POSITIVE
    if days_positive == total_days:
        pattern, narrative = 'sempre_amigos', f"Sempre deu â¤ï¸ ({days_positive} dias)."
    elif days_negative == total_days:
        pattern, narrative = 'sempre_inimigos', f"Inimigos desde o inÃ­cio ({days_negative} dias)."
    elif days_positive > 0 and not current_positive and change_date:
        days_since = sum(1 for d, _, _ in history if d >= change_date)
        if days_since <= 2:
            pattern, narrative = 'recem_inimigos', f"Eram amigos por {days_positive} dias, mudou hÃ¡ {days_since} dia(s)!"
        else:
            pattern, narrative = 'ex_amigos', f"Foram amigos por {days_positive} dias, romperam em {change_date}."
    elif days_negative > 0 and current_positive and change_date:
        pattern, narrative = 'reconciliados', f"Reconciliaram em {change_date}."
    else:
        pattern, narrative = 'instavel', f"InstÃ¡vel: {days_positive}d â¤ï¸, {days_negative}d negativo."

    return {'pattern': pattern, 'days_as_friends': days_positive, 'days_as_enemies': days_negative,
            'days_mutual_friends': days_mutual_positive, 'change_date': change_date,
            'narrative': narrative, 'total_days': total_days}

def genero(nome):
    nome_lower = nome.lower().split()[0]
    female_names = {'maxiane', 'marciele', 'milena', 'gabriela', 'jordana', 'samira',
                   'chaiany', 'solange', 'sarah', 'sol', 'aline'}
    if nome_lower in female_names:
        return 'f'
    if nome_lower.endswith('a') and not nome_lower.endswith('ba'):
        return 'f'
    return 'm'
```

```{python}
#| label: paredao-data
#| include: false

PAREDOES_FILE = Path("data/paredoes.json")

def load_paredoes():
    if not PAREDOES_FILE.exists():
        return []
    with open(PAREDOES_FILE, encoding="utf-8") as f:
        data = json.load(f)

    paredoes = []
    for p in data.get('paredoes', []):
        entry = {
            'numero': p['numero'],
            'status': p['status'],
            'data': p['data'],
            'data_formacao': p.get('data_formacao'),
            'titulo': p['titulo'],
            'lider': p.get('formacao', {}).get('lider'),
            'indicado_lider': p.get('formacao', {}).get('indicado_lider'),
            'motivo_lider': p.get('formacao', {}).get('motivo_lider'),
            'formacao': p.get('formacao', {}).get('resumo', ''),
            'dinamica': p.get('formacao', {}).get('dinamica'),
            'big_fone': p.get('formacao', {}).get('big_fone'),
            'contragolpe': p.get('formacao', {}).get('contragolpe'),
            'votos_casa': p.get('votos_casa', {}),
            'fontes': p.get('fontes', []),
        }

        im = p.get('formacao', {}).get('imunizado')
        if im:
            entry['imunizado'] = im

        if p['status'] == 'finalizado' and p.get('resultado'):
            entry['participantes'] = []
            for ind in p.get('indicados_finais', []):
                part = {
                    'nome': ind['nome'],
                    'grupo': ind.get('grupo', MEMBER_OF.get(ind['nome'], '?')),
                    'como': ind.get('como', ''),
                }
                votos = p['resultado'].get('votos', {}).get(ind['nome'], {})
                if votos:
                    part['voto_unico'] = votos.get('voto_unico', 0)
                    part['voto_torcida'] = votos.get('voto_torcida', 0)
                    part['voto_total'] = votos.get('voto_total', 0)
                    part['resultado'] = 'ELIMINADA' if ind['nome'] == p['resultado'].get('eliminado') else 'Salva'
                entry['participantes'].append(part)
        else:
            entry['participantes'] = [
                {'nome': ind['nome'], 'grupo': ind.get('grupo', '?'), 'como': ind.get('como', '')}
                for ind in p.get('indicados_finais', [])
            ]
            entry['total_esperado'] = 3

        paredoes.append(entry)

    return paredoes

paredoes = load_paredoes()
polls_data = load_votalhada_polls()

missing_formacao = [p for p in paredoes if p.get('status') == 'finalizado' and not p.get('data_formacao')]
if missing_formacao:
    print("::: {.callout-warning title=\"âš ï¸ data_formacao ausente\" appearance=\"minimal\"}")
    print("HÃ¡ paredÃµes finalizados sem `data_formacao`. A anÃ¡lise de coerÃªncia social pode ficar menos precisa.")
    print("Preencha `data_formacao` em `data/paredoes.json`.")
    print(":::\n")
```

## Resumo das EliminaÃ§Ãµes

```{python}
#| label: paredao-summary
#| output: asis

paredoes_finalizados = [p for p in paredoes if p.get('status') == 'finalizado']

if len(paredoes_finalizados) >= 1:
    hist_rows = []
    for p in paredoes_finalizados:
        eliminado = next((x for x in p['participantes'] if x['resultado'] == 'ELIMINADA'), None)
        salvos = [x for x in p['participantes'] if x['resultado'] != 'ELIMINADA']

        row = {
            'NÂº': f"{p['numero']}Âº",
            'Data': p['data'],
            'Eliminado(a)': eliminado['nome'] if eliminado else 'â€”',
            'Grupo': eliminado['grupo'] if eliminado else 'â€”',
            'Voto Ãšnico': f"{eliminado['voto_unico']:.1f}%" if eliminado and eliminado.get('voto_unico') else 'â€”',
            'Voto Torcida': f"{eliminado['voto_torcida']:.1f}%" if eliminado and eliminado.get('voto_torcida') else 'â€”',
            'MÃ©dia Final': f"{eliminado['voto_total']:.1f}%" if eliminado else 'â€”',
            'Salvos': ', '.join(s['nome'] for s in salvos),
        }
        hist_rows.append(row)

    df_hist = pd.DataFrame(hist_rows)
    print(df_hist.to_markdown(index=False))
```

## PrecisÃ£o das Enquetes (Votalhada)

```{python}
#| label: poll-accuracy-summary
#| output: asis

all_polls = polls_data.get('paredoes', [])
finalized_polls = [p for p in all_polls if p.get('resultado_real')]

if len(finalized_polls) >= 1:
    total_correct = sum(1 for p in finalized_polls if p['resultado_real'].get('predicao_correta'))
    total_polls = len(finalized_polls)

    # Collect data for analysis
    poll_vs_votes = []  # For comparing poll vs each vote type
    platform_errors = {'sites': [], 'youtube': [], 'twitter': [], 'instagram': []}

    for poll in finalized_polls:
        elim = poll['resultado_real'].get('eliminado')
        poll_val = poll['consolidado'].get(elim, 0)
        real_val = poll['resultado_real'].get(elim, 0)

        # Get vote breakdown from paredoes data
        par = next((p for p in paredoes_finalizados if p['numero'] == poll['numero']), None)
        if par:
            elim_data = next((x for x in par['participantes'] if x['nome'] == elim), None)
            if elim_data and 'voto_total' in elim_data:
                poll_vs_votes.append({
                    'paredao': poll['numero'],
                    'eliminado': elim,
                    'enquete': poll_val,
                    'voto_unico': elim_data['voto_unico'],
                    'voto_torcida': elim_data['voto_torcida'],
                    'voto_total': elim_data['voto_total'],
                })

        # Platform errors
        for plat in platform_errors:
            if plat in poll.get('plataformas', {}):
                plat_val = poll['plataformas'][plat].get(elim, 0)
                platform_errors[plat].append({
                    'paredao': poll['numero'],
                    'erro': abs(plat_val - real_val),
                    'valor': plat_val,
                    'real': real_val,
                })

    # Calculate averages
    avg_errors = {
        'enquete_vs_total': np.mean([abs(r['enquete'] - r['voto_total']) for r in poll_vs_votes]) if poll_vs_votes else 0,
        'enquete_vs_unico': np.mean([abs(r['enquete'] - r['voto_unico']) for r in poll_vs_votes]) if poll_vs_votes else 0,
        'enquete_vs_torcida': np.mean([abs(r['enquete'] - r['voto_torcida']) for r in poll_vs_votes]) if poll_vs_votes else 0,
    }

    # Find best vote type match
    best_vote_type = min(avg_errors, key=avg_errors.get)
    best_vote_label = {'enquete_vs_total': 'MÃ©dia Final', 'enquete_vs_unico': 'Voto Ãšnico', 'enquete_vs_torcida': 'Voto Torcida'}

    # Platform averages
    platform_avg = {plat: np.mean([e['erro'] for e in errs]) for plat, errs in platform_errors.items() if errs}
    best_platform = min(platform_avg, key=platform_avg.get) if platform_avg else None

    platform_names = {'sites': 'ğŸŒ Sites', 'youtube': 'â–¶ï¸ YouTube', 'twitter': 'ğ• Twitter', 'instagram': 'ğŸ“· Instagram'}

    # Summary cards
    print(f'<div style="background:rgba(155,89,182,0.1); border-radius:12px; padding:1.5rem; margin:1rem 0;">')
    print(f'<h4 style="margin:0 0 1rem 0;">ğŸ“Š Resumo da PrecisÃ£o ({total_polls} paredÃµes)</h4>')
    print(f'<div style="display:flex; flex-wrap:wrap; gap:1.5rem;">')

    pct = 100 * total_correct / total_polls
    color = '#3CB44B' if pct >= 75 else '#f39c12' if pct >= 50 else '#E6194B'
    print(f'<div style="min-width:120px;"><strong>Taxa de acerto</strong><br><span style="font-size:2em; color:{color}; font-weight:bold;">{total_correct}/{total_polls}</span><br><span style="color:#888;">({pct:.0f}%)</span></div>')

    print(f'<div style="min-width:120px;"><strong>Erro mÃ©dio</strong><br><span style="font-size:2em; color:#f39c12; font-weight:bold;">{avg_errors["enquete_vs_total"]:.1f}</span><br><span style="color:#888;">p.p. vs MÃ©dia Final</span></div>')

    print(f'<div style="min-width:150px;"><strong>Mais prÃ³ximo de</strong><br><span style="font-size:1.3em; font-weight:bold;">{best_vote_label[best_vote_type]}</span><br><span style="color:#888;">erro: {avg_errors[best_vote_type]:.1f} p.p.</span></div>')

    if best_platform:
        print(f'<div style="min-width:150px;"><strong>Plataforma mais precisa</strong><br><span style="font-size:1.3em;">{platform_names.get(best_platform, best_platform)}</span><br><span style="color:#888;">erro: {platform_avg[best_platform]:.1f} p.p.</span></div>')

    print(f'</div></div>\n')

    # Detailed comparison table: Enquete vs Vote Types
    print("\n### ğŸ“Š Enquetes vs Tipos de Voto\n")
    print('<table class="table table-striped table-sm" style="max-width:900px;">')
    print('<thead><tr><th>ParedÃ£o</th><th>Eliminado</th><th style="text-align:center;">Enquete</th>')
    print('<th style="text-align:center;">Voto Ãšnico</th><th style="text-align:center;">Voto Torcida</th><th style="text-align:center;">MÃ©dia Final</th>')
    print('<th style="text-align:center;">Melhor Match</th></tr></thead>')
    print('<tbody>')

    for r in poll_vs_votes:
        err_unico = abs(r['enquete'] - r['voto_unico'])
        err_torcida = abs(r['enquete'] - r['voto_torcida'])
        err_total = abs(r['enquete'] - r['voto_total'])

        best = 'Ãšnico' if err_unico <= err_torcida and err_unico <= err_total else 'Torcida' if err_torcida <= err_total else 'Final'
        best_err = min(err_unico, err_torcida, err_total)

        print(f'<tr><td>{r["paredao"]}Âº</td><td>{r["eliminado"]}</td>')
        print(f'<td style="text-align:center; font-weight:bold; color:#9b59b6;">{r["enquete"]:.1f}%</td>')

        # Highlight cells based on error
        for val, err in [(r['voto_unico'], err_unico), (r['voto_torcida'], err_torcida), (r['voto_total'], err_total)]:
            cell_color = '#3CB44B' if err < 10 else '#f39c12' if err < 20 else '#E6194B'
            print(f'<td style="text-align:center;">{val:.1f}% <span style="color:{cell_color}; font-size:0.8em;">({err:+.1f})</span></td>')

        print(f'<td style="text-align:center; font-weight:bold;">ğŸ¯ {best}</td>')
        print('</tr>')

    print('</tbody></table>\n')

    # Platform accuracy table
    print("\n### ğŸ† PrecisÃ£o por Plataforma\n")
    print('<table class="table table-striped table-sm" style="max-width:700px;">')
    print('<thead><tr><th>Plataforma</th>')
    for poll in finalized_polls:
        print(f'<th style="text-align:center;">{poll["numero"]}Âº Par.</th>')
    print('<th style="text-align:center; font-weight:bold;">MÃ©dia</th><th style="text-align:center;">Rank</th></tr></thead>')
    print('<tbody>')

    platform_order = ['twitter', 'sites', 'instagram', 'youtube']
    ranked_platforms = sorted(platform_avg.items(), key=lambda x: x[1])
    rank_map = {plat: i+1 for i, (plat, _) in enumerate(ranked_platforms)}

    for plat in platform_order:
        if plat not in platform_avg:
            continue
        medal = 'ğŸ¥‡' if rank_map[plat] == 1 else 'ğŸ¥ˆ' if rank_map[plat] == 2 else 'ğŸ¥‰' if rank_map[plat] == 3 else f'{rank_map[plat]}Âº'
        row_style = 'background:rgba(60,180,75,0.15);' if rank_map[plat] == 1 else ''

        print(f'<tr style="{row_style}"><td>{platform_names.get(plat, plat)}</td>')

        for poll in finalized_polls:
            err_data = next((e for e in platform_errors[plat] if e['paredao'] == poll['numero']), None)
            if err_data:
                err_color = '#3CB44B' if err_data['erro'] < 10 else '#f39c12' if err_data['erro'] < 20 else '#E6194B'
                print(f'<td style="text-align:center;"><span style="color:{err_color};">{err_data["erro"]:.1f}</span></td>')
            else:
                print('<td style="text-align:center;">â€”</td>')

        print(f'<td style="text-align:center; font-weight:bold;">{platform_avg[plat]:.1f}</td>')
        print(f'<td style="text-align:center;">{medal}</td>')
        print('</tr>')

    # Add consolidado row
    consolidado_errs = [abs(r['enquete'] - r['voto_total']) for r in poll_vs_votes]
    print(f'<tr style="background:rgba(155,89,182,0.2);"><td><strong>ğŸ“Š Consolidado</strong></td>')
    for err in consolidado_errs:
        err_color = '#3CB44B' if err < 10 else '#f39c12' if err < 20 else '#E6194B'
        print(f'<td style="text-align:center;"><span style="color:{err_color};">{err:.1f}</span></td>')
    avg_consol = np.mean(consolidado_errs)
    print(f'<td style="text-align:center; font-weight:bold;">{avg_consol:.1f}</td>')
    print('<td style="text-align:center;">â€”</td>')
    print('</tr>')

    print('</tbody></table>')
    print('<p class="text-muted small">Erro = diferenÃ§a em pontos percentuais entre previsÃ£o e resultado real (MÃ©dia Final)</p>\n')

    # Pattern observation
    underest = np.mean([r['enquete'] - r['voto_total'] for r in poll_vs_votes])
    pattern = "subestimam" if underest < 0 else "superestimam"
    print(f'<div style="background:rgba(52,152,219,0.1); border-radius:8px; padding:1rem; margin:1rem 0;">')
    print(f'<strong>ğŸ“‰ PadrÃ£o observado:</strong> As enquetes consistentemente <strong>{pattern}</strong> o eliminado em <strong>{abs(underest):.1f} p.p.</strong> em mÃ©dia.')
    print(f'<br><span style="color:#888;">Isso ocorre porque enquetes online sobre-representam fÃ£s engajados que votam estrategicamente.</span>')
    print(f'</div>\n')
```

---

## Arquivo de ParedÃµes

```{python}
#| label: data-freshness
#| output: asis

n_snapshots = len(snapshots)
latest = snapshots[-1]
print(f'<p class="text-muted small">ğŸ“… Dados disponÃ­veis: <strong>{snapshots[0]["label"]}</strong> â†’ <strong>{latest["label"]}</strong> ({n_snapshots} coletas)</p>')

# Generate Bootstrap nav-tabs
tabs_html = '<ul class="nav nav-tabs" id="paredaoTabs" role="tablist">'
for i, paredao in enumerate(reversed(paredoes_finalizados)):
    par_num = paredao['numero']
    eliminado = next((x for x in paredao['participantes'] if x['resultado'] == 'ELIMINADA'), None)
    elim_name = eliminado['nome'].split()[0] if eliminado else '?'
    active = 'active' if i == 0 else ''
    selected = 'true' if i == 0 else 'false'
    tabs_html += f'''
    <li class="nav-item" role="presentation">
        <button class="nav-link {active}" id="tab-{par_num}" data-bs-toggle="tab" data-bs-target="#paredao-{par_num}"
                type="button" role="tab" aria-controls="paredao-{par_num}" aria-selected="{selected}">
            {par_num}Âº ParedÃ£o ({elim_name})
        </button>
    </li>'''
tabs_html += '</ul>'
print(tabs_html)
```

```{python}
#| label: paredao-tabs-content
#| output: asis

# Generate tab content for each finalized paredÃ£o
print('<div class="tab-content" id="paredaoTabsContent">')

for i, paredao in enumerate(reversed(paredoes_finalizados)):  # Most recent first
    par_num = paredao['numero']
    par_date = paredao['data']

    analysis_date = paredao.get('data_formacao') or par_date
    snap_p, matrix_p, idx_p = get_snapshot_for_date(analysis_date, snapshots, all_matrices)
    snap_participants = snap_p['participants']

    eliminado = next((x for x in paredao['participantes'] if x['resultado'] == 'ELIMINADA'), None)
    salvos = [x for x in paredao['participantes'] if x['resultado'] != 'ELIMINADA']

    # Tab pane wrapper
    active = 'show active' if i == 0 else ''
    print(f'<div class="tab-pane fade {active}" id="paredao-{par_num}" role="tabpanel" aria-labelledby="tab-{par_num}">')
    print(f'<h3 style="margin-top:1.5rem;">{par_num}Âº ParedÃ£o â€” {paredao["data"]}</h3>')
    print(f'<p class="text-muted small">ğŸ“… CoerÃªncia social usa queridÃ´metro do dia <strong>{analysis_date}</strong> (formaÃ§Ã£o).</p>')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # HEADER WITH RESULT CARDS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print('<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; margin: 1rem 0 1.5rem 0;">')
    for part in paredao['participantes']:
        nome = part['nome']
        grupo = part.get('grupo', MEMBER_OF.get(nome, '?'))
        resultado = part.get('resultado', '')
        voto_total = part.get('voto_total', 0)
        avatar_url = AVATARS.get(nome, '')
        cor_grupo = GROUP_COLORS.get(grupo, '#666')

        if resultado == 'ELIMINADA':
            border_color = '#E6194B'
            badge_bg = '#E6194B'
            badge_text = 'ELIMINADO(A)'
            img_filter = 'grayscale(100%)'
        else:
            border_color = '#3CB44B'
            badge_bg = '#3CB44B'
            badge_text = 'SALVO(A)'
            img_filter = 'none'

        print(f'<div style="background: linear-gradient(145deg, #3a3a3a, #2a2a2a); border-radius: 12px; padding: 1rem; text-align: center; width: 130px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); border: 2px solid {border_color};">')
        if avatar_url:
            print(f'<img src="{avatar_url}" alt="{nome}" style="width: 70px; height: 70px; border-radius: 50%; object-fit: cover; border: 2px solid {border_color}; margin-bottom: 0.5rem; filter: {img_filter};">')
        print(f'<div style="color: #fff; font-size: 0.9em; font-weight:bold;">{nome.split()[0]}</div>')
        print(f'<span style="display: inline-block; padding: 0.15rem 0.4rem; background: {badge_bg}; color: #fff; border-radius: 8px; font-size: 0.65em; margin: 0.3rem 0;">{badge_text}</span>')
        print(f'<div style="color: #fff; font-size: 1.2em; font-weight: bold;">{voto_total:.1f}%</div>')
        print('</div>')
    print('</div>')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # RESULT CHART
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    df_p = pd.DataFrame(paredao['participantes'])
    has_breakdown = 'voto_unico' in df_p.columns and df_p['voto_unico'].notna().all()

    fig = go.Figure()

    if has_breakdown:
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_unico'],
            text=[f"{v:.1f}%" for v in df_p['voto_unico']],
            textposition='outside', name='Voto Ãšnico (70%)',
            marker_color='#1976D2',
        ))
        fig.add_trace(go.Bar(
            x=df_p['nome'], y=df_p['voto_torcida'],
            text=[f"{v:.1f}%" for v in df_p['voto_torcida']],
            textposition='outside', name='Voto Torcida (30%)',
            marker_color='#FF9800',
        ))

    colors_total = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]
    fig.add_trace(go.Bar(
        x=df_p['nome'], y=df_p['voto_total'],
        text=[f"{v:.1f}%" for v in df_p['voto_total']],
        textposition='outside', name='MÃ©dia Final',
        marker_color=colors_total,
    ))

    fig.update_layout(
        title=dict(text=f"Resultado: {par_num}Âº ParedÃ£o", y=0.95, x=0.5, xanchor='center'),
        xaxis_title="", yaxis_title="Votos (%)",
        yaxis_range=[0, max(df_p['voto_total'].max(), df_p.get('voto_torcida', pd.Series([0])).max()) * 1.25],
        barmode='group',
        height=400,
        margin=dict(t=80),
        legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
    )
    fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # COERÃŠNCIA SOCIAL (votos + indicaÃ§Ãµes vs queridÃ´metro da formaÃ§Ã£o)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    votos = paredao.get('votos_casa', {})
    def alignment_from_reaction(label):
        if label in (MILD_NEGATIVE | STRONG_NEGATIVE):
            return "alinhado"
        if label in POSITIVE:
            return "contraditorio"
        return "neutro"

    vote_align = Counter()
    for votante, alvo in votos.items():
        label = matrix_p.get((votante, alvo), '')
        vote_align[alignment_from_reaction(label)] += 1

    indicacoes = []
    if paredao.get('lider') and paredao.get('indicado_lider'):
        indicacoes.append(('LÃ­der', paredao.get('lider'), paredao.get('indicado_lider')))
    if paredao.get('big_fone'):
        bf = paredao.get('big_fone')
        if bf.get('atendeu') and bf.get('indicou'):
            indicacoes.append(('Big Fone', bf.get('atendeu'), bf.get('indicou')))
    if paredao.get('contragolpe'):
        cg = paredao.get('contragolpe')
        if cg.get('de') and cg.get('para'):
            indicacoes.append(('Contragolpe', cg.get('de'), cg.get('para')))
    if paredao.get('dinamica'):
        din = paredao.get('dinamica')
        indicados = din.get('indicaram') or []
        alvo = din.get('indicado')
        for ator in indicados:
            indicacoes.append((din.get('nome', 'DinÃ¢mica'), ator, alvo))

    ind_align = Counter()
    for origem, ator, alvo in indicacoes:
        label = matrix_p.get((ator, alvo), '')
        ind_align[alignment_from_reaction(label)] += 1

    total_votes = max(1, len(votos))
    aligned_pct = vote_align["alinhado"] / total_votes * 100
    contrad_pct = vote_align["contraditorio"] / total_votes * 100

    print("<h4 style='margin-top:1.2rem;'>ğŸ§­ CoerÃªncia social</h4>")
    print(f"<p style='font-size:0.98rem;'>Votos: <strong>{aligned_pct:.0f}% alinhados</strong> vs <strong>{contrad_pct:.0f}% contraditÃ³rios</strong> com o queridÃ´metro da formaÃ§Ã£o.</p>")
    if indicacoes:
        total_ind = len(indicacoes)
        print(f"<p style='font-size:0.95rem;'>IndicaÃ§Ãµes pÃºblicas coerentes: {ind_align['alinhado']}/{total_ind}.</p>")

    # Badge vs realidade (contradiÃ§Ãµes)
        if paredao.get('votos_casa'):
            votos = paredao['votos_casa']
        # compute false friends + votes per participant
        active_names = [p['name'] for p in snap_participants if not p.get('characteristics', {}).get('eliminated')]
        false_friends = {}
        for name in active_names:
            ff = 0
            for other in active_names:
                if other == name:
                    continue
                my = matrix_p.get((name, other), '')
                their = matrix_p.get((other, name), '')
                if my in POSITIVE and their and their not in POSITIVE:
                    ff += 1
            false_friends[name] = ff

        # indicacoes publicas / elegibilidade
        ineligible = set()
        indicacoes = Counter()
        if paredao.get('indicado_lider'):
            ineligible.add(paredao.get('indicado_lider'))
            indicacoes[paredao.get('indicado_lider')] += 1
        if paredao.get('big_fone'):
            bf = paredao.get('big_fone')
            if bf.get('indicou'):
                ineligible.add(bf.get('indicou'))
                indicacoes[bf.get('indicou')] += 1
        if paredao.get('contragolpe'):
            cg = paredao.get('contragolpe')
            if cg.get('para'):
                ineligible.add(cg.get('para'))
                indicacoes[cg.get('para')] += 1
        if paredao.get('dinamica'):
            din = paredao.get('dinamica')
            alvo = din.get('indicado')
            if alvo:
                ineligible.add(alvo)
                indicacoes[alvo] += 1
        if paredao.get('imunizado'):
            im = paredao.get('imunizado')
            if im.get('quem'):
                ineligible.add(im.get('quem'))

        vuln_no_votes = []
        prot_with_votes = []
        for name in active_names:
            votes_count = sum(1 for v, a in votos.items() if a == name)
            ff = false_friends.get(name, 0)
            if ff >= 5:
                vuln = 'ğŸ”´ MUITO VULNERÃVEL'
            elif ff >= 3:
                vuln = 'ğŸŸ  VULNERÃVEL'
            elif ff >= 1:
                vuln = 'ğŸŸ¡ ATENÃ‡ÃƒO'
            else:
                vuln = 'ğŸŸ¢ PROTEGIDO'

            eligible = name not in ineligible
            if votes_count == 0 and indicacoes.get(name, 0) == 0 and eligible and vuln in ['ğŸŸ  VULNERÃVEL', 'ğŸ”´ MUITO VULNERÃVEL']:
                vuln_no_votes.append((name, vuln, votes_count))
            if votes_count >= 3 and eligible and vuln in ['ğŸŸ¢ PROTEGIDO', 'ğŸŸ¡ ATENÃ‡ÃƒO']:
                prot_with_votes.append((name, vuln, votes_count))

        if vuln_no_votes or prot_with_votes:
            print("<div style='margin-top:0.6rem;'>")
            print("<p style='font-size:0.95rem;'><strong>ContradiÃ§Ãµes (badge vs realidade)</strong></p>")
            if vuln_no_votes:
                print("<p class='text-muted'>VulnerÃ¡veis sem votos (surpresa nÃ£o se confirmou):</p>")
                print('<ul>')
                for name, vuln, votes_count in vuln_no_votes:
                    print(f"<li>{name} â€” {vuln} (0 votos)</li>")
                print('</ul>')
            if prot_with_votes:
                print("<p class='text-muted'>Protegidos/atenÃ§Ã£o com muitos votos (voto coletivo/bloco):</p>")
                print('<ul>')
                for name, vuln, votes_count in prot_with_votes:
                    print(f"<li>{name} â€” {vuln} ({votes_count} votos)</li>")
                print('</ul>')
            print("</div>")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ENQUETES VS RESULTADO (compact)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    poll = get_poll_for_paredao(polls_data, par_num)

    if poll and poll.get('resultado_real'):
        participantes_poll = poll.get('participantes', [])
        consolidado = poll.get('consolidado', {})
        plataformas = poll.get('plataformas', {})
        resultado = poll['resultado_real']
        accuracy = calculate_poll_accuracy(poll)

        print("\n### Enquetes vs Resultado\n")

        if accuracy and accuracy['predicao_correta']:
            status_html = '<span style="background:#3CB44B; color:#fff; padding:0.2rem 0.6rem; border-radius:10px; font-size:0.85em;">âœ… PrevisÃ£o correta</span>'
        else:
            status_html = '<span style="background:#E6194B; color:#fff; padding:0.2rem 0.6rem; border-radius:10px; font-size:0.85em;">âŒ PrevisÃ£o errada</span>'

        print(f'{status_html} <span style="color:#888; font-size:0.9em;">Erro mÃ©dio: {accuracy["erro_medio"]:.1f} p.p.</span>\n')

        # Compact platform table
        print('<table class="table table-sm" style="max-width: 100%; font-size: 0.85rem;">')
        print('<thead><tr><th>Fonte</th>')
        for nome in participantes_poll:
            print(f'<th style="text-align:center;">{nome.split()[0]}</th>')
        print('</tr></thead><tbody>')

        platform_order = ['sites', 'youtube', 'twitter', 'instagram']
        plat_names = {'sites': 'Sites', 'youtube': 'YouTube', 'twitter': 'Twitter', 'instagram': 'Instagram'}

        for plat in platform_order:
            if plat in plataformas:
                pdata = plataformas[plat]
                print(f'<tr><td>{plat_names.get(plat, plat)}</td>')
                for nome in participantes_poll:
                    val = pdata.get(nome, 0)
                    is_max = val == max(pdata.get(n, 0) for n in participantes_poll)
                    style = 'font-weight:bold; color:#f39c12;' if is_max else ''
                    print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
                print('</tr>')

        print(f'<tr style="background:rgba(155,89,182,0.2);"><td><strong>Consolidado</strong></td>')
        for nome in participantes_poll:
            print(f'<td style="text-align:center; font-weight:bold;">{consolidado.get(nome, 0):.1f}%</td>')
        print('</tr>')

        print(f'<tr style="background:rgba(52,152,219,0.2);"><td><strong>Resultado</strong></td>')
        for nome in participantes_poll:
            val = resultado.get(nome, 0)
            is_elim = nome == resultado.get('eliminado')
            style = 'font-weight:bold; color:#E6194B;' if is_elim else 'font-weight:bold; color:#3CB44B;'
            print(f'<td style="text-align:center; {style}">{val:.1f}%</td>')
        print('</tr>')
        print('</tbody></table>\n')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FORMAÃ‡ÃƒO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f"### Como foi formado\n")
    print(f"{paredao['formacao']}\n")

    if paredao.get('imunizado'):
        im = paredao['imunizado']
        print(f"**ImunizaÃ§Ã£o:** {im['por']} imunizou {im['quem']}\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # VOTAÃ‡ÃƒO DA CASA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        votos = paredao['votos_casa']
        contagem = Counter(votos.values())
        ranking = contagem.most_common()

        print(f"### VotaÃ§Ã£o da Casa\n")
        print(f"**Mais votado:** {ranking[0][0]} ({ranking[0][1]} votos)\n")

        for alvo, n in ranking[:5]:  # Top 5 only
            votantes = sorted([v for v, a in votos.items() if a == alvo])
            print(f"- **{alvo}** ({n}): {', '.join(votantes[:4])}" + (f" +{len(votantes)-4}" if len(votantes) > 4 else ""))
        print("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # VOTO VS REAÃ‡ÃƒO (compact summary)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if paredao.get('votos_casa'):
        votos = paredao['votos_casa']
        n_incoerente = 0
        n_coerente = 0

        for votante, alvo in votos.items():
            reacao_ao_alvo = matrix_p.get((votante, alvo), '')
            if reacao_ao_alvo in POSITIVE:
                n_incoerente += 1
            elif reacao_ao_alvo in MILD_NEGATIVE or reacao_ao_alvo in STRONG_NEGATIVE:
                n_coerente += 1

        total = len(votos)
        print(f"### CoerÃªncia Voto vs ReaÃ§Ã£o\n")
        print(f"**{n_coerente}/{total}** votos coerentes (votou em quem deu reaÃ§Ã£o negativa)")
        print(f"<br>**{n_incoerente}/{total}** incoerentes (deu â¤ï¸ mas votou contra)\n")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # RANKING DE SENTIMENTO (compact)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    sentiment_data = []
    for p in snap_participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        score = calc_sentiment(p)
        member_of = p.get('characteristics', {}).get('memberOf', '?')
        sentiment_data.append({'name': name, 'score': score, 'memberOf': member_of})

    df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

    print(f"\n### Ranking de Sentimento ({snap_p['label']})\n")

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_sent['name'],
        x=df_sent['score'],
        orientation='h',
        marker_color=[GROUP_COLORS.get(m, '#999') for m in df_sent['memberOf']],
        text=[f"{s:+.1f}" for s in df_sent['score']],
        textposition='outside',
    ))

    fig.update_layout(
        xaxis_title="Score",
        yaxis_title="",
        height=max(400, len(df_sent) * 22),
        margin=dict(l=120, t=30),
        shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                     line=dict(color='red', dash='dash', width=1))]
    )

    fig.show()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ANÃLISE ESTRATÃ‰GICA DE VOTOS â€” Categorias de Relacionamento
    # (transferred from paredao.qmd)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    votos = paredao.get('votos_casa', {})
    if votos and matrix_p:
        analysis_date = paredao.get('data_formacao') or par_date

        # Classify each vote
        vote_analysis = []
        relationship_counts = Counter()
        betrayals = []
        blind_spots = []

        REACTION_EMOJI_LOCAL = dict(REACTION_EMOJI)

        for votante, alvo in votos.items():
            rel_type, rel_label, rel_color = classify_relationship(votante, alvo, matrix_p)
            rxn_to = matrix_p.get((votante, alvo), '')
            rxn_from = matrix_p.get((alvo, votante), '')
            hist = analyze_relationship_history(votante, alvo, daily_matrices, daily_snapshots, analysis_date)

            entry = {
                'votante': votante, 'alvo': alvo,
                'tipo': rel_type, 'label': rel_label, 'cor': rel_color,
                'emoji_dado': REACTION_EMOJI_LOCAL.get(rxn_to, '?'),
                'emoji_recebido': REACTION_EMOJI_LOCAL.get(rxn_from, '?'),
                'hist_pattern': hist['pattern'],
                'hist_narrative': hist['narrative'],
                'days_as_friends': hist['days_as_friends'],
                'days_as_enemies': hist['days_as_enemies'],
                'days_mutual_friends': hist['days_mutual_friends'],
                'total_days': hist['total_days'],
            }
            vote_analysis.append(entry)
            relationship_counts[rel_type] += 1
            if rel_type in ('falso_amigo', 'aliados_mutuos'):
                betrayals.append(entry)
            elif rel_type == 'ponto_cego':
                blind_spots.append(entry)

        total_votes = len(votos)
        n_traicoes = len(betrayals)
        n_pontos_cegos = len(blind_spots)
        vote_counts = Counter(votos.values())
        mais_votado, n_votos_mais = vote_counts.most_common(1)[0]

        # â”€â”€ Narrative â”€â”€
        print(f"### ğŸ“– A HistÃ³ria do {par_num}Âº ParedÃ£o\n")
        n_esperados = sum(relationship_counts.get(t, 0) for t in ('inimigos_declarados', 'hostilidade_forte', 'hostilidade_leve'))
        if n_traicoes >= 3:
            print(f"Este paredÃ£o foi marcado por **traiÃ§Ãµes**. Nada menos que **{n_traicoes} votos** "
                  f"vieram de pessoas que davam â¤ï¸ ao alvo no queridÃ´metro.\n")
        elif n_pontos_cegos >= 3:
            print(f"Este paredÃ£o revelou **pontos cegos** perigosos. **{n_pontos_cegos} participantes** "
                  f"foram votados por pessoas que consideravam amigas.\n")
        elif n_esperados >= total_votes * 0.5:
            print(f"Este paredÃ£o seguiu a lÃ³gica das **hostilidades mÃºtuas**. "
                  f"A maioria dos votos ({n_esperados}/{total_votes}) veio de quem jÃ¡ dava reaÃ§Ãµes negativas ao alvo.\n")
        else:
            print(f"Este paredÃ£o foi **estratÃ©gico**. Os votos nÃ£o seguiram simplesmente as emoÃ§Ãµes do queridÃ´metro.\n")

        # â”€â”€ Anatomia dos Votos chart â”€â”€
        print("#### Anatomia dos Votos\n")
        rel_order = ['inimigos_declarados', 'hostilidade_forte', 'hostilidade_leve', 'ponto_cego', 'falso_amigo', 'aliados_mutuos', 'neutro']
        rel_labels = {
            'inimigos_declarados': 'âš”ï¸ Hostilidade MÃºtua', 'hostilidade_forte': 'ğŸ Hostilidade Forte',
            'hostilidade_leve': 'ğŸŒ± Hostilidade Leve', 'ponto_cego': 'ğŸ¯ Ponto Cego',
            'falso_amigo': 'ğŸ­ Falso Amigo', 'aliados_mutuos': 'ğŸ’” TraiÃ§Ã£o de Aliado', 'neutro': 'â“ Neutro'
        }
        rel_colors = {
            'inimigos_declarados': '#3CB44B', 'hostilidade_forte': '#3CB44B', 'hostilidade_leve': '#FF9800',
            'ponto_cego': '#f39c12', 'falso_amigo': '#E6194B', 'aliados_mutuos': '#9b59b6', 'neutro': '#999'
        }

        fig_rel = go.Figure()
        for rel in rel_order:
            count = relationship_counts.get(rel, 0)
            if count > 0:
                pct = count / total_votes * 100
                fig_rel.add_trace(go.Bar(
                    y=[rel_labels.get(rel, rel)], x=[count], orientation='h',
                    marker_color=rel_colors.get(rel, '#999'),
                    text=f"{count} ({pct:.0f}%)", textposition='auto', showlegend=False,
                ))
        fig_rel.update_layout(
            title=f"DistribuiÃ§Ã£o dos Votos por Tipo de Relacionamento<br><sup>Total: {total_votes} votos</sup>",
            height=300, xaxis_title="Votos", margin=dict(l=200, r=30, t=80, b=40),
        )
        fig_rel.show()

        coerentes = sum(relationship_counts.get(t, 0) for t in ('inimigos_declarados', 'hostilidade_forte', 'hostilidade_leve'))
        incoerentes = relationship_counts.get('falso_amigo', 0) + relationship_counts.get('aliados_mutuos', 0)
        print(f"\nâœ… **{coerentes} votos coerentes** â€” votaram em quem davam negativa")
        print(f"<br>âŒ **{incoerentes} votos incoerentes** â€” votaram em quem davam â¤ï¸")
        print(f"<br>ğŸ¯ **{n_pontos_cegos} pontos cegos** â€” alvos confiavam no votante\n")

        # â”€â”€ Betrayals table â”€â”€
        if betrayals:
            print("#### ğŸ­ As TraiÃ§Ãµes\n")
            print(f"**{n_traicoes} voto(s)** de pessoas que davam â¤ï¸ ao alvo.\n")
            print('<table class="table table-striped" style="font-size: 0.95rem;">')
            print('<thead><tr><th>Votante</th><th>Alvo</th><th style="text-align:center;">Deu</th><th>MÃºtuo?</th></tr></thead><tbody>')
            for b in betrayals:
                reciproca = f"Sim, {b['emoji_recebido']}" if b['tipo'] == 'aliados_mutuos' else "NÃ£o"
                print(f'<tr><td>{avatar_html(b["votante"], 28)}</td><td>{avatar_html(b["alvo"], 28)}</td>'
                      f'<td style="text-align:center; font-size:1.1em;">{b["emoji_dado"]}</td><td>{reciproca}</td></tr>')
            print('</tbody></table>\n')

        # â”€â”€ Blind spots table â”€â”€
        if blind_spots:
            print("#### ğŸ¯ Os Pontos Cegos\n")
            print(f"**{n_pontos_cegos} voto(s)** de inimigos disfarÃ§ados â€” a vÃ­tima dava â¤ï¸ sem saber que era odiada.\n")
            print('<table class="table table-striped" style="font-size: 0.95rem;">')
            print('<thead><tr><th>VÃ­tima</th><th>Votante</th><th style="text-align:center;">VÃ­tima dava</th><th style="text-align:center;">Votante dava</th></tr></thead><tbody>')
            for bs in blind_spots:
                print(f'<tr><td>{avatar_html(bs["alvo"], 28)}</td><td>{avatar_html(bs["votante"], 28)}</td>'
                      f'<td style="text-align:center; font-size:1.1em;">{bs["emoji_recebido"]}</td>'
                      f'<td style="text-align:center; font-size:1.1em;">{bs["emoji_dado"]}</td></tr>')
            print('</tbody></table>\n')

        # â”€â”€ Temporal evolution â”€â”€
        ex_amigos_v = [v for v in vote_analysis if v['hist_pattern'] == 'ex_amigos']
        recem_inimigos_v = [v for v in vote_analysis if v['hist_pattern'] == 'recem_inimigos']
        sempre_amigos_v = [v for v in vote_analysis if v['hist_pattern'] == 'sempre_amigos']
        sempre_inimigos_v = [v for v in vote_analysis if v['hist_pattern'] == 'sempre_inimigos']

        has_temporal = len(ex_amigos_v) > 0 or len(recem_inimigos_v) > 0 or len(sempre_amigos_v) > 0
        if has_temporal and n_daily >= 3:
            print("#### â³ EvoluÃ§Ã£o dos Relacionamentos\n")

            if recem_inimigos_v:
                print(f"**ğŸš¨ MudanÃ§a de Ãºltima hora** â€” {len(recem_inimigos_v)} voto(s) de quem mudou nos Ãºltimos 2 dias:\n")
                for v in recem_inimigos_v:
                    print(f"- {avatar_html(v['votante'], 22)} â†’ {avatar_html(v['alvo'], 22)}: {v['hist_narrative']}")
                print()

            if ex_amigos_v:
                print(f"**ğŸ’” Ex-amigos** â€” {len(ex_amigos_v)} voto(s) de quem jÃ¡ deu â¤ï¸:\n")
                for v in ex_amigos_v:
                    print(f"- {avatar_html(v['votante'], 22)} â†’ {avatar_html(v['alvo'], 22)}: {v['hist_narrative']}")
                print()

            always_friends_voted = [v for v in sempre_amigos_v if v['tipo'] in ('falso_amigo', 'aliados_mutuos')]
            if always_friends_voted:
                print(f"**ğŸ—¡ï¸ TraiÃ§Ã£o de longa data** â€” {len(always_friends_voted)} voto(s) contra quem sempre recebeu â¤ï¸:\n")
                for v in always_friends_voted:
                    print(f"- {avatar_html(v['votante'], 22)} â†’ {avatar_html(v['alvo'], 22)}: {v['days_as_friends']} dias de â¤ï¸")
                print()

            # Temporal summary table
            pattern_counts = Counter([v['hist_pattern'] for v in vote_analysis])
            pattern_labels = {
                'sempre_amigos': ('ğŸ’š Sempre amigos', 'Sempre deu â¤ï¸ â€” voto inesperado'),
                'sempre_inimigos': ('ğŸ’€ Sempre inimigos', 'Nunca deu â¤ï¸ â€” voto esperado'),
                'ex_amigos': ('ğŸ’” Ex-amigos', 'Davam â¤ï¸, hoje nÃ£o mais'),
                'recem_inimigos': ('âš¡ MudanÃ§a recente', 'Mudou nos Ãºltimos 2 dias'),
                'instavel': ('ğŸ­ InstÃ¡veis', 'RelaÃ§Ã£o oscilou muito'),
            }
            print("| PadrÃ£o | Votos | Significado |")
            print("|--------|-------|-------------|")
            for pat, (lab, desc) in pattern_labels.items():
                if pattern_counts.get(pat, 0):
                    print(f"| {lab} | {pattern_counts[pat]} | {desc} |")
            print()

        # â”€â”€ O Caso [mais votado] â”€â”€
        sent_by_name = {}
        neg_count_by_name = {}
        for p in snap_participants:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            sent_by_name[p['name']] = calc_sentiment(p)
            neg_count_by_name[p['name']] = sum(
                r['amount'] for r in p.get('characteristics', {}).get('receivedReactions', [])
                if r['label'] != 'CoraÃ§Ã£o'
            )

        mv_detalhes = [v for v in vote_analysis if v['alvo'] == mais_votado]
        mv_from_enemies = len([v for v in mv_detalhes if v['tipo'] in ('inimigos_declarados', 'hostilidade_forte', 'hostilidade_leve')])
        mv_from_traitors = len([v for v in mv_detalhes if v['tipo'] in ('falso_amigo', 'aliados_mutuos')])
        mv_from_blind = len([v for v in mv_detalhes if v['tipo'] == 'ponto_cego'])

        gen_mv = genero(mais_votado)
        votado_a = "votada" if gen_mv == 'f' else "votado"

        print(f"#### ğŸ“Š O Caso {mais_votado}\n")
        print(f"**{mais_votado}** foi {'a' if gen_mv == 'f' else 'o'} mais {votado_a} com **{n_votos_mais} votos**.\n")
        print(f"| MÃ©trica | Valor |")
        print(f"|---------|-------|")
        print(f"| Sentimento total recebido | {sent_by_name.get(mais_votado, 0):+.1f} |")
        print(f"| ReaÃ§Ãµes negativas recebidas | {neg_count_by_name.get(mais_votado, 0)} |")
        print(f"| Votos de quem dava negativo | {mv_from_enemies} |")
        print(f"| Votos de \"amigos\" (traiÃ§Ã£o) | {mv_from_traitors} |")
        print(f"| Pontos cegos | {mv_from_blind} |\n")

        if mv_from_traitors > n_votos_mais / 2:
            apunhalado = "apunhalada" if gen_mv == 'f' else "apunhalado"
            print(f"> ğŸ’” **{mais_votado} foi {apunhalado} pelas costas.** "
                  f"Mais da metade dos votos ({mv_from_traitors}/{n_votos_mais}) veio de quem dava â¤ï¸.\n")
        elif mv_from_enemies == n_votos_mais:
            print(f"> âš”ï¸ **{mais_votado} era um alvo Ã³bvio.** "
                  f"Todos os {n_votos_mais} votos vieram de quem jÃ¡ dava negativa.\n")
        elif mv_from_blind >= 2:
            print(f"> ğŸ¯ **{mais_votado} nÃ£o percebia seus inimigos.** "
                  f"Dava â¤ï¸ para {mv_from_blind} pessoas que {'a' if gen_mv == 'f' else 'o'} detestavam.\n")

        # â”€â”€ Leader nomination analysis â”€â”€
        lider = paredao.get('lider')
        indicado = paredao.get('indicado_lider')
        if lider and indicado:
            rxn_lider = matrix_p.get((lider, indicado), '')
            rxn_indicado = matrix_p.get((indicado, lider), '')
            rel_type_l, rel_label_l, _ = classify_relationship(lider, indicado, matrix_p)
            emoji_lider = REACTION_EMOJI_LOCAL.get(rxn_lider, '?')
            emoji_indicado = REACTION_EMOJI_LOCAL.get(rxn_indicado, '?')

            print(f"#### ğŸ‘‘ IndicaÃ§Ã£o do LÃ­der\n")
            print(f"**{lider}** indicou **{indicado}** ao paredÃ£o.\n")

            print('<table class="table" style="max-width: 500px; font-size: 0.95rem;">')
            print('<thead><tr><th>De</th><th>Para</th><th style="text-align:center;">ReaÃ§Ã£o</th></tr></thead><tbody>')
            print(f'<tr><td>{avatar_html(lider, 28)}</td><td>{avatar_html(indicado, 28)}</td><td style="text-align:center; font-size:1.2em;">{emoji_lider}</td></tr>')
            print(f'<tr><td>{avatar_html(indicado, 28)}</td><td>{avatar_html(lider, 28)}</td><td style="text-align:center; font-size:1.2em;">{emoji_indicado}</td></tr>')
            print('</tbody></table>\n')

            if rel_type_l == 'aliados_mutuos':
                print(f"> ğŸ’” **IndicaÃ§Ã£o surpreendente!** Trocavam â¤ï¸ mÃºtuos.\n")
            elif rel_type_l == 'falso_amigo':
                print(f"> ğŸ­ **IndicaÃ§Ã£o contraditÃ³ria.** {lider} dava â¤ï¸ para {indicado}.\n")
            elif rel_type_l == 'inimigos_declarados':
                print(f"> âš”ï¸ **IndicaÃ§Ã£o coerente.** Hostilidade mÃºtua no queridÃ´metro.\n")
            elif rel_type_l == 'ponto_cego':
                print(f"> ğŸ¯ **{indicado} nÃ£o viu chegando.** Dava â¤ï¸ para {lider}.\n")

        # â”€â”€ Full vote table â”€â”€
        print("#### ğŸ“‹ Tabela Completa de Votos\n")
        pattern_emoji = {
            'sempre_amigos': 'ğŸ’š', 'sempre_inimigos': 'ğŸ’€', 'ex_amigos': 'ğŸ’”',
            'recem_inimigos': 'âš¡', 'reconciliados': 'ğŸ¤', 'instavel': 'ğŸ­', 'sem_dados': 'â“',
        }
        print('<table class="table table-striped" style="font-size: 0.9rem;">')
        print('<thead><tr><th>Votante</th><th>Votou em</th><th style="text-align:center;">Deu</th>'
              '<th style="text-align:center;">Recebeu</th><th>Tipo</th><th>HistÃ³rico</th></tr></thead><tbody>')
        for v in vote_analysis:
            hist_str = f"{pattern_emoji.get(v['hist_pattern'], '?')} {v['days_as_friends']}dâ¤ï¸"
            print(f'<tr><td>{avatar_html(v["votante"], 28)}</td><td>{avatar_html(v["alvo"], 28)}</td>'
                  f'<td style="text-align:center; font-size:1.1em;">{v["emoji_dado"]}</td>'
                  f'<td style="text-align:center; font-size:1.1em;">{v["emoji_recebido"]}</td>'
                  f'<td>{v["label"]}</td><td>{hist_str}</td></tr>')
        print('</tbody></table>')

    # Close tab-pane div
    print('</div>')  # Close tab-pane

# Close tab-content div
print('</div>')  # Close tab-content
```

<div class="alert alert-info" role="alert" style="margin-top:2rem;">
<strong>Voltar:</strong> <a href="index.html">Painel Principal</a>
</div>
