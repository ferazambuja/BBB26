---
title: "BBB 26 â€” Clusters de Afinidade"
subtitle: "Comunidades, blocos de votaÃ§Ã£o e dinÃ¢mica de grupos"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from pathlib import Path
from collections import Counter

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    require_clean_manual_events, setup_bbb_dark_theme,
)

require_clean_manual_events()
setup_bbb_dark_theme()

import networkx as nx
from scipy.spatial import ConvexHull
```

```{python}
#| label: load-data
#| include: false

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA LOADING â€” all precomputed by build_derived_data.py
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

with open("data/derived/clusters_data.json") as f:
    clusters = json.load(f)

with open("data/derived/relations_scores.json") as f:
    rel_data = json.load(f)

with open("data/derived/participants_index.json") as f:
    participants_index = json.load(f)

# --- Metadata ---
meta = clusters["_metadata"]
ref_date = meta["reference_date"]
current_week = meta["week"]
n_active = meta["n_active"]
n_clusters = meta["n_clusters"]
n_paredoes = meta["n_paredoes"]
n_contradictions = meta["n_contradictions"]
n_tensions = meta["n_tensions"]
best_cohesion = meta["best_cohesion"]
worst_rivalry = meta["worst_rivalry"]

# --- Precomputed structures ---
active_names = clusters["active_names"]
cluster_order = clusters["cluster_order"]
communities = clusters["communities"]
inter_cluster = clusters["inter_cluster"]
polarization = clusters["polarization"]
score_matrix_ordered = np.array(clusters["score_matrix_ordered"])
vote_matrix_ordered = np.array(clusters["vote_matrix_ordered"])

# --- Voting blocs + contradictions from relations_scores ---
voting_blocs = rel_data.get("voting_blocs", [])
contradictions_list = rel_data.get("contradictions", {}).get("vote_vs_queridometro", [])

# --- Participant info ---
PARTICIPANT_INFO = {}
AVATARS = {}
for p in participants_index["participants"]:
    PARTICIPANT_INFO[p["name"]] = {
        "grupo": p["grupo"],
        "avatar": p.get("avatar", ""),
        "active": p["active"],
    }
    if p.get("avatar"):
        AVATARS[p["name"]] = p["avatar"]

# --- Rebuild lookup dicts from precomputed communities ---
name_to_idx = {name: i for i, name in enumerate(active_names)}
cluster_of = {}
cluster_members = {}
cluster_names = {}
cluster_colors = {}
cluster_cohesion = {}
for comm in communities:
    label = comm["label"]
    cluster_members[label] = comm["members"]
    cluster_names[label] = comm["name"]
    cluster_colors[label] = comm["color"]
    cluster_cohesion[label] = comm["cohesion"]
    for m in comm["members"]:
        cluster_of[m] = label

# --- Rebuild directed score matrix (for network graph + polarizer cards) ---
pairs_daily = rel_data["pairs_daily"]
score_mat = np.zeros((n_active, n_active))
for src, targets in pairs_daily.items():
    if src not in name_to_idx:
        continue
    i = name_to_idx[src]
    for tgt, entry in targets.items():
        if tgt not in name_to_idx:
            continue
        j = name_to_idx[tgt]
        score_mat[i, j] = entry["score"]

sym_mat = (score_mat + score_mat.T) / 2
```

```{python}
#| label: destaques
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DESTAQUES - Key highlights callout
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

highlights = []
highlights.append(f"Louvain detectou **{n_clusters} comunidades** entre {n_active} participantes ativos")
highlights.append(f"Comunidade mais coesa: **{best_cohesion['name']}** (sentimento mÃ©dio {best_cohesion['score']:+.2f})")
if worst_rivalry:
    highlights.append(f"Maior rivalidade entre clusters: **{worst_rivalry['text']} ({worst_rivalry['score']:+.2f})**")
if n_contradictions > 0:
    highlights.append(f"**{n_contradictions}** contradiÃ§Ãµes voto vs. queridÃ´metro detectadas")

print(f'''
<div style="background: #2a2a2a; border-left: 4px solid #2ecc71; border-radius: 8px; padding: 0.8rem 1rem; margin: 1rem 0;">
<div style="font-weight: 700; margin-bottom: 0.5rem;">Destaques â€” Semana {current_week}</div>
<ul style="margin: 0; padding-left: 1.2rem;">
''')
for h in highlights:
    print(f"<li>{h}</li>")
print("</ul></div>")
```

```{python}
#| label: kpi-boxes
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KPI VALUE BOXES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

overall_cohesion = np.mean([c["cohesion"] for c in communities])
silhouette_val = meta.get("silhouette_coefficient")
silhouette_display = f"{silhouette_val:.2f}" if silhouette_val else "â€”"
resolution_val = meta.get("resolution_used", 1.0)

# Silhouette quality interpretation
if silhouette_val is not None:
    if silhouette_val > 0.5:
        sil_quality = "Excelente"
        sil_color_start, sil_color_end = "#27ae60", "#1e8449"
    elif silhouette_val > 0.3:
        sil_quality = "Boa"
        sil_color_start, sil_color_end = "#2ecc71", "#27ae60"
    elif silhouette_val > 0.1:
        sil_quality = "Moderada"
        sil_color_start, sil_color_end = "#f39c12", "#d68910"
    else:
        sil_quality = "Fraca"
        sil_color_start, sil_color_end = "#e74c3c", "#c0392b"
else:
    sil_quality = "N/D"
    sil_color_start, sil_color_end = "#7f8c8d", "#5d6d7e"

print(f'''
<div style="display: flex; flex-wrap: wrap; gap: 0.8rem; margin: 1.5rem 0;">

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_clusters}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">Comunidades</div>
</div>

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{overall_cohesion:+.2f}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">CoesÃ£o MÃ©dia</div>
</div>

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, {sil_color_start} 0%, {sil_color_end} 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{silhouette_display}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">Silhouette ({sil_quality})</div>
</div>

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_tensions}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">TensÃµes</div>
</div>

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #f39c12 0%, #d68910 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_contradictions}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">ContradiÃ§Ãµes</div>
</div>

</div>

<p class="text-muted small" style="margin-top: 0.3rem;">Baseado em scores compostos (queridÃ´metro + votos + eventos de poder + SincerÃ£o + VIP). ReferÃªncia: {ref_date}. ResoluÃ§Ã£o Louvain: {resolution_val}.</p>
''')
```

# Comunidades por Sentimento

Comunidades detectadas pelo algoritmo Louvain sobre o grafo de afinidades compostas. Participantes no mesmo grupo tendem a ter sentimento mÃºtuo positivo.

```{python}
#| label: network-graph

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NETWORK GRAPH â€” nodes colored by cluster, edges by score sign
# Layout is a visualization concern, computed here with networkx spring_layout
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

G_viz = nx.Graph()
for name in active_names:
    grupo = PARTICIPANT_INFO[name]["grupo"]
    cl = cluster_of[name]
    G_viz.add_node(name, group=grupo, cluster=cl)

# Add edges where |sym_score| > 0.5
for i, a in enumerate(active_names):
    for j, b in enumerate(active_names):
        if i >= j:
            continue
        w = sym_mat[i, j]
        if abs(w) > 0.5:
            G_viz.add_edge(a, b, weight=w)

pos = nx.spring_layout(G_viz, k=2.5, iterations=80, seed=42)

# Edge traces: positive (green) and negative (red)
edge_traces = []
for edge_type, color, dash, legend_name in [
    ('positive', '#2ca02c', 'solid', 'Afinidade (score > 0.5)'),
    ('negative', '#d62728', 'dash', 'TensÃ£o (score < -0.5)')
]:
    edge_x, edge_y = [], []
    for u, v, data in G_viz.edges(data=True):
        w = data['weight']
        if edge_type == 'positive' and w <= 0:
            continue
        if edge_type == 'negative' and w >= 0:
            continue
        x0, y0 = pos[u]
        x1, y1 = pos[v]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])

    if edge_x:
        edge_traces.append(go.Scatter(
            x=edge_x, y=edge_y,
            line=dict(width=1.5, color=color, dash=dash),
            hoverinfo='none',
            mode='lines',
            name=legend_name,
            showlegend=True
        ))

# Convex hull shading per cluster
hull_traces = []

for label, members in cluster_members.items():
    if len(members) < 3:
        continue
    pts = np.array([pos[m] for m in members])
    try:
        hull = ConvexHull(pts)
        hull_pts = pts[hull.vertices]
        hull_pts = np.vstack([hull_pts, hull_pts[0]])
        centroid = pts.mean(axis=0)
        expanded = centroid + 1.15 * (hull_pts - centroid)
        color_hex = cluster_colors[label].lstrip('#')
        r, g, b = int(color_hex[:2], 16), int(color_hex[2:4], 16), int(color_hex[4:], 16)
        hull_traces.append(go.Scatter(
            x=expanded[:, 0], y=expanded[:, 1],
            fill='toself',
            fillcolor=f'rgba({r},{g},{b},0.08)',
            line=dict(color=f'rgba({r},{g},{b},0.3)', width=1, dash='dot'),
            mode='lines',
            name=cluster_names[label],
            showlegend=True,
            hoverinfo='skip'
        ))
    except Exception:
        pass

# Use precomputed pos_received from polarization data
pol_lookup = {p["name"]: p for p in polarization}

# Node trace
node_x = [pos[n][0] for n in active_names if n in pos]
node_y = [pos[n][1] for n in active_names if n in pos]
nodes_in_graph = [n for n in active_names if n in pos]

node_colors_list = [cluster_colors[cluster_of[n]] for n in nodes_in_graph]
node_sizes = [max(12, min(40, 15 + pol_lookup.get(n, {}).get("pos_received", 0) * 3)) for n in nodes_in_graph]

node_trace = go.Scatter(
    x=node_x, y=node_y,
    mode='markers+text',
    text=[n.split()[0] for n in nodes_in_graph],
    textposition='top center',
    textfont=dict(size=9),
    marker=dict(size=node_sizes, color=node_colors_list, line=dict(width=1.5, color='white')),
    hovertemplate='%{hovertext}<extra></extra>',
    hovertext=[
        f"<b>{n}</b><br>"
        f"Grupo: {PARTICIPANT_INFO[n]['grupo']}<br>"
        f"Cluster: {cluster_names[cluster_of[n]]}<br>"
        f"Sentimento recebido: {pol_lookup.get(n, {}).get('pos_received', 0):+.1f}"
        for n in nodes_in_graph
    ],
    showlegend=False
)

fig = go.Figure(data=hull_traces + edge_traces + [node_trace])

fig.update_layout(
    title=f"Grafo de Comunidades â€” {ref_date}",
    height=700,
    showlegend=True,
    legend=dict(x=0, y=-0.1, orientation='h'),
    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    annotations=[
        dict(text="Tamanho do nÃ³ = sentimento positivo recebido | Cor = comunidade | Arestas: verde = afinidade, vermelho = tensÃ£o",
             xref="paper", yref="paper", x=0.5, y=-0.08, showarrow=False, font=dict(size=10))
    ]
)

fig.show()
```

## Perfil das Comunidades

```{python}
#| label: community-cards
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMMUNITY PROFILE CARDS â€” all data from precomputed communities
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

for comm in communities:
    label = comm["label"]
    name = comm["name"]
    color = comm["color"]
    members = comm["members"]
    cohesion = comm["cohesion"]
    best_ext = comm["best_external"]
    worst_ext = comm["worst_external"]
    comp = comm["group_composition"]

    comp_str = ", ".join(f"{cnt} {g}" for g, cnt in comp.items())

    # Member avatars
    members_html = ""
    for m in members:
        avatar_url = AVATARS.get(m, "")
        short = m.split()[0]
        if avatar_url:
            members_html += f'<img src="{avatar_url}" title="{m}" style="width:36px;height:36px;border-radius:50%;margin:2px;border:2px solid {color};" />'
        else:
            members_html += f'<div style="display:inline-block;width:36px;height:36px;border-radius:50%;background:#444;text-align:center;line-height:36px;margin:2px;border:2px solid {color};font-size:12px;">{short[0]}</div>'

    ext_alliance = f"{best_ext['name']} ({best_ext['score']:+.2f})" if best_ext else "â€”"
    ext_rivalry = f"{worst_ext['name']} ({worst_ext['score']:+.2f})" if worst_ext else "â€”"

    card_html = f'<div style="background:#2a2a2a;border-left:4px solid {color};border-radius:8px;padding:1rem;margin:1rem 0;">'
    card_html += f'<div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;margin-bottom:0.5rem;">'
    card_html += f'<div style="display:inline;font-size:1.2rem;font-weight:700;color:{color};">{name}</div>'
    card_html += f' <div style="display:inline;font-size:0.85rem;color:#aaa;margin-left:0.5rem;">{len(members)} membros Â· {comp_str}</div>'
    card_html += f' <div style="display:inline;background:#333;padding:2px 8px;border-radius:12px;font-size:0.75rem;margin-left:auto;">CoesÃ£o: {cohesion:+.2f}</div>'
    card_html += '</div>'
    card_html += f'<div style="margin:0.6rem 0;">{members_html}</div>'
    card_html += f'<div style="font-size:0.85rem;color:#ccc;">ğŸ¤ AlianÃ§a externa: <b>{ext_alliance}</b> &nbsp;Â·&nbsp; âš”ï¸ Rivalidade externa: <b>{ext_rivalry}</b></div>'
    card_html += '</div>'
    print(card_html)
```

# Mapa de Afinidade

Heatmap de sentimento composto (queridÃ´metro + eventos + votos) entre todos os participantes, ordenado por comunidade. Linhas brancas separam as comunidades.

```{python}
#| label: affinity-heatmap

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HEATMAP â€” precomputed cluster-ordered score matrix
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

short_names = [n.split()[0] if len(n.split()[0]) <= 10 else n.split()[0][:8] + '.' for n in cluster_order]

# Cluster boundary lines
shapes = []
cumsum = 0
for comm in communities:
    size = len(comm["members"])
    cumsum += size
    if cumsum < n_active:
        shapes.append(dict(type='line', x0=-0.5, x1=n_active-0.5, y0=cumsum-0.5, y1=cumsum-0.5,
                           line=dict(color='white', width=2)))
        shapes.append(dict(type='line', x0=cumsum-0.5, x1=cumsum-0.5, y0=-0.5, y1=n_active-0.5,
                           line=dict(color='white', width=2)))

vmax = max(3, float(np.max(np.abs(score_matrix_ordered))))

fig = go.Figure(go.Heatmap(
    z=score_matrix_ordered.tolist(),
    x=short_names,
    y=short_names,
    colorscale=[
        [0, '#8b0000'],
        [0.25, '#d62728'],
        [0.45, '#7f7f7f'],
        [0.55, '#7f7f7f'],
        [0.75, '#2ca02c'],
        [1, '#006400']
    ],
    zmid=0,
    zmin=-vmax, zmax=vmax,
    hovertemplate='%{y} â†” %{x}<br>Score composto: %{z:+.2f}<extra></extra>',
    colorbar=dict(title="Score", tickformat="+.1f")
))

# Cluster label annotations at midpoints
cumsum = 0
annotations = []
for comm in communities:
    size = len(comm["members"])
    mid = cumsum + size / 2 - 0.5
    cumsum += size
    annotations.append(dict(
        x=n_active + 0.3, y=mid,
        text=comm["name"],
        showarrow=False,
        font=dict(size=9, color=comm["color"]),
        xref='x', yref='y',
        xanchor='left'
    ))

fig.update_layout(
    title="Mapa de Afinidade Composta (ordenado por comunidade)",
    height=750,
    xaxis=dict(tickangle=45, side='bottom'),
    yaxis=dict(autorange='reversed'),
    shapes=shapes,
    annotations=annotations,
    margin=dict(r=140),
)

fig.show()
```

# Blocos de VotaÃ§Ã£o

::: {.callout-note}
Blocos de votaÃ§Ã£o se tornam mais confiÃ¡veis com mais paredÃµes. Os padrÃµes abaixo sÃ£o indicativos, nÃ£o definitivos.
:::

```{python}
#| label: vote-caveat
#| output: asis
print(f'''
<div style="background: #2a2a2a; border-left: 4px solid #3498db; border-radius: 8px; padding: 0.6rem 1rem; margin: 0.5rem 0; font-size: 0.9rem;">
â„¹ï¸ Dados baseados em <b>{n_paredoes} paredÃµes</b> finalizados. Os blocos abaixo mostram quem votou no mesmo alvo em cada semana.
</div>
''')
```

## Matriz de Alinhamento de Votos

```{python}
#| label: vote-alignment-heatmap

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VOTE ALIGNMENT MATRIX â€” precomputed cluster-ordered vote matrix
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

vote_display = vote_matrix_ordered.copy()
np.fill_diagonal(vote_display, np.nan)

fig = go.Figure(go.Heatmap(
    z=vote_display.tolist(),
    x=short_names,
    y=short_names,
    colorscale=[[0, '#1a1a2e'], [0.5, '#16537e'], [1, '#2ecc71']],
    zmin=0, zmax=1,
    hovertemplate='%{y} & %{x}<br>Alinhamento: %{z:.0%}<extra></extra>',
    colorbar=dict(title="Alinhamento", tickformat=".0%")
))

fig.update_layout(
    title="Alinhamento de Votos (fraÃ§Ã£o de paredÃµes com mesmo alvo)",
    height=700,
    xaxis=dict(tickangle=45, side='bottom'),
    yaxis=dict(autorange='reversed'),
    shapes=shapes,
)

fig.show()
```

## Blocos de VotaÃ§Ã£o por Semana

```{python}
#| label: voting-blocs
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VOTING BLOCS from precomputed data (relations_scores.json)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if not voting_blocs:
    print('<p class="text-muted">Nenhum bloco de votaÃ§Ã£o registrado.</p>')
else:
    # Count multi-bloc voters
    voter_bloc_count = Counter()
    for bloc in voting_blocs:
        for v in bloc.get("voters", []):
            voter_bloc_count[v] += 1
    multi_bloc = {v for v, c in voter_bloc_count.items() if c > 1}

    for bloc in sorted(voting_blocs, key=lambda b: (b.get("week", 0), -b.get("count", 0))):
        week = bloc.get("week", "?")
        target = bloc.get("target", "?")
        voters = bloc.get("voters", [])
        count = bloc.get("count", len(voters))

        voter_tags = []
        for v in voters:
            short = v.split()[0]
            if v in multi_bloc:
                voter_tags.append(f'<b style="background:#f39c12;color:#000;padding:1px 6px;border-radius:10px;font-size:0.8rem;font-weight:600;">{short}</b>')
            else:
                voter_tags.append(f'<b style="background:#444;padding:1px 6px;border-radius:10px;font-size:0.8rem;font-weight:normal;">{short}</b>')

        bloc_html = f'<div style="background:#2a2a2a;border-left:4px solid #e74c3c;border-radius:8px;padding:0.8rem 1rem;margin:0.5rem 0;">'
        bloc_html += f'<div style="font-weight:600;">Semana {week} â€” Alvo: <b style="color:#e74c3c;">{target}</b> <b style="color:#888;">({count} votos)</b></div>'
        bloc_html += f'<div style="margin-top:0.4rem;display:flex;flex-wrap:wrap;gap:4px;">{" ".join(voter_tags)}</div>'
        bloc_html += '</div>'
        print(bloc_html)

    if multi_bloc:
        multi_names = ", ".join(f"**{v.split()[0]}**" for v in sorted(multi_bloc))
        print(f'\n<p class="text-muted small" style="margin-top: 0.5rem;">Votantes em mÃºltiplos blocos (destaque amarelo): {multi_names}</p>')
```

## ContradiÃ§Ãµes Voto vs. QueridÃ´metro

Participantes que deram reaÃ§Ã£o positiva no queridÃ´metro mas votaram contra o mesmo alvo â€” ou vice-versa. Essas contradiÃ§Ãµes revelam estratÃ©gia ou mudanÃ§a de opiniÃ£o.

```{python}
#| label: contradictions-table
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONTRADICTIONS TABLE (from relations_scores.json)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if not contradictions_list:
    print('<p class="text-muted">Nenhuma contradiÃ§Ã£o voto vs. queridÃ´metro detectada.</p>')
else:
    sorted_contras = sorted(contradictions_list, key=lambda c: -(c.get("queridometro", 0) - c.get("vote_weight", 0)))

    print('''
<div style="overflow-x: auto; margin: 1rem 0;">
<table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
<thead>
<tr style="border-bottom: 2px solid #555;">
  <th style="padding: 8px; text-align: left;">Ator</th>
  <th style="padding: 8px; text-align: left;">Alvo</th>
  <th style="padding: 8px; text-align: center;">QueridÃ´metro</th>
  <th style="padding: 8px; text-align: center;">Voto</th>
  <th style="padding: 8px; text-align: center;">Tipo</th>
  <th style="padding: 8px; text-align: center;">Semana</th>
</tr>
</thead>
<tbody>
''')

    for c in sorted_contras:
        actor = c.get("actor", "?")
        target = c.get("target", "?")
        qscore = c.get("queridometro", 0)
        vote_w = c.get("vote_weight", 0)
        kind = c.get("vote_kind", "?")
        week = c.get("week", "?")

        severity = qscore - vote_w
        if severity > 2.5:
            row_color = "rgba(231,76,60,0.15)"
        elif severity > 1.5:
            row_color = "rgba(243,156,18,0.10)"
        else:
            row_color = "transparent"

        qcolor = "#2ecc71" if qscore > 0 else "#e74c3c" if qscore < 0 else "#888"
        vcolor = "#e74c3c" if vote_w < 0 else "#2ecc71" if vote_w > 0 else "#888"

        print(f'''<tr style="border-bottom: 1px solid #333; background: {row_color};">
  <td style="padding: 6px 8px;">{actor}</td>
  <td style="padding: 6px 8px;">{target}</td>
  <td style="padding: 6px 8px; text-align: center; color: {qcolor}; font-weight: 600;">{qscore:+.1f}</td>
  <td style="padding: 6px 8px; text-align: center; color: {vcolor}; font-weight: 600;">{vote_w:+.1f}</td>
  <td style="padding: 6px 8px; text-align: center;">{kind}</td>
  <td style="padding: 6px 8px; text-align: center;">{week}</td>
</tr>''')

    print('</tbody></table></div>')
```

# DinÃ¢mica Entre Comunidades

```{python}
#| label: inter-cluster-heatmap

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTER-CLUSTER HEATMAP â€” precomputed inter-cluster scores
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sorted_labels = sorted(cluster_members.keys())
n_cl = len(sorted_labels)
inter_mat = np.zeros((n_cl, n_cl))

# Build matrix from precomputed inter_cluster data
inter_directed_lookup = {}
for entry in inter_cluster:
    a, b = entry["cluster_a"], entry["cluster_b"]
    inter_directed_lookup[(a, b)] = entry["score_a_to_b"]
    inter_directed_lookup[(b, a)] = entry["score_b_to_a"]

for i, la in enumerate(sorted_labels):
    for j, lb in enumerate(sorted_labels):
        if la == lb:
            inter_mat[i, j] = cluster_cohesion[la]
        else:
            inter_mat[i, j] = inter_directed_lookup.get((la, lb), 0)

cl_names_short = [cluster_names[l] for l in sorted_labels]

fig = go.Figure(go.Heatmap(
    z=inter_mat,
    x=cl_names_short,
    y=cl_names_short,
    colorscale=[
        [0, '#8b0000'],
        [0.35, '#d62728'],
        [0.5, '#7f7f7f'],
        [0.65, '#2ca02c'],
        [1, '#006400']
    ],
    zmid=0,
    text=[[f"{inter_mat[i,j]:+.2f}" for j in range(n_cl)] for i in range(n_cl)],
    texttemplate="%{text}",
    hovertemplate='%{y} â†’ %{x}<br>Score mÃ©dio: %{z:+.2f}<extra></extra>',
    colorbar=dict(title="Score", tickformat="+.1f")
))

fig.update_layout(
    title="Sentimento MÃ©dio Entre Comunidades (diagonal = coesÃ£o interna)",
    height=400,
    xaxis=dict(side='bottom'),
    yaxis=dict(autorange='reversed'),
)

fig.show()
```

```{python}
#| label: inter-cluster-narrative
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTER-CLUSTER NARRATIVE TEXT â€” precomputed data
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("### RelaÃ§Ãµes Entre Comunidades\n")

for entry in sorted(inter_cluster, key=lambda e: e["score_sym"]):
    name_a = entry["name_a"]
    name_b = entry["name_b"]
    val = entry["score_sym"]
    fwd = entry["score_a_to_b"]
    rev = entry["score_b_to_a"]
    vote_al = entry.get("vote_alignment")

    if val > 0.5:
        classification = "ğŸ¤ AlianÃ§a"
    elif val > -0.3:
        classification = "ğŸ˜ Neutro"
    elif val > -1.0:
        classification = "âš¡ TensÃ£o"
    else:
        classification = "âš”ï¸ Rivalidade"

    vote_text = f" Â· Alinhamento de voto: {vote_al:.0%}" if vote_al is not None else ""

    asym = abs(fwd - rev)
    asym_note = ""
    if asym > 0.5:
        if fwd > rev:
            asym_note = f" (assimetria: {name_a} mais positivo que {name_b})"
        else:
            asym_note = f" (assimetria: {name_b} mais positivo que {name_a})"

    print(f"- **{name_a}** Ã— **{name_b}**: {classification} ({val:+.2f}){asym_note}{vote_text}\n")
```

# Participantes Polarizadores

Ranking por **dispersÃ£o** de sentimento recebido: participantes com alto desvio-padrÃ£o dividem opiniÃµes (sÃ£o amados por uns e rejeitados por outros).

```{python}
#| label: polarization-chart

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# POLARIZATION â€” precomputed dispersion data
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

polar_df = pd.DataFrame(polarization).sort_values('std_received', ascending=True)

fig = go.Figure(go.Bar(
    y=polar_df['name'].apply(lambda n: n.split()[0]),
    x=polar_df['std_received'],
    orientation='h',
    marker_color=[cluster_colors[cluster_of[n]] for n in polar_df['name']],
    hovertemplate='<b>%{y}</b><br>DispersÃ£o: %{x:.2f}<br>Sentimento mÃ©dio: %{customdata[0]:+.2f}<br>Cluster: %{customdata[1]}<br>ContradiÃ§Ãµes: %{customdata[2]}<extra></extra>',
    customdata=list(zip(
        polar_df['avg_received'],
        [cluster_names[cluster_of[n]] for n in polar_df['name']],
        polar_df['contradictions'],
    )),
))

fig.update_layout(
    title="DispersÃ£o de Sentimento Recebido (mais polarizador = mais alto)",
    height=600,
    xaxis_title="Desvio-padrÃ£o do score recebido",
    yaxis=dict(autorange='reversed'),
    margin=dict(l=120),
)

fig.show()
```

```{python}
#| label: polarizer-cards
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOP 3 POLARIZER MINI-CARDS â€” precomputed data
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

top3 = sorted(polarization, key=lambda d: -d['std_received'])[:3]

print('<div style="display: flex; flex-wrap: wrap; gap: 1rem; margin: 1rem 0;">')

for entry in top3:
    name = entry['name']
    avatar = AVATARS.get(name, "")
    cl = cluster_of[name]

    love_str = ", ".join(f'{e["name"].split()[0]} ({e["score"]:+.1f})' for e in entry["top_love"])
    hate_str = ", ".join(f'{e["name"].split()[0]} ({e["score"]:+.1f})' for e in entry["top_hate"])

    avatar_img_html = f'<img src="{avatar}" style="width:48px;height:48px;border-radius:50%;border:2px solid {cluster_colors[cl]};" />' if avatar else ""

    p_html = f'<div style="flex:1 1 250px;background:#2a2a2a;border-radius:8px;padding:1rem;border-top:3px solid {cluster_colors[cl]};">'
    p_html += f'<div style="display:flex;gap:0.7rem;align-items:center;margin-bottom:0.5rem;">{avatar_img_html}<div><div style="font-weight:700;">{name}</div><div style="font-size:0.8rem;color:#aaa;">{entry["grupo"]} Â· {cluster_names[cl]}</div></div></div>'
    p_html += f'<div style="font-size:0.85rem;">'
    p_html += f'<div style="color:#aaa;">DispersÃ£o: <b>{entry["std_received"]:.2f}</b> Â· MÃ©dia: <b>{entry["avg_received"]:+.2f}</b></div>'
    p_html += f'<div style="margin-top:0.3rem;">ğŸ’š Mais positivos: {love_str}</div>'
    p_html += f'<div>ğŸ”´ Mais negativos: {hate_str}</div>'
    p_html += f'<div style="color:#f39c12;margin-top:0.2rem;">âš¡ ContradiÃ§Ãµes: {entry["contradictions"]}</div>'
    p_html += '</div></div>'
    print(p_html)

print('</div>')
```

# EvoluÃ§Ã£o dos Clusters

Acompanhamento de como a estrutura de comunidades mudou ao longo das semanas.

```{python}
#| label: cluster-evolution
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLUSTER EVOLUTION â€” temporal tracking of community changes
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

evolution_path = Path("data/derived/cluster_evolution.json")
if evolution_path.exists():
    with open(evolution_path) as f:
        evolution = json.load(f)

    timeline = evolution.get("timeline", [])
    all_transitions = evolution.get("all_transitions", [])
    most_mobile = evolution.get("most_mobile", [])

    if len(timeline) >= 2:
        # â”€â”€ KPI: Evolution summary â”€â”€
        n_weeks = len(timeline)
        total_trans = evolution.get("_metadata", {}).get("total_transitions", len(all_transitions))
        avg_clusters = np.mean([e["n_clusters"] for e in timeline])
        silhouettes = [e["silhouette"] for e in timeline if e.get("silhouette") is not None]
        avg_sil = np.mean(silhouettes) if silhouettes else None

        print(f'''
<div style="background: #2a2a2a; border-left: 4px solid #9b59b6; border-radius: 8px; padding: 0.8rem 1rem; margin: 1rem 0;">
<div style="font-weight: 700; margin-bottom: 0.5rem;">Resumo da EvoluÃ§Ã£o ({n_weeks} semanas)</div>
<div style="display: flex; flex-wrap: wrap; gap: 1rem;">
<div><strong>{total_trans}</strong> transiÃ§Ãµes detectadas</div>
<div><strong>{avg_clusters:.1f}</strong> clusters em mÃ©dia</div>
{"<div><strong>" + f"{avg_sil:.2f}" + "</strong> silhouette mÃ©dio</div>" if avg_sil else ""}
</div>
</div>
''')

        # â”€â”€ Chart 1: Cluster count + silhouette over time â”€â”€
        weeks = [e["week"] for e in timeline]
        clusters_per_week = [e["n_clusters"] for e in timeline]
        silhouettes = [e.get("silhouette") for e in timeline]

        fig_evo = go.Figure()
        fig_evo.add_trace(go.Scatter(
            x=weeks, y=clusters_per_week, mode='lines+markers',
            name='NÂº Clusters', line=dict(width=3, color='#3498db'),
            marker=dict(size=10),
            yaxis='y',
        ))
        if any(s is not None for s in silhouettes):
            fig_evo.add_trace(go.Scatter(
                x=weeks, y=silhouettes, mode='lines+markers',
                name='Silhouette', line=dict(width=2, color='#2ecc71', dash='dash'),
                marker=dict(size=8, symbol='diamond'),
                yaxis='y2',
            ))

        fig_evo.update_layout(
            title="EvoluÃ§Ã£o da Estrutura de Clusters",
            xaxis_title="Semana",
            yaxis=dict(title="NÃºmero de Clusters", title_font=dict(color='#3498db'), tickfont=dict(color='#3498db')),
            yaxis2=dict(title="Silhouette", title_font=dict(color='#2ecc71'), tickfont=dict(color='#2ecc71'),
                        overlaying='y', side='right', range=[0, 1]),
            height=350,
            legend=dict(orientation='h', yanchor='bottom', y=1.05, xanchor='center', x=0.5),
        )
        fig_evo.show()

        # â”€â”€ Chart 2: Cluster sizes stacked area â”€â”€
        def hex_to_rgba(h, alpha=0.6):
            h = h.lstrip('#')
            return f'rgba({int(h[0:2],16)},{int(h[2:4],16)},{int(h[4:6],16)},{alpha})'

        # Build series for each cluster label across time
        all_labels = set()
        for e in timeline:
            for c in e.get("communities", []):
                all_labels.add(c["label"])
        all_labels = sorted(all_labels)

        fig_area = go.Figure()
        for label in all_labels:
            sizes = []
            for e in timeline:
                comm = next((c for c in e.get("communities", []) if c["label"] == label), None)
                sizes.append(comm["size"] if comm else 0)
            color = next((c["color"] for e in timeline for c in e.get("communities", []) if c["label"] == label), '#888')
            fig_area.add_trace(go.Scatter(
                x=weeks, y=sizes, mode='lines',
                name=f'Cluster {label}', stackgroup='one',
                line=dict(width=0.5, color=color),
                fillcolor=hex_to_rgba(color) if color.startswith('#') else color,
            ))

        fig_area.update_layout(
            title="Tamanho dos Clusters ao Longo do Tempo",
            xaxis_title="Semana", yaxis_title="Participantes",
            height=350, hovermode='x unified',
        )
        fig_area.show()

        # â”€â”€ Most mobile participants â”€â”€
        if most_mobile:
            print("\n### ğŸ”„ Participantes Mais MÃ³veis\n")
            print("Quem mudou de cluster com mais frequÃªncia:\n")
            print('<div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">')
            for item in most_mobile:
                name = item["name"]
                moves = item["moves"]
                avatar_url = AVATARS.get(name, "")
                if avatar_url:
                    print(f'<div style="background:#2a2a2a;padding:8px 12px;border-radius:8px;display:flex;align-items:center;gap:8px;">')
                    print(f'<img src="{avatar_url}" style="width:32px;height:32px;border-radius:50%;">')
                    print(f'<span><strong>{name.split()[0]}</strong> ({moves}Ã—)</span></div>')
                else:
                    print(f'<span style="background:#2a2a2a;padding:4px 10px;border-radius:6px;margin:2px;"><strong>{name.split()[0]}</strong> ({moves}Ã—)</span>')
            print('</div>\n')

        # â”€â”€ Transitions table â”€â”€
        if all_transitions:
            print("\n### ğŸ“‹ Registro de TransiÃ§Ãµes\n")
            print('<table class="table table-sm" style="max-width: 600px; font-size: 0.9rem;">')
            print('<thead><tr><th>Semana</th><th>Participante</th><th>De</th><th>Para</th></tr></thead>')
            print('<tbody>')
            for t in sorted(all_transitions, key=lambda x: (x.get("week", 0), x.get("name", "")))[:15]:
                print(f'<tr><td>Sem {t.get("week", "?")}</td>')
                print(f'<td>{t.get("name", "?").split()[0]}</td>')
                print(f'<td style="text-align:center;">Cl {t.get("from_cluster", "?")}</td>')
                print(f'<td style="text-align:center;">Cl {t.get("to_cluster", "?")}</td></tr>')
            print('</tbody></table>')
            if len(all_transitions) > 15:
                print(f'<p class="text-muted small">Mostrando 15 de {len(all_transitions)} transiÃ§Ãµes.</p>')
    else:
        print('<p class="text-muted">Dados de evoluÃ§Ã£o insuficientes (mÃ­nimo 2 semanas).</p>')
else:
    print('<p class="text-muted">Dados de evoluÃ§Ã£o de clusters ainda nÃ£o gerados. Execute <code>python scripts/build_derived_data.py</code>.</p>')
```

# Metodologia

::: {.callout-tip collapse="true"}
## Como funciona esta anÃ¡lise

**DetecÃ§Ã£o de comunidades:** Algoritmo de Louvain aplicado sobre o grafo de afinidades compostas. Apenas arestas positivas (sentimento mÃºtuo > 0) definem comunidades â€” a ausÃªncia de conexÃ£o positiva jÃ¡ indica separaÃ§Ã£o.

**ResoluÃ§Ã£o otimizada via Silhouette:** O algoritmo testa mÃºltiplos valores de resoluÃ§Ã£o Louvain (0.5 a 1.5) e escolhe aquele que maximiza o coeficiente de silhueta â€” uma mÃ©trica de qualidade que mede quÃ£o bem separados estÃ£o os clusters. Valores de silhouette:
- **> 0.5**: Excelente â€” clusters bem definidos
- **0.3â€“0.5**: Boa â€” estrutura razoÃ¡vel
- **0.1â€“0.3**: Moderada â€” clusters sobrepostos
- **< 0.1**: Fraca â€” estrutura pouco clara

**Score composto (A â†’ B):** CombinaÃ§Ã£o de 6 sinais:

- **QueridÃ´metro** â€” 70% janela reativa de 3 dias (0.6 / 0.3 / 0.1) + 30% memÃ³ria de sequÃªncia + penalidade de ruptura
- **Eventos de poder** â€” indicaÃ§Ã£o, contragolpe, monstro, veto, etc. (acumulam sem decay)
- **SincerÃ£o** â€” pÃ³dio e bombas
- **VIP** â€” compartilhamento de grupo
- **Votos da casa** â€” votos secretos e abertos
- **Anjo** â€” almoÃ§o do anjo, duo, autoimunidade

**Alinhamento de votos:** FraÃ§Ã£o de paredÃµes em que dois participantes votaram no mesmo alvo (0% a 100%). Com poucos paredÃµes, esse dado Ã© indicativo.

**ContradiÃ§Ãµes:** Quando um participante dÃ¡ â¤ï¸ no queridÃ´metro mas vota contra o mesmo alvo no paredÃ£o (ou vice-versa). Revela estratÃ©gia ou mudanÃ§a rÃ¡pida de opiniÃ£o.

**Auto-nomeaÃ§Ã£o:** Comunidades sÃ£o nomeadas automaticamente: >70% de um grupo â†’ "NÃºcleo {Grupo}"; coesÃ£o alta (>1.5) â†’ prefixo "AlianÃ§a"; coesÃ£o negativa â†’ prefixo "Frente".
:::
