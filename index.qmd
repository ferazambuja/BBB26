---
title: "BBB 26 â€” Painel de ReaÃ§Ãµes"
subtitle: "AnÃ¡lise das reaÃ§Ãµes entre os participantes do Big Brother Brasil 2026"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import load_snapshot, get_all_snapshots, parse_roles, build_reaction_matrix

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

REACTION_SLUG_TO_LABEL = {
    'coracao': 'CoraÃ§Ã£o', 'planta': 'Planta', 'mala': 'Mala', 'biscoito': 'Biscoito',
    'cobra': 'Cobra', 'alvo': 'Alvo', 'vomito': 'VÃ´mito', 'mentiroso': 'Mentiroso',
    'coracao-partido': 'CoraÃ§Ã£o partido'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0,
    'CoraÃ§Ã£o partido': -0.5  # Mild negative (disappointment, not hostility)
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito', 'CoraÃ§Ã£o partido'}  # ğŸ’” = disappointment, not hostility
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}  # preenchido ao carregar dados

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Plotly Dark Theme Configuration (matches Bootswatch darkly)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PLOT_BG = '#303030'  # Darkly body background
PAPER_BG = '#303030'
GRID_COLOR = '#444444'
TEXT_COLOR = '#fff'

# Standard layout applied to ALL plots
import plotly.io as pio

pio.templates['bbb_dark'] = go.layout.Template(
    layout=go.Layout(
        paper_bgcolor=PAPER_BG,
        plot_bgcolor=PLOT_BG,
        font=dict(color=TEXT_COLOR, family='Lato, -apple-system, sans-serif', size=13),
        title=dict(font=dict(size=16), x=0.5, xanchor='center', y=0.95),
        margin=dict(l=70, r=30, t=70, b=60),
        xaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        yaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        legend=dict(
            bgcolor='rgba(0,0,0,0)',
            bordercolor='rgba(0,0,0,0)',
        ),
        colorway=['#00bc8c', '#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6'],
    )
)
pio.templates.default = 'bbb_dark'
```

```{python}
#| label: load-data

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label legÃ­vel e flag de sintÃ©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

# Detectar participantes que entraram apÃ³s o primeiro snapshot
first_snap_names = set(p['name'] for p in snapshots[0]['participants'])
late_entrants = {}
_seen_names = set(first_snap_names)
for snap in snapshots[1:]:
    current_names = set(p['name'] for p in snap['participants'])
    new_names = current_names - _seen_names
    for name in new_names:
        if name not in late_entrants:
            late_entrants[name] = snap['date']
    _seen_names |= current_names

if late_entrants:
    # Group by entry date
    _by_date = {}
    for n, d in late_entrants.items():
        _by_date.setdefault(d, []).append(n)

    _parts = []
    for d, names in sorted(_by_date.items()):
        names_str = ', '.join(sorted(names))
        _parts.append(f"{names_str} (entraram em {d})")
    _late_str = '; '.join(_parts)

    late_caption = (
        f"âš ï¸ Participantes que entraram apÃ³s o inÃ­cio do confinamento ({_late_str}) "
        f"tÃªm menos dias de dados comparados aos demais participantes que estavam presentes "
        f"desde o inÃ­cio da temporada, e isso pode afetar comparaÃ§Ãµes temporais."
    )
else:
    late_caption = ""

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (Ãºltima do dia) â€” usada para anÃ¡lises de reaÃ§Ãµes
# ReaÃ§Ãµes mudam 1x/dia (no Raio-X da manhÃ£); coletas extras no mesmo dia
# tÃªm reaÃ§Ãµes idÃªnticas mas podem diferir em saldo/papÃ©is.
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)

# Derived daily metrics (optional)
daily_metrics = {}
daily_metrics_map = {}
DAILY_METRICS_FILE = Path("data/derived/daily_metrics.json")
if DAILY_METRICS_FILE.exists():
    with open(DAILY_METRICS_FILE, encoding="utf-8") as f:
        daily_metrics = json.load(f)
    daily_metrics_map = {d.get('date'): d for d in daily_metrics.get('daily', [])}
```

```{python}
#| label: viz-functions
#| include: false

def get_snapshot_for_date(target_date, snapshots_list=None, matrices_list=None):
    """Retorna (snapshot, matrix, index) do snapshot mais prÃ³ximo antes/em target_date."""
    snaps = snapshots_list or snapshots
    mats = matrices_list or all_matrices
    closest_idx = 0
    for i, snap in enumerate(snaps):
        if snap['date'] <= target_date:
            closest_idx = i
    return snaps[closest_idx], mats[closest_idx], closest_idx


def make_sentiment_ranking(participants, matrix, title_suffix="", show_avatars=False, avatars_dict=None, fixed_height=None):
    """Retorna go.Figure com ranking horizontal de sentimento.

    Args:
        fixed_height: If provided, uses this height instead of auto-calculating.
                      Useful for consistent heights across tabsets.
    """
    sentiment_data = []
    for p in participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        score = calc_sentiment(p)
        hearts = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                     if r['label'] == 'CoraÃ§Ã£o')
        neg = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                  if r['label'] != 'CoraÃ§Ã£o')
        member_of = p.get('characteristics', {}).get('memberOf', '?')
        avatar = (avatars_dict or {}).get(name, '') if show_avatars else ''
        sentiment_data.append({
            'name': name, 'score': score, 'hearts': hearts,
            'negative': neg, 'memberOf': member_of, 'avatar': avatar
        })

    df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

    color_map = {name: GROUP_COLORS.get(m, '#999')
                 for name, m in zip(df_sent['name'], df_sent['memberOf'])}

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_sent['name'],
        x=df_sent['score'],
        orientation='h',
        marker_color=[color_map[n] for n in df_sent['name']],
        text=[f"{s:+.1f}" for s in df_sent['score']],
        textposition='outside',
        hovertemplate='%{y}: %{x:+.1f}<br>â¤ï¸: %{customdata[0]} | Neg: %{customdata[1]}<extra></extra>',
        customdata=list(zip(df_sent['hearts'], df_sent['negative'])),
        showlegend=False
    ))

    title = "Ranking de Sentimento"
    if title_suffix:
        title += f" â€” {title_suffix}"

    # Calculate left margin - need more space for avatars
    left_margin = 180 if show_avatars else 150

    # Use fixed height if provided, otherwise auto-calculate
    chart_height = fixed_height if fixed_height else max(500, len(df_sent) * 32)

    fig.update_layout(
        title=title,
        xaxis_title="Score de Sentimento",
        yaxis_title="",
        height=chart_height,
        margin=dict(l=left_margin),
        shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                     line=dict(color='red', dash='dash', width=1))]
    )

    # Add avatar images as layout images (positioned in paper coordinates)
    if show_avatars and avatars_dict:
        images = []
        n_participants = len(df_sent)
        for i, (_, row) in enumerate(df_sent.iterrows()):
            avatar_url = row.get('avatar', '')
            if avatar_url:
                # Position each avatar to the left of the y-axis label
                # y position: map bar index to paper coordinates
                y_pos = i / (n_participants - 1) if n_participants > 1 else 0.5
                images.append(dict(
                    source=avatar_url,
                    xref="paper", yref="paper",
                    x=-0.01, y=y_pos,  # Just left of the chart
                    sizex=0.04, sizey=0.04,  # Size relative to plot
                    xanchor="right", yanchor="middle",
                    layer="above"
                ))
        if images:
            fig.update_layout(images=images)

    for group, color in GROUP_COLORS.items():
        fig.add_trace(go.Scatter(
            x=[None], y=[None], mode='markers',
            marker=dict(size=10, color=color),
            name=group, showlegend=True
        ))

    return fig


def make_cross_table_heatmap(participants, matrix, title_suffix=""):
    """Retorna go.Figure com heatmap da tabela cruzada de reaÃ§Ãµes."""
    active_names_ht = sorted([p['name'] for p in participants
                              if not p.get('characteristics', {}).get('eliminated')])

    heat_data = np.zeros((len(active_names_ht), len(active_names_ht)))
    rxn_labels = []
    for i, giver in enumerate(active_names_ht):
        row_labels = []
        for j, receiver in enumerate(active_names_ht):
            if giver == receiver:
                heat_data[i, j] = np.nan
                row_labels.append('â€”')
            else:
                rxn = matrix.get((giver, receiver), '')
                weight = SENTIMENT_WEIGHTS.get(rxn, 0)
                heat_data[i, j] = weight
                emoji = REACTION_EMOJI.get(rxn, '?')
                row_labels.append(emoji)
        rxn_labels.append(row_labels)

    short_names = [n.split()[0] if len(n) > 12 else n for n in active_names_ht]

    fig = go.Figure(data=go.Heatmap(
        z=heat_data,
        x=short_names,
        y=short_names,
        colorscale=[
            [0, '#d73027'],
            [0.25, '#fc8d59'],
            [0.5, '#ffffbf'],
            [1.0, '#1a9850'],
        ],
        zmin=-1, zmax=1,
        text=[[rxn_labels[i][j] for j in range(len(active_names_ht))] for i in range(len(active_names_ht))],
        texttemplate='%{text}',
        textfont=dict(size=14),
        hovertemplate='%{y} â†’ %{x}: %{text}<extra></extra>',
        colorbar=dict(title="Sentimento", tickvals=[-1, -0.5, 0, 1],
                      ticktext=['Forte Neg', 'Leve Neg', 'Neutro', 'Positivo'])
    ))

    title = "Mapa de ReaÃ§Ãµes"
    if title_suffix:
        title += f" â€” {title_suffix}"

    fig.update_layout(
        title=title,
        xaxis_title="Receptor â†",
        yaxis_title="Emissor â†’",
        height=750,
        xaxis=dict(tickangle=45, side='bottom'),
        yaxis=dict(autorange='reversed')
    )

    return fig


def make_cross_table_html(participants, matrix, title_suffix=""):
    """Retorna HTML string com tabela cruzada de reaÃ§Ãµes (sticky header/column)."""
    active_names = sorted([p['name'] for p in participants
                           if not p.get('characteristics', {}).get('eliminated')])

    short_names = [n.split()[0] if len(n) > 10 else n for n in active_names]

    # Color mapping based on sentiment
    def get_cell_style(rxn):
        if not rxn:
            return "background: #444; color: #888;"
        weight = SENTIMENT_WEIGHTS.get(rxn, 0)
        if weight == 1:  # Positive
            return "background: #1a9850; color: #fff;"
        elif weight == -0.5:  # Mild negative
            return "background: #fc8d59; color: #000;"
        elif weight == -1:  # Strong negative
            return "background: #d73027; color: #fff;"
        return "background: #ffffbf; color: #000;"

    # Build HTML table
    html = []
    html.append(f'''
<div style="overflow-x: auto; max-width: 100%;">
<style>
.cross-table {{
    border-collapse: separate;
    border-spacing: 0;
    font-size: 0.85rem;
    width: max-content;
}}
.cross-table th, .cross-table td {{
    padding: 4px 6px;
    text-align: center;
    border: 1px solid #555;
    min-width: 36px;
    white-space: nowrap;
}}
.cross-table thead th {{
    position: sticky;
    top: 0;
    background: #222;
    z-index: 2;
    font-weight: bold;
}}
.cross-table tbody th {{
    position: sticky;
    left: 0;
    background: #222;
    z-index: 1;
    font-weight: bold;
    text-align: right;
}}
.cross-table thead th:first-child {{
    z-index: 3;
    left: 0;
}}
.cross-table td {{ font-size: 1.1rem; }}
.cross-table td:hover {{ outline: 2px solid #fff; }}
</style>
<table class="cross-table">
<thead>
<tr>
<th style="background: #222;">â†“ deu / recebeu â†’</th>
''')

    # Header row with receiver names
    for short in short_names:
        html.append(f'<th>{short}</th>')
    html.append('</tr></thead><tbody>')

    # Data rows
    for i, giver in enumerate(active_names):
        html.append(f'<tr><th>{short_names[i]}</th>')
        for j, receiver in enumerate(active_names):
            if giver == receiver:
                html.append('<td style="background: #333; color: #666;">â€”</td>')
            else:
                rxn = matrix.get((giver, receiver), '')
                emoji = REACTION_EMOJI.get(rxn, '?') if rxn else '?'
                style = get_cell_style(rxn)
                tooltip = f"{giver} â†’ {receiver}: {rxn or 'N/A'}"
                html.append(f'<td style="{style}" title="{tooltip}">{emoji}</td>')
        html.append('</tr>')

    html.append('</tbody></table></div>')

    return '\n'.join(html)


def make_reaction_summary_html(participants, collapsed_rows=5):
    """Retorna HTML com tabela de reaÃ§Ãµes recebidas, colapsÃ¡vel com cores."""
    summary_rows = []
    for p in sorted(participants, key=lambda x: calc_sentiment(x), reverse=True):
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        rxn_counts = {}
        for rxn in p.get('characteristics', {}).get('receivedReactions', []):
            emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
            rxn_counts[emoji] = rxn['amount']
        score = calc_sentiment(p)
        summary_rows.append({
            'name': name,
            'hearts': rxn_counts.get('â¤ï¸', 0),
            'planta': rxn_counts.get('ğŸŒ±', 0),
            'mala': rxn_counts.get('ğŸ’¼', 0),
            'biscoito': rxn_counts.get('ğŸª', 0),
            'cobra': rxn_counts.get('ğŸ', 0),
            'alvo': rxn_counts.get('ğŸ¯', 0),
            'vomito': rxn_counts.get('ğŸ¤®', 0),
            'mentiroso': rxn_counts.get('ğŸ¤¥', 0),
            'coracao_partido': rxn_counts.get('ğŸ’”', 0),
            'score': score
        })

    n_total = len(summary_rows)
    n_active = len([p for p in participants if not p.get('characteristics', {}).get('eliminated')])

    # Calculate max values for color scaling
    max_hearts = max((r['hearts'] for r in summary_rows), default=1)
    max_neg = max((r['cobra'] + r['alvo'] + r['vomito'] + r['mentiroso'] for r in summary_rows), default=1)

    def heart_color(val):
        if val == 0: return "color: #666;"
        intensity = min(val / max_hearts, 1)
        if intensity > 0.7: return "background: #1a9850; color: #fff; font-weight: bold;"
        if intensity > 0.4: return "background: #91cf60; color: #000;"
        return "color: #a6d96a;"

    def neg_color(val):
        if val == 0: return "color: #666;"
        if val >= 3: return "background: #d73027; color: #fff; font-weight: bold;"
        if val >= 2: return "background: #fc8d59; color: #000;"
        return "color: #fdae61;"

    def score_color(val):
        if val >= 10: return "background: #1a9850; color: #fff; font-weight: bold;"
        if val >= 5: return "color: #66bd63;"
        if val >= 0: return "color: #a6d96a;"
        if val >= -5: return "color: #fdae61;"
        if val >= -10: return "color: #f46d43;"
        return "background: #d73027; color: #fff; font-weight: bold;"

    html = []
    html.append(f'''
<style>
.summary-table {{
    border-collapse: collapse;
    font-size: 0.85rem;
    width: 100%;
}}
.summary-table th, .summary-table td {{
    padding: 6px 8px;
    text-align: center;
    border-bottom: 1px solid #444;
}}
.summary-table th {{
    background: #222;
    position: sticky;
    top: 0;
    z-index: 1;
}}
.summary-table th:first-child, .summary-table td:first-child {{
    text-align: left;
    position: sticky;
    left: 0;
    background: #222;
    z-index: 2;
}}
.summary-table thead th:first-child {{ z-index: 3; }}
.summary-table tbody tr:hover {{ background: #333; }}
.collapsed-rows {{ display: none; }}
.expand-btn {{
    display: block;
    width: 100%;
    padding: 10px;
    margin-top: 8px;
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 6px;
    color: #ccc;
    cursor: pointer;
    font-size: 0.9rem;
}}
.expand-btn:hover {{ background: #333; }}
</style>
<div style="overflow-x: auto; max-width: 100%;">
<table class="summary-table" id="reaction-summary-table">
<thead>
<tr>
<th>Participante</th>
<th>â¤ï¸</th>
<th>ğŸŒ±</th>
<th>ğŸ’¼</th>
<th>ğŸª</th>
<th>ğŸ</th>
<th>ğŸ¯</th>
<th>ğŸ¤®</th>
<th>ğŸ¤¥</th>
<th>ğŸ’”</th>
<th>Score</th>
</tr>
</thead>
<tbody>
''')

    for i, r in enumerate(summary_rows):
        row_class = 'collapsed-rows' if i >= collapsed_rows else ''
        html.append(f'<tr class="{row_class}">')
        html.append(f'<td>{r["name"]}</td>')
        html.append(f'<td style="{heart_color(r["hearts"])}">{r["hearts"]}</td>')
        html.append(f'<td style="{neg_color(r["planta"])}">{r["planta"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["mala"])}">{r["mala"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["biscoito"])}">{r["biscoito"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["cobra"])}">{r["cobra"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["alvo"])}">{r["alvo"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["vomito"])}">{r["vomito"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["mentiroso"])}">{r["mentiroso"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["coracao_partido"])}">{r["coracao_partido"] or "Â·"}</td>')
        html.append(f'<td style="{score_color(r["score"])}">{r["score"]:+.1f}</td>')
        html.append('</tr>')

    html.append('</tbody></table></div>')

    if n_total > collapsed_rows:
        html.append(f'''
<button class="expand-btn" onclick="
    var rows = document.querySelectorAll('.collapsed-rows');
    var btn = this;
    if (btn.dataset.expanded === 'true') {{
        rows.forEach(r => r.style.display = 'none');
        btn.innerHTML = 'â–¼ Ver todos os {n_total} participantes';
        btn.dataset.expanded = 'false';
    }} else {{
        rows.forEach(r => r.style.display = 'table-row');
        btn.innerHTML = 'â–² Mostrar menos';
        btn.dataset.expanded = 'true';
    }}
" data-expanded="false">â–¼ Ver todos os {n_total} participantes</button>
''')

    return '\n'.join(html)


def make_negative_givers_chart(participants, matrix, title_suffix=""):
    """Retorna go.Figure com perfil de emissÃ£o de reaÃ§Ãµes (â¤ï¸ vs negativos)."""
    active_ns = sorted([p['name'] for p in participants
                        if not p.get('characteristics', {}).get('eliminated')])

    giver_data = []
    for name in active_ns:
        pos_given = 0
        neg_given = 0
        for receiver in active_ns:
            if name == receiver:
                continue
            rxn = matrix.get((name, receiver), '')
            if rxn in POSITIVE:
                pos_given += 1
            elif rxn:
                neg_given += 1

        total = pos_given + neg_given
        neg_pct = (neg_given / total * 100) if total > 0 else 0

        giver_data.append({
            'Participante': name,
            'â¤ï¸ dados': pos_given,
            'Negativos dados': neg_given,
            '% Negativo': round(neg_pct, 1),
            'Grupo': MEMBER_OF.get(name, '?')
        })

    df_givers = pd.DataFrame(giver_data).sort_values('% Negativo', ascending=True)

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_givers['Participante'],
        x=df_givers['â¤ï¸ dados'],
        name='â¤ï¸ dados',
        orientation='h',
        marker_color='#1a9850'
    ))
    fig.add_trace(go.Bar(
        y=df_givers['Participante'],
        x=df_givers['Negativos dados'],
        name='Negativos dados',
        orientation='h',
        marker_color='#d73027'
    ))

    title = "Perfil de EmissÃ£o: Quem DÃ¡ Mais â¤ï¸ vs Negatividade?"
    if title_suffix:
        title += f" â€” {title_suffix}"

    fig.update_layout(
        title=title,
        xaxis_title="Quantidade de reaÃ§Ãµes dadas",
        yaxis_title="",
        barmode='stack',
                height=max(500, len(df_givers) * 25),
        margin=dict(l=150)
    )

    return fig
```

```{python}
#| label: compute-highlights
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DESTAQUES DO DIA - Auto-generated highlights answering "What changed today?"
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from datetime import datetime

highlights = []

if len(daily_snapshots) >= 2:
    today = daily_snapshots[-1]
    yesterday = daily_snapshots[-2]
    today_mat = daily_matrices[-1]
    yesterday_mat = daily_matrices[-2]

    # Get active participants for today
    today_active = [p for p in today['participants']
                    if not p.get('characteristics', {}).get('eliminated')]
    today_names = set(p['name'] for p in today_active)

    # 1. Top participant + check if leading for multiple days
    sentiment_today = {p['name']: calc_sentiment(p) for p in today_active}
    if sentiment_today:
        leader_name = max(sentiment_today, key=sentiment_today.get)
        leader_score = sentiment_today[leader_name]

        # Count consecutive days leading
        streak = 1
        for i in range(len(daily_snapshots) - 2, -1, -1):
            snap = daily_snapshots[i]
            snap_active = [p for p in snap['participants']
                           if not p.get('characteristics', {}).get('eliminated')]
            if not snap_active:
                break
            snap_sent = {p['name']: calc_sentiment(p) for p in snap_active}
            if snap_sent and max(snap_sent, key=snap_sent.get) == leader_name:
                streak += 1
            else:
                break

        streak_text = f" pelo {streak}Âº dia consecutivo" if streak > 1 else ""
        highlights.append(f"ğŸ† **{leader_name}** lidera o [ranking](#ranking){streak_text} ({leader_score:+.1f})")

    # 2. Total reactions changed
    common_pairs = set(today_mat.keys()) & set(yesterday_mat.keys())
    changes = [(pair, yesterday_mat[pair], today_mat[pair])
               for pair in common_pairs if yesterday_mat[pair] != today_mat[pair]]
    n_changes = len(changes)

    if n_changes > 0:
        total_possible = len(common_pairs)
        pct_changed = n_changes / total_possible * 100 if total_possible > 0 else 0
        highlights.append(f"ğŸ“Š **{n_changes} reaÃ§Ãµes** [mudaram](mudancas.html) ontem ({pct_changed:.0f}% do total)")

    # 3. Biggest single change (prioritize dramatic shifts)
    dramatic_changes = []
    for pair, old_rxn, new_rxn in changes:
        giver, receiver = pair
        old_pos = old_rxn in POSITIVE
        new_pos = new_rxn in POSITIVE
        old_strong_neg = old_rxn in STRONG_NEGATIVE
        new_strong_neg = new_rxn in STRONG_NEGATIVE

        # Dramatic: heart to strong negative or vice versa
        if old_pos and new_strong_neg:
            emoji_new = REACTION_EMOJI.get(new_rxn, '?')
            dramatic_changes.append((giver, receiver, 'â¤ï¸', emoji_new, 'heart_to_snake'))
        elif old_strong_neg and new_pos:
            emoji_old = REACTION_EMOJI.get(old_rxn, '?')
            dramatic_changes.append((giver, receiver, emoji_old, 'â¤ï¸', 'snake_to_heart'))

    if dramatic_changes:
        giver, receiver, old_e, new_e, _ = dramatic_changes[0]
        giver_short = giver.split()[0]
        receiver_short = receiver.split()[0]
        highlights.append(f"ğŸ’¥ [Maior mudanÃ§a](mudancas.html): **{giver_short}** â†’ **{receiver_short}** (de {old_e} para {new_e})")

    # 4. New one-sided hostilities
    new_hostilities = []
    for pair, old_rxn, new_rxn in changes:
        giver, receiver = pair
        # Check if giver now dislikes receiver, but receiver likes giver
        new_is_neg = new_rxn not in POSITIVE and new_rxn != ''
        old_is_pos = old_rxn in POSITIVE
        receiver_likes_giver = today_mat.get((receiver, giver), '') in POSITIVE

        if old_is_pos and new_is_neg and receiver_likes_giver:
            new_hostilities.append((giver, receiver, new_rxn))

    if new_hostilities:
        highlights.append(f"âš ï¸ **{len(new_hostilities)}** [nova(s) hostilidade(s)](trajetoria.html#hostilidades-dia) unilateral(is) surgiram")

# 5. ParedÃ£o status (from latest snapshot)
paredao_check = []
for p in latest['participants']:
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    if 'ParedÃ£o' in roles:
        paredao_check.append(p['name'])

if paredao_check:
    names_str = ", ".join(sorted(paredao_check))
    highlights.append(f"ğŸ—³ï¸ [**ParedÃ£o ativo**](paredao.html): {names_str}")

# Format the date
try:
    date_obj = datetime.strptime(latest['date'], '%Y-%m-%d')
    date_display_pt = date_obj.strftime('%d de %B').replace('January', 'Janeiro').replace('February', 'Fevereiro').replace('March', 'MarÃ§o').replace('April', 'Abril').replace('May', 'Maio').replace('June', 'Junho').replace('July', 'Julho').replace('August', 'Agosto').replace('September', 'Setembro').replace('October', 'Outubro').replace('November', 'Novembro').replace('December', 'Dezembro')
except:
    date_display_pt = latest['date']

# Output the highlights callout
if highlights:
    print(f'''
::: {{.callout-tip title="Destaques do Dia ({date_display_pt})" appearance="simple"}}
''')
    for h in highlights:
        print(f"- {h}")
    print('''
:::
''')
else:
    print(f'''
::: {{.callout-note title="Destaques do Dia ({date_display_pt})" appearance="simple"}}
Primeiro dia de dados â€” sem comparaÃ§Ãµes disponÃ­veis ainda.
:::
''')
```

# VisÃ£o Geral {#visao-geral}

```{python}
#| label: overview-stats
#| output: asis

active = [p for p in latest['participants'] if not p.get('characteristics', {}).get('eliminated')]
n_active = len(active)
active_names = set(p['name'] for p in active)

# Contar por grupo
groups = Counter(p.get('characteristics', {}).get('memberOf', '?') for p in active)

# Contar reaÃ§Ãµes por tipo
total_reactions = 0
total_hearts = 0
total_negative = 0
for p in active:
    for rxn in p.get('characteristics', {}).get('receivedReactions', []):
        amt = rxn.get('amount', 0)
        total_reactions += amt
        if rxn.get('label') == 'CoraÃ§Ã£o':
            total_hearts += amt
        else:
            total_negative += amt

# â”€â”€ Calculate hostility metrics for "game temperature" â”€â”€
n_two_sided = 0      # Mutual enemies (both hate each other)
n_one_sided = 0      # False friends (A hates B, but B gives â¤ï¸)
blind_spot_victims = set()   # People who give â¤ï¸ to enemies
attackers = set()            # People who attack those who love them

checked_pairs = set()
for (a, b), rxn_a_to_b in latest_matrix.items():
    if a not in active_names or b not in active_names:
        continue

    rxn_b_to_a = latest_matrix.get((b, a), '')
    a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
    b_dislikes_a = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''
    b_likes_a = rxn_b_to_a in POSITIVE

    pair = frozenset([a, b])

    if a_dislikes_b and b_dislikes_a:
        if pair not in checked_pairs:
            n_two_sided += 1
            checked_pairs.add(pair)
    elif a_dislikes_b and b_likes_a:
        n_one_sided += 1
        attackers.add(a)       # A attacks someone who loves them
        blind_spot_victims.add(b)  # B gives â¤ï¸ to an enemy

n_blind_spots = len(blind_spot_victims)
n_attackers = len(attackers)

# Check for paredÃ£o
paredao_names = []
for p in latest['participants']:
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    if 'ParedÃ£o' in roles:
        paredao_names.append(p['name'])

# Format date
from datetime import datetime
try:
    date_obj = datetime.strptime(latest['date'], '%Y-%m-%d')
    date_display = date_obj.strftime('%d/%m')
except:
    date_display = latest['date']

# KPI Value Boxes - Two rows with explanations
print(f'''
<div style="display: flex; flex-wrap: wrap; gap: 0.8rem; margin: 1.5rem 0;">

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_active}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">Participantes</div>
</div>

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{total_hearts}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">â¤ï¸ CoraÃ§Ãµes</div>
</div>

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{total_negative}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">Negativos</div>
</div>

<a href="trajetoria.html#hostilidades-dia" style="flex: 1 1 150px; min-width: 120px; text-decoration: none;">
<div style="background: linear-gradient(135deg, #d73027 0%, #a50026 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3); cursor: pointer; height: 100%; box-sizing: border-box;">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_two_sided}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">âš”ï¸ Inimigos</div>
<div style="font-size: 0.65rem; color: rgba(255,255,255,0.6); margin-top: 0.2rem;">pares mÃºtuos</div>
</div>
</a>

<a href="trajetoria.html#hostilidades-dia" style="flex: 1 1 150px; min-width: 120px; text-decoration: none;">
<div style="background: linear-gradient(135deg, #f39c12 0%, #d68910 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3); cursor: pointer; height: 100%; box-sizing: border-box;">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_one_sided}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">ğŸ­ Falsos Amigos</div>
<div style="font-size: 0.65rem; color: rgba(255,255,255,0.6); margin-top: 0.2rem;">A detesta B, B dÃ¡ â¤ï¸</div>
</div>
</a>

<a href="trajetoria.html#hostilidades-dia" style="flex: 1 1 150px; min-width: 120px; text-decoration: none;">
<div style="background: linear-gradient(135deg, #8e44ad 0%, #6c3483 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3); cursor: pointer; height: 100%; box-sizing: border-box;">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_blind_spots}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">ğŸ‘ï¸ Pontos Cegos</div>
<div style="font-size: 0.65rem; color: rgba(255,255,255,0.6); margin-top: 0.2rem;">dÃ£o â¤ï¸ a inimigos</div>
</div>
</a>

</div>

<p class="text-muted small" style="margin-top: 0.3rem; text-align: center;">ğŸ“… Dados de <strong>{date_display}</strong> â€” {n_daily} dias de histÃ³rico</p>
''')
```

```{python}
#| label: paredao-status-card
#| output: asis

# ParedÃ£o Status Card - shows current paredÃ£o state
paredao_names = []
for p in latest['participants']:
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    if 'ParedÃ£o' in roles:
        paredao_names.append(p['name'])

if paredao_names:
    status_text = "Em VotaÃ§Ã£o"
    status_color = "#e74c3c"
    status_icon = "ğŸ—³ï¸"
    names_display = ", ".join(sorted(paredao_names))
    emparedados_html = f'<div style="color: #ccc; font-size: 0.95rem;">Emparedados: <strong>{names_display}</strong></div>'
else:
    status_text = "Aguardando formaÃ§Ã£o"
    status_color = "#6c757d"
    status_icon = "â³"
    emparedados_html = '<div style="color: #888; font-size: 0.9rem;">Nenhum paredÃ£o ativo no momento</div>'

print(f'''
<div style="background: #2a2a2a; border-radius: 12px; padding: 1rem 1.2rem; margin: 1rem 0 1.5rem 0; border-left: 4px solid {status_color}; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
<div>
<div style="font-size: 1.1rem; font-weight: bold; color: #fff; margin-bottom: 0.3rem;">
{status_icon} ParedÃ£o: <span style="color: {status_color};">{status_text}</span>
</div>
{emparedados_html}
</div>
<a href="paredao.html" style="background: {status_color}; color: #fff; padding: 0.5rem 1rem; border-radius: 6px; text-decoration: none; font-weight: 500; font-size: 0.9rem; white-space: nowrap;">
Ver anÃ¡lise â†’
</a>
</div>
''')
```

::: {.callout-warning title="ğŸ—³ï¸ ParedÃ£o"}
Para acompanhar o **paredÃ£o atual** (formaÃ§Ã£o, votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia entre reaÃ§Ãµes e votos), acesse a pÃ¡gina dedicada: **[ParedÃ£o](paredao.html)**

Para ver o **histÃ³rico de paredÃµes anteriores**, acesse: **[Arquivo de ParedÃµes](paredoes.html)**
:::

```{python}
#| label: watchlist-risco
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WATCHLIST DE RISCO â€” Top 5 most vulnerable participants
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from collections import Counter

def get_vulnerability_data(matrix, active_names):
    """Calculate who gives â¤ï¸ to enemies and who attacks friends."""
    loving_victim = Counter()  # Who gives â¤ï¸ to people who hate them
    hostile_giver = Counter()  # Who attacks people who love them
    blind_spots = {}           # {victim: [list of attackers who receive â¤ï¸]}

    for (a, b), rxn_a_to_b in matrix.items():
        if a not in active_names or b not in active_names:
            continue

        rxn_b_to_a = matrix.get((b, a), '')
        a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
        b_likes_a = rxn_b_to_a in POSITIVE

        # A dislikes B, but B gives A a â¤ï¸
        if a_dislikes_b and b_likes_a:
            hostile_giver[a] += 1   # A is attacking someone who loves them
            loving_victim[b] += 1   # B gives â¤ï¸ to an enemy
            # Track who B's attackers are
            if b not in blind_spots:
                blind_spots[b] = []
            blind_spots[b].append(a)

    return loving_victim, hostile_giver, blind_spots

active_for_watchlist = set(p['name'] for p in latest['participants']
                           if not p.get('characteristics', {}).get('eliminated'))

loving_victim, hostile_giver, blind_spots = get_vulnerability_data(latest_matrix, active_for_watchlist)

# Calculate vulnerability scores: â¤ï¸ given to enemies / (attacks on friends + 1)
vulnerability_scores = []
for name in loving_victim:
    hearts_to_enemies = loving_victim[name]
    attacks_on_friends = hostile_giver.get(name, 0)
    ratio = hearts_to_enemies / (attacks_on_friends + 1)
    vulnerability_scores.append({
        'name': name,
        'hearts_to_enemies': hearts_to_enemies,
        'attacks_on_friends': attacks_on_friends,
        'ratio': ratio,
        'grupo': MEMBER_OF.get(name, '?'),
        'attackers': blind_spots.get(name, [])
    })

# Sort by vulnerability ratio, take top 5
top_vulnerable = sorted(vulnerability_scores, key=lambda x: (-x['ratio'], -x['hearts_to_enemies']))[:5]

if top_vulnerable:
    print('''
# Watchlist de Risco {#watchlist}

Participantes com **pontos cegos** â€” dÃ£o â¤ï¸ para quem os detesta. Podem ser surpreendidos em votaÃ§Ãµes.

<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
''')

    for i, p in enumerate(top_vulnerable):
        # Color by risk level
        if p['ratio'] >= 3:
            border_color = '#e74c3c'  # Red - high risk
            risk_label = 'Alto Risco'
        elif p['ratio'] >= 2:
            border_color = '#f39c12'  # Orange - medium risk
            risk_label = 'Risco MÃ©dio'
        else:
            border_color = '#f1c40f'  # Yellow - watch
            risk_label = 'AtenÃ§Ã£o'

        grupo_color = GROUP_COLORS.get(p['grupo'], '#666')
        avatar_url = AVATARS.get(p['name'], '')

        # Show up to 3 attackers
        attackers_display = ', '.join(p['attackers'][:3])
        if len(p['attackers']) > 3:
            attackers_display += f' +{len(p["attackers"]) - 3}'

        print(f'''
<div style="background: #2a2a2a; border-radius: 10px; border-left: 4px solid {border_color}; padding: 1rem; display: flex; gap: 0.8rem; align-items: flex-start;">
<div style="flex-shrink: 0;">
<img src="{avatar_url}" alt="{p['name']}" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid {grupo_color}; object-fit: cover;">
</div>
<div style="flex: 1; min-width: 0;">
<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.3rem;">
<span style="font-weight: bold; color: #fff; font-size: 1rem;">{p['name']}</span>
<span style="background: {border_color}; color: #fff; padding: 0.15rem 0.5rem; border-radius: 4px; font-size: 0.7rem; text-transform: uppercase;">{risk_label}</span>
</div>
<div style="color: #aaa; font-size: 0.8rem; margin-top: 0.4rem;">
DÃ¡ â¤ï¸ para <strong style="color: #e74c3c;">{p['hearts_to_enemies']}</strong> {('pessoa que o detesta' if p['hearts_to_enemies'] == 1 else 'pessoas que o detestam')}
</div>
<div style="color: #888; font-size: 0.75rem; margin-top: 0.3rem;">
ğŸ‘ï¸ Pontos cegos: <span style="color: #ccc;">{attackers_display}</span>
</div>
</div>
</div>
''')

    print('</div>')
    print(f'\n<p style="text-align: center; margin-top: 0.5rem;"><a href="trajetoria.html#hostilidades-dia" style="color: #6ea8fe; font-size: 0.85rem;">Ver anÃ¡lise completa â†’</a></p>')
else:
    print("*Nenhum participante com pontos cegos detectado.*")
```

# Ranking de Sentimento {#ranking}

Cada participante recebe reaÃ§Ãµes dos demais. O **score de sentimento** pondera: â¤ï¸ = +1, reaÃ§Ãµes leves (ğŸŒ±ğŸ’¼ğŸª) = -0.5, reaÃ§Ãµes fortes (ğŸğŸ¯ğŸ¤®ğŸ¤¥ğŸ’”) = -1.

```{python}
#| label: ranking-prep
#| include: false

# Pre-calculate data for ranking tabs
_n_today = len([p for p in latest['participants']
                if not p.get('characteristics', {}).get('eliminated')])
_ranking_height = max(500, _n_today * 32)

# Calculate sentiment scores for today
today_scores = {}
for p in latest['participants']:
    if not p.get('characteristics', {}).get('eliminated'):
        today_scores[p['name']] = {
            'score': calc_sentiment(p),
            'group': p.get('characteristics', {}).get('memberOf', '?')
        }

# Calculate yesterday scores (if available)
yesterday_scores = {}
if n_daily >= 2:
    yesterday = daily_snapshots[-2]
    for p in yesterday['participants']:
        if not p.get('characteristics', {}).get('eliminated'):
            yesterday_scores[p['name']] = calc_sentiment(p)

# Calculate 7-days-ago scores (if available)
week_ago_scores = {}
if n_daily >= 7:
    week_ago = daily_snapshots[-7]
    for p in week_ago['participants']:
        if not p.get('characteristics', {}).get('eliminated'):
            week_ago_scores[p['name']] = calc_sentiment(p)


def make_sentiment_change_table(today_scores, past_scores, period_label):
    """Create HTML table showing sentiment changes with colors."""
    if not past_scores:
        return f"<p class='text-muted'>Dados insuficientes para comparaÃ§Ã£o de {period_label}.</p>"

    # Calculate changes
    rows = []
    for name, data in today_scores.items():
        today_score = data['score']
        group = data['group']
        past_score = past_scores.get(name)

        if past_score is not None:
            delta = today_score - past_score
            rows.append({
                'name': name,
                'group': group,
                'past': past_score,
                'today': today_score,
                'delta': delta
            })

    # Sort by delta descending (biggest gainers first)
    rows.sort(key=lambda x: -x['delta'])

    # Build HTML table
    html = '''
<div style="max-height: 500px; overflow-y: auto; border-radius: 8px; border: 1px solid #444;">
<table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
<thead style="position: sticky; top: 0; background: #2a2a2a; z-index: 1;">
<tr style="border-bottom: 2px solid #555;">
<th style="padding: 0.6rem; text-align: left; color: #ccc;">Participante</th>
<th style="padding: 0.6rem; text-align: center; color: #ccc;">Antes</th>
<th style="padding: 0.6rem; text-align: center; color: #ccc;">Hoje</th>
<th style="padding: 0.6rem; text-align: center; color: #ccc;">Î”</th>
</tr>
</thead>
<tbody>
'''

    for row in rows:
        # Color for delta
        if row['delta'] > 1:
            delta_color = '#27ae60'  # Green
            delta_bg = 'rgba(39, 174, 96, 0.2)'
        elif row['delta'] > 0:
            delta_color = '#58d68d'  # Light green
            delta_bg = 'rgba(88, 214, 141, 0.1)'
        elif row['delta'] < -1:
            delta_color = '#e74c3c'  # Red
            delta_bg = 'rgba(231, 76, 60, 0.2)'
        elif row['delta'] < 0:
            delta_color = '#ec7063'  # Light red
            delta_bg = 'rgba(236, 112, 99, 0.1)'
        else:
            delta_color = '#888'
            delta_bg = 'transparent'

        # Arrow emoji
        if row['delta'] > 0:
            arrow = 'ğŸ“ˆ'
        elif row['delta'] < 0:
            arrow = 'ğŸ“‰'
        else:
            arrow = 'â–'

        # Group color dot
        group_color = GROUP_COLORS.get(row['group'], '#666')

        html += f'''
<tr style="border-bottom: 1px solid #333; background: {delta_bg};">
<td style="padding: 0.5rem;"><span style="color: {group_color}; margin-right: 0.3rem;">â—</span>{row['name']}</td>
<td style="padding: 0.5rem; text-align: center; color: #aaa;">{row['past']:+.1f}</td>
<td style="padding: 0.5rem; text-align: center; font-weight: 500;">{row['today']:+.1f}</td>
<td style="padding: 0.5rem; text-align: center; color: {delta_color}; font-weight: bold;">{arrow} {row['delta']:+.1f}</td>
</tr>
'''

    html += '</tbody></table></div>'
    return html
```

::: {.panel-tabset}

## Hoje

```{python}
#| label: sentiment-ranking-today

fig = make_sentiment_ranking(latest['participants'], latest_matrix, title_suffix=latest['label'], fixed_height=_ranking_height)
fig.show()
```

## Ontemâ†’Hoje

```{python}
#| label: sentiment-yesterday-today
#| output: asis

if n_daily >= 2:
    yesterday_label = daily_snapshots[-2]['label']
    print(f"<p class='text-muted small'>MudanÃ§as de <strong>{yesterday_label}</strong> para <strong>{latest['label']}</strong></p>")
    print(make_sentiment_change_table(today_scores, yesterday_scores, "ontem"))
else:
    print("<p class='text-muted'>Dados insuficientes (apenas 1 dia disponÃ­vel).</p>")
```

## Em 7 dias

```{python}
#| label: sentiment-7d-change
#| output: asis

if n_daily >= 7:
    week_ago_label = daily_snapshots[-7]['label']
    print(f"<p class='text-muted small'>MudanÃ§as de <strong>{week_ago_label}</strong> para <strong>{latest['label']}</strong></p>")
    print(make_sentiment_change_table(today_scores, week_ago_scores, "7 dias"))
else:
    print(f"<p class='text-muted'>Dados insuficientes (apenas {n_daily} dias disponÃ­veis).</p>")
```

## EvoluÃ§Ã£o

```{python}
#| label: sentiment-evolution
#| output: asis

# Build timeline data for sentiment evolution chart
timeline_data = []
if daily_metrics_map:
    for date_str in sorted(daily_metrics_map.keys()):
        entry = daily_metrics_map[date_str]
        for name, score in entry.get('sentiment', {}).items():
            timeline_data.append({
                'Data': pd.to_datetime(date_str),
                'Participante': name,
                'Sentimento': score,
                'Grupo': MEMBER_OF.get(name, '?')
            })
else:
    for snap in daily_snapshots:
        for p in snap['participants']:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            name = p['name']
            score = calc_sentiment(p)
            timeline_data.append({
                'Data': pd.to_datetime(snap['date']),
                'Participante': name,
                'Sentimento': score,
                'Grupo': p.get('characteristics', {}).get('memberOf', '?')
            })

df_timeline = pd.DataFrame(timeline_data)

if not df_timeline.empty and len(df_timeline['Data'].unique()) > 1:
    # Color palette for participants
    all_parts = sorted(df_timeline['Participante'].unique())
    palette = (
        px.colors.qualitative.Plotly + px.colors.qualitative.D3 +
        px.colors.qualitative.Set2 + px.colors.qualitative.Bold
    )
    part_colors = {name: palette[i % len(palette)] for i, name in enumerate(all_parts)}

    # Top 3 and bottom 3 by latest score - visible by default
    latest_scores_df = df_timeline.groupby('Participante')['Sentimento'].last()
    top3 = set(latest_scores_df.nlargest(3).index)
    bottom3 = set(latest_scores_df.nsmallest(3).index)
    highlight = top3 | bottom3

    fig = go.Figure()

    for name in all_parts:
        df_p = df_timeline[df_timeline['Participante'] == name].sort_values('Data')
        is_hl = name in highlight

        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Sentimento'],
            mode='lines+markers',
            name=name,
            line=dict(width=3 if is_hl else 1.5, color=part_colors[name]),
            marker=dict(size=6 if is_hl else 4),
            hovertemplate=f'{name}: ' + '%{y:+.1f}<extra></extra>',
            visible=True if is_hl else 'legendonly',
        ))

    # Zero line
    fig.add_shape(type='line', x0=df_timeline['Data'].min(), x1=df_timeline['Data'].max(),
                  y0=0, y1=0, line=dict(color='red', dash='dash', width=1))

    # ParedÃ£o date lines (load from paredoes.json)
    paredoes_file = Path("data/paredoes.json")
    if paredoes_file.exists():
        with open(paredoes_file, encoding="utf-8") as f:
            paredoes_data = json.load(f)
        for p in paredoes_data.get('paredoes', []):
            paredao_date = pd.to_datetime(p['data'])
            y_range = [df_timeline['Sentimento'].min() - 2, df_timeline['Sentimento'].max() + 2]
            fig.add_shape(
                type='line', x0=paredao_date, x1=paredao_date,
                y0=y_range[0], y1=y_range[1],
                line=dict(color='#FF6B6B', dash='dot', width=2),
            )
            # Add annotation
            fig.add_annotation(
                x=paredao_date, y=y_range[1],
                text=f"ğŸ—³ï¸ {p['numero']}Âº ParedÃ£o",
                showarrow=False,
                font=dict(size=11, color='#FF6B6B'),
                yshift=10,
            )

    fig.update_layout(
        title="EvoluÃ§Ã£o do Sentimento ao Longo do Tempo",
        xaxis_title="Data",
        yaxis_title="Score de Sentimento",
        height=_ranking_height,  # Same height as Ranking tabs
        hovermode='x unified',
        legend=dict(font=dict(size=11), itemsizing='constant'),
        margin=dict(r=180),  # More room for legend
    )

    fig.show()

    print("<p class='text-muted small' style='margin-top: 0.5rem;'>Top 3 e bottom 3 destacados por padrÃ£o. Clique na legenda para mostrar/esconder outros participantes.</p>")
else:
    print("<p class='text-muted'>Dados insuficientes para grÃ¡fico de evoluÃ§Ã£o.</p>")
```

:::

# Tabela Cruzada de ReaÃ§Ãµes {#crosstable}

<p class="text-muted small">ğŸ“¸ <strong>Dado do dia</strong> â€” mostra apenas a coleta mais recente.</p>

Quem deu qual reaÃ§Ã£o para quem. Cada cÃ©lula mostra a reaÃ§Ã£o que a **linha** (emissor) deu para a **coluna** (receptor).

```{python}
#| label: cross-table
#| output: asis

# Definir active_names (usado por outras seÃ§Ãµes abaixo)
active_names = sorted([p['name'] for p in latest['participants']
                        if not p.get('characteristics', {}).get('eliminated')])

# HTML table with sticky header/column (mobile-friendly)
print(make_cross_table_html(latest['participants'], latest_matrix, title_suffix=latest['label']))
```

```{python}
#| label: cross-table-summary
#| output: asis

print("\n### ReaÃ§Ãµes Recebidas por Participante\n")
print("<p class='text-muted small'>Ordenado por score de sentimento. CÃ©lulas coloridas indicam valores altos.</p>")
print(make_reaction_summary_html(latest['participants'], collapsed_rows=5))
```

# Perfis Individuais {#perfis}

<p class="text-muted small">ğŸ“¸ <strong>Dado do dia</strong> â€” mostra apenas a coleta mais recente.</p>

Detalhamento estratÃ©gico de cada participante ativo, incluindo anÃ¡lise de hostilidades e vulnerabilidades no jogo.

<div style="background: #2a2a2a; border-radius: 12px; padding: 1.2rem; margin: 1.5rem 0; border-left: 4px solid #17a2b8;">

**ğŸ¯ Vulnerabilidade a Votos Surpresa**

O badge avalia o risco de receber **votos inesperados** â€” de pessoas que o participante considera aliadas mas que, na verdade, sÃ£o hostis ("falsos amigos"). Quem tem muitos inimigos declarados mas zero falsos amigos estÃ¡ em posiÃ§Ã£o mais segura: sabe exatamente de onde vÃªm as ameaÃ§as.

| Badge | CritÃ©rio | Significado |
|-------|----------|-------------|
| ğŸ”´ **MUITO VULNERÃVEL** | 5+ falsos amigos | PosiÃ§Ã£o crÃ­tica. Muitas pessoas que considera amigas podem votar contra sem que espere. |
| ğŸŸ  **VULNERÃVEL** | 3-4 falsos amigos | PosiÃ§Ã£o frÃ¡gil. Alguns "amigos" sÃ£o hostis e podem surpreender em votaÃ§Ã£o. |
| ğŸŸ¡ **ATENÃ‡ÃƒO** | 1-2 falsos amigos | PosiÃ§Ã£o razoÃ¡vel, mas com pontos cegos. |
| ğŸŸ¢ **PROTEGIDO** | 0 falsos amigos | Sem pontos cegos â€” sabe quem sÃ£o seus aliados e inimigos. |

**Categorias de RelaÃ§Ã£o:**

- **âœ… Aliados** â€” â¤ï¸ mÃºtuo. Votos seguros, nÃ£o votarÃ£o contra.
- **âš”ï¸ Inimigos Declarados** â€” Negatividade mÃºtua. Votos contra esperados de ambos os lados.
- **âš ï¸ Falsos Amigos** â€” VocÃª dÃ¡ â¤ï¸, mas eles dÃ£o negativa. **PERIGO:** podem votar contra vocÃª!
- **ğŸ—¡ï¸ Inimigos NÃ£o Declarados** â€” VocÃª dÃ¡ negativa, eles dÃ£o â¤ï¸. Eles nÃ£o sabem que sÃ£o seus alvos.

</div>

```{python}
#| label: individual-profiles
#| output: asis

# Ordenar alfabeticamente
sorted_active = sorted(
    [p for p in latest['participants'] if not p.get('characteristics', {}).get('eliminated')],
    key=lambda x: x['name']
)

for p in sorted_active:
    name = p['name']
    first_name = name.split()[0]
    member_of = p.get('characteristics', {}).get('memberOf', '?')
    group = p.get('characteristics', {}).get('group', '?')
    balance = p.get('characteristics', {}).get('balance', 0)
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    score = calc_sentiment(p)

    # ReaÃ§Ãµes recebidas
    rxn_summary = []
    for rxn in p.get('characteristics', {}).get('receivedReactions', []):
        emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
        rxn_summary.append(f"{emoji}Ã—{rxn['amount']}")

    # ReaÃ§Ãµes que este participante deu
    given = {}
    for other_name in active_names:
        if other_name == name:
            continue
        rxn = latest_matrix.get((name, other_name), '')
        if rxn:
            emoji = REACTION_EMOJI.get(rxn, rxn)
            given[emoji] = given.get(emoji, 0) + 1

    given_summary = " | ".join(f"{e}Ã—{c}" for e, c in sorted(given.items(), key=lambda x: -x[1]))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ANÃLISE ESTRATÃ‰GICA DE RELAÃ‡Ã•ES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    allies = []           # â¤ï¸ mÃºtuo â€” aliados seguros
    enemies = []          # Neg mÃºtua â€” inimigos declarados (votos previsÃ­veis)
    false_friends = []    # Dou â¤ï¸, recebo neg â€” PERIGO: podem me votar
    blind_targets = []    # Dou neg, recebo â¤ï¸ â€” posso votar neles sem retaliaÃ§Ã£o esperada

    for other_name in active_names:
        if other_name == name:
            continue
        my_rxn = latest_matrix.get((name, other_name), '')
        their_rxn = latest_matrix.get((other_name, name), '')

        my_is_positive = my_rxn in POSITIVE
        their_is_positive = their_rxn in POSITIVE
        my_is_negative = my_rxn and my_rxn not in POSITIVE
        their_is_negative = their_rxn and their_rxn not in POSITIVE

        if my_is_positive and their_is_positive:
            allies.append(other_name)
        elif my_is_negative and their_is_negative:
            my_emoji = REACTION_EMOJI.get(my_rxn, '?')
            their_emoji = REACTION_EMOJI.get(their_rxn, '?')
            enemies.append((other_name, my_emoji, their_emoji))
        elif my_is_positive and their_is_negative:
            their_emoji = REACTION_EMOJI.get(their_rxn, '?')
            false_friends.append((other_name, their_emoji))
        elif my_is_negative and their_is_positive:
            my_emoji = REACTION_EMOJI.get(my_rxn, '?')
            blind_targets.append((other_name, my_emoji))

    # Calculate metrics
    n_false_friends = len(false_friends)
    n_blind_targets = len(blind_targets)
    n_enemies = len(enemies)
    n_allies = len(allies)
    total_relations = n_allies + n_enemies + n_false_friends + n_blind_targets

    # Vulnerability assessment - based on false friends (blind spots for incoming votes)
    # Thresholds calibrated to current data: avg ~2.6 false friends, max 9
    if n_false_friends >= 5:
        risk_level = "ğŸ”´ MUITO VULNERÃVEL"
        risk_color = "#dc3545"
    elif n_false_friends >= 3:
        risk_level = "ğŸŸ  VULNERÃVEL"
        risk_color = "#fd7e14"
    elif n_false_friends >= 1:
        risk_level = "ğŸŸ¡ ATENÃ‡ÃƒO"
        risk_color = "#ffc107"
    else:
        risk_level = "ğŸŸ¢ PROTEGIDO"
        risk_color = "#28a745"

    # Get avatar
    avatar_url = AVATARS.get(name, '')
    cor_grupo = GROUP_COLORS.get(member_of, '#666')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PROFILE CARD - Using HTML tables for better formatting
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f'''
<div style="margin-top: 2rem; margin-bottom: 1rem; border: 1px solid #444; border-radius: 12px; overflow: hidden; background: #2a2a2a;">

<!-- Header with avatar -->
<div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: linear-gradient(90deg, rgba(48,48,48,0.9), rgba(48,48,48,0.3)); border-left: 5px solid {cor_grupo};">
''')
    if avatar_url:
        print(f'<img src="{avatar_url}" alt="{name}" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid {cor_grupo}; flex-shrink: 0;">')

    role_text = f" | {', '.join(roles)}" if roles else ""
    print(f'''
<div>
<h3 style="margin: 0 0 0.3rem 0; color: #fff; font-size: 1.4em;">{name} <span style="font-size: 0.5em; padding: 3px 10px; border-radius: 4px; background: {risk_color}; color: #fff; vertical-align: middle; font-weight: bold;">{risk_level}</span></h3>
<div style="color: #aaa; font-size: 0.95em;">
<strong style="color: {cor_grupo};">{member_of}</strong> | {group} | Saldo: {balance:,} | Sentimento: <strong style="color: {'#28a745' if score >= 0 else '#dc3545'};">{score:+.1f}</strong>{role_text}
</div>
</div>
</div>

<!-- Reactions -->
<div style="padding: 0.8rem 1rem; border-bottom: 1px solid #444; background: #333;">
<div style="display: flex; flex-wrap: wrap; gap: 1.5rem;">
<div><strong style="color: #888;">Recebeu:</strong> {' '.join(rxn_summary)}</div>
<div><strong style="color: #888;">Deu:</strong> {given_summary}</div>
</div>
</div>

<!-- Strategic Map -->
<div style="padding: 1rem;">
<h4 style="margin: 0 0 0.8rem 0; color: #fff; font-size: 1em; border-bottom: 1px solid #444; padding-bottom: 0.5rem;">ğŸ—ºï¸ Mapa EstratÃ©gico</h4>
''')

    # Allies
    if allies:
        allies_str = ', '.join(sorted(allies))
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border-left: 3px solid #28a745;">
<div style="font-weight: bold; color: #28a745; margin-bottom: 0.3rem;">âœ… Aliados ({n_allies})</div>
<div style="color: #ccc; font-size: 0.9em;">{allies_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Votos seguros. NÃ£o votarÃ£o contra.</div>
</div>
''')

    # Enemies
    if enemies:
        enemy_items = [f"{n} <span style='color:#888;'>({me}â†”{te})</span>" for n, me, te in sorted(enemies, key=lambda x: x[0])]
        enemies_str = ', '.join(enemy_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(220, 53, 69, 0.1); border-radius: 6px; border-left: 3px solid #dc3545;">
<div style="font-weight: bold; color: #dc3545; margin-bottom: 0.3rem;">âš”ï¸ Inimigos Declarados ({n_enemies})</div>
<div style="color: #ccc; font-size: 0.9em;">{enemies_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Hostilidade mÃºtua. Votos contra esperados de ambos os lados.</div>
</div>
''')

    # False Friends - DANGER
    if false_friends:
        ff_items = [f"<strong>{n}</strong> <span style='color:#dc3545;'>({e})</span>" for n, e in sorted(false_friends, key=lambda x: x[0])]
        ff_str = ', '.join(ff_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(255, 193, 7, 0.15); border-radius: 6px; border-left: 3px solid #ffc107;">
<div style="font-weight: bold; color: #ffc107; margin-bottom: 0.3rem;">âš ï¸ Falsos Amigos ({n_false_friends}) â€” PERIGO!</div>
<div style="color: #ccc; font-size: 0.9em;">{ff_str}</div>
<div style="color: #dc3545; font-size: 0.8em; margin-top: 0.3rem;">â†’ {first_name} dÃ¡ â¤ï¸ mas recebe negatividade. Podem votar contra sem que {first_name} espere!</div>
</div>
''')

    # Blind Targets - Undeclared enemies (they don't know)
    if blind_targets:
        bt_items = [f"{n} <span style='color:#6f42c1;'>({e})</span>" for n, e in sorted(blind_targets, key=lambda x: x[0])]
        bt_str = ', '.join(bt_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(111, 66, 193, 0.1); border-radius: 6px; border-left: 3px solid #6f42c1;">
<div style="font-weight: bold; color: #6f42c1; margin-bottom: 0.3rem;">ğŸ—¡ï¸ Inimigos NÃ£o Declarados ({n_blind_targets})</div>
<div style="color: #ccc; font-size: 0.9em;">{bt_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Eles dÃ£o â¤ï¸ para {first_name}, mas {first_name} Ã© hostil. Eles nÃ£o sabem que sÃ£o alvos.</div>
</div>
''')

    # Game Analysis
    insights = []
    if n_false_friends == 0 and n_enemies == 0:
        insights.append("ğŸ›¡ï¸ PosiÃ§Ã£o confortÃ¡vel: sem inimigos e sem falsos amigos.")
    if n_false_friends >= 3:
        insights.append(f"ğŸš¨ <strong style='color:#dc3545;'>PosiÃ§Ã£o vulnerÃ¡vel</strong>: {n_false_friends} pessoas que considera amigas sÃ£o hostis.")
    elif n_false_friends >= 1:
        insights.append(f"âš¡ AtenÃ§Ã£o: {n_false_friends} falso(s) amigo(s) pode(m) surpreender em votaÃ§Ã£o.")
    if n_blind_targets >= 3:
        insights.append(f"ğŸ—¡ï¸ {n_blind_targets} inimigos nÃ£o declarados: confiam em {first_name} sem saber que sÃ£o alvos.")
    if n_enemies >= 3:
        insights.append(f"ğŸ”¥ Polarizante: {n_enemies} inimigos declarados. Alvo provÃ¡vel em paredÃµes.")
    if n_allies >= 10 and total_relations > 0:
        pct = n_allies * 100 // total_relations
        insights.append(f"ğŸ’ª Base sÃ³lida: {n_allies} aliados ({pct}% das relaÃ§Ãµes).")

    if insights:
        print(f'''
<div style="padding: 0.6rem; background: #383838; border-radius: 6px; margin-top: 0.5rem;">
<div style="font-weight: bold; color: #fff; margin-bottom: 0.4rem; font-size: 0.9em;">ğŸ“Š AnÃ¡lise de Jogo</div>
<ul style="margin: 0; padding-left: 1.2rem; color: #ccc; font-size: 0.85em;">
''')
        for insight in insights:
            print(f'<li style="margin-bottom: 0.2rem;">{insight}</li>')
        print('</ul></div>')

    print('</div></div>')  # Close strategic map and card
```

---

<div class="alert alert-info" role="alert">
<strong>ğŸ’¡ Sobre este painel:</strong> Este painel acompanha as reaÃ§Ãµes do queridÃ´metro do BBB 26. As reaÃ§Ãµes <strong>mudam diariamente</strong> â€” os participantes podem trocar suas escolhas a cada Raio-X. SeÃ§Ãµes marcadas com ğŸ“¸ mostram apenas o dia mais recente; seÃ§Ãµes marcadas com ğŸ“ˆ mostram a evoluÃ§Ã£o ao longo do tempo. Acompanhamento desde 13 de janeiro de 2026.
</div>
