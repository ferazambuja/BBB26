---
title: "BBB 26 â€” Painel de ReaÃ§Ãµes"
subtitle: "AnÃ¡lise das reaÃ§Ãµes entre os participantes do Big Brother Brasil 2026"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import load_snapshot, get_all_snapshots, parse_roles, build_reaction_matrix

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

POWER_EVENT_EMOJI = {
    'lider': 'ğŸ‘‘',
    'anjo': 'ğŸ˜‡',
    'monstro': 'ğŸ‘¹',
    'imunidade': 'ğŸ›¡ï¸',
    'indicacao': 'ğŸ¯',
    'contragolpe': 'ğŸŒ€',
    'voto_duplo': 'ğŸ—³ï¸',
    'voto_anulado': 'ğŸš«',
    'perdeu_voto': 'â›”',
}

POWER_EVENT_LABELS = {
    'lider': 'LÃ­der',
    'anjo': 'Anjo',
    'monstro': 'Monstro',
    'imunidade': 'Imunidade',
    'indicacao': 'IndicaÃ§Ã£o',
    'contragolpe': 'Contragolpe',
    'voto_duplo': 'Voto 2x',
    'voto_anulado': 'Voto anulado',
    'perdeu_voto': 'Perdeu voto',
}

REACTION_SLUG_TO_LABEL = {
    'coracao': 'CoraÃ§Ã£o', 'planta': 'Planta', 'mala': 'Mala', 'biscoito': 'Biscoito',
    'cobra': 'Cobra', 'alvo': 'Alvo', 'vomito': 'VÃ´mito', 'mentiroso': 'Mentiroso',
    'coracao-partido': 'CoraÃ§Ã£o partido'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0,
    'CoraÃ§Ã£o partido': -0.5  # Mild negative (disappointment, not hostility)
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito', 'CoraÃ§Ã£o partido'}  # ğŸ’” = disappointment, not hostility
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}  # preenchido ao carregar dados

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Plotly Dark Theme Configuration (matches Bootswatch darkly)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PLOT_BG = '#303030'  # Darkly body background
PAPER_BG = '#303030'
GRID_COLOR = '#444444'
TEXT_COLOR = '#fff'

# Standard layout applied to ALL plots
import plotly.io as pio

pio.templates['bbb_dark'] = go.layout.Template(
    layout=go.Layout(
        paper_bgcolor=PAPER_BG,
        plot_bgcolor=PLOT_BG,
        font=dict(color=TEXT_COLOR, family='Lato, -apple-system, sans-serif', size=13),
        title=dict(font=dict(size=16), x=0.5, xanchor='center', y=0.95),
        margin=dict(l=70, r=30, t=70, b=60),
        xaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        yaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        legend=dict(
            bgcolor='rgba(0,0,0,0)',
            bordercolor='rgba(0,0,0,0)',
        ),
        colorway=['#00bc8c', '#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6'],
    )
)
pio.templates.default = 'bbb_dark'
```

```{python}
#| label: load-data

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label legÃ­vel e flag de sintÃ©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

# Detectar participantes que entraram apÃ³s o primeiro snapshot
first_snap_names = set(p['name'] for p in snapshots[0]['participants'])
late_entrants = {}
_seen_names = set(first_snap_names)
for snap in snapshots[1:]:
    current_names = set(p['name'] for p in snap['participants'])
    new_names = current_names - _seen_names
    for name in new_names:
        if name not in late_entrants:
            late_entrants[name] = snap['date']
    _seen_names |= current_names

if late_entrants:
    # Group by entry date
    _by_date = {}
    for n, d in late_entrants.items():
        _by_date.setdefault(d, []).append(n)

    _parts = []
    for d, names in sorted(_by_date.items()):
        names_str = ', '.join(sorted(names))
        _parts.append(f"{names_str} (entraram em {d})")
    _late_str = '; '.join(_parts)

    late_caption = (
        f"âš ï¸ Participantes que entraram apÃ³s o inÃ­cio do confinamento ({_late_str}) "
        f"tÃªm menos dias de dados comparados aos demais participantes que estavam presentes "
        f"desde o inÃ­cio da temporada, e isso pode afetar comparaÃ§Ãµes temporais."
    )
else:
    late_caption = ""

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (Ãºltima do dia) â€” usada para anÃ¡lises de reaÃ§Ãµes
# ReaÃ§Ãµes mudam 1x/dia (no Raio-X da manhÃ£); coletas extras no mesmo dia
# tÃªm reaÃ§Ãµes idÃªnticas mas podem diferir em saldo/papÃ©is.
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)

# Derived daily metrics (optional)
daily_metrics = {}
daily_metrics_map = {}
DAILY_METRICS_FILE = Path("data/derived/daily_metrics.json")
if DAILY_METRICS_FILE.exists():
    with open(DAILY_METRICS_FILE, encoding="utf-8") as f:
        daily_metrics = json.load(f)
    daily_metrics_map = {d.get('date'): d for d in daily_metrics.get('daily', [])}

# Week helper (BBB26 starts 2026-01-13)
def get_week_number(date_str):
    date = datetime.strptime(date_str, '%Y-%m-%d')
    start = datetime(2026, 1, 13)
    delta = (date - start).days
    return max(1, (delta // 7) + 1)

# Manual + derived events (for profiles)
manual_events = {}
MANUAL_EVENTS_FILE = Path("data/manual_events.json")
if MANUAL_EVENTS_FILE.exists():
    with open(MANUAL_EVENTS_FILE, encoding="utf-8") as f:
        manual_events = json.load(f)

auto_events = {}
AUTO_EVENTS_FILE = Path("data/derived/auto_events.json")
if AUTO_EVENTS_FILE.exists():
    with open(AUTO_EVENTS_FILE, encoding="utf-8") as f:
        auto_events = json.load(f)

sincerao_data = {}
SINCERAO_FILE = Path("data/derived/sincerao_edges.json")
if SINCERAO_FILE.exists():
    with open(SINCERAO_FILE, encoding="utf-8") as f:
        sincerao_data = json.load(f)

paredoes_data = {}
PAREDOES_FILE = Path("data/paredoes.json")
if PAREDOES_FILE.exists():
    with open(PAREDOES_FILE, encoding="utf-8") as f:
        paredoes_data = json.load(f)
```

```{python}
#| label: viz-functions
#| include: false

def get_snapshot_for_date(target_date, snapshots_list=None, matrices_list=None):
    """Retorna (snapshot, matrix, index) do snapshot mais prÃ³ximo antes/em target_date."""
    snaps = snapshots_list or snapshots
    mats = matrices_list or all_matrices
    closest_idx = 0
    for i, snap in enumerate(snaps):
        if snap['date'] <= target_date:
            closest_idx = i
    return snaps[closest_idx], mats[closest_idx], closest_idx


def make_sentiment_ranking(participants, matrix, title_suffix="", show_avatars=False, avatars_dict=None, fixed_height=None):
    """Retorna go.Figure com ranking horizontal de sentimento.

    Args:
        fixed_height: If provided, uses this height instead of auto-calculating.
                      Useful for consistent heights across tabsets.
    """
    sentiment_data = []
    for p in participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        score = calc_sentiment(p)
        hearts = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                     if r['label'] == 'CoraÃ§Ã£o')
        neg = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                  if r['label'] != 'CoraÃ§Ã£o')
        member_of = p.get('characteristics', {}).get('memberOf', '?')
        avatar = (avatars_dict or {}).get(name, '') if show_avatars else ''
        sentiment_data.append({
            'name': name, 'score': score, 'hearts': hearts,
            'negative': neg, 'memberOf': member_of, 'avatar': avatar
        })

    df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

    color_map = {name: GROUP_COLORS.get(m, '#999')
                 for name, m in zip(df_sent['name'], df_sent['memberOf'])}

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_sent['name'],
        x=df_sent['score'],
        orientation='h',
        marker_color=[color_map[n] for n in df_sent['name']],
        text=[f"{s:+.1f}" for s in df_sent['score']],
        textposition='outside',
        hovertemplate='%{y}: %{x:+.1f}<br>â¤ï¸: %{customdata[0]} | Neg: %{customdata[1]}<extra></extra>',
        customdata=list(zip(df_sent['hearts'], df_sent['negative'])),
        showlegend=False
    ))

    title = "Ranking de Sentimento"
    if title_suffix:
        title += f" â€” {title_suffix}"

    # Calculate left margin - need more space for avatars
    left_margin = 180 if show_avatars else 150

    # Use fixed height if provided, otherwise auto-calculate
    chart_height = fixed_height if fixed_height else max(500, len(df_sent) * 32)

    fig.update_layout(
        title=title,
        xaxis_title="Score de Sentimento",
        yaxis_title="",
        height=chart_height,
        margin=dict(l=left_margin),
        shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                     line=dict(color='red', dash='dash', width=1))]
    )

    # Add avatar images as layout images (positioned in paper coordinates)
    if show_avatars and avatars_dict:
        images = []
        n_participants = len(df_sent)
        for i, (_, row) in enumerate(df_sent.iterrows()):
            avatar_url = row.get('avatar', '')
            if avatar_url:
                # Position each avatar to the left of the y-axis label
                # y position: map bar index to paper coordinates
                y_pos = i / (n_participants - 1) if n_participants > 1 else 0.5
                images.append(dict(
                    source=avatar_url,
                    xref="paper", yref="paper",
                    x=-0.01, y=y_pos,  # Just left of the chart
                    sizex=0.04, sizey=0.04,  # Size relative to plot
                    xanchor="right", yanchor="middle",
                    layer="above"
                ))
        if images:
            fig.update_layout(images=images)

    for group, color in GROUP_COLORS.items():
        fig.add_trace(go.Scatter(
            x=[None], y=[None], mode='markers',
            marker=dict(size=10, color=color),
            name=group, showlegend=True
        ))

    return fig


def make_cross_table_heatmap(participants, matrix, title_suffix=""):
    """Retorna go.Figure com heatmap da tabela cruzada de reaÃ§Ãµes."""
    active_names_ht = sorted([p['name'] for p in participants
                              if not p.get('characteristics', {}).get('eliminated')])

    heat_data = np.zeros((len(active_names_ht), len(active_names_ht)))
    rxn_labels = []
    for i, giver in enumerate(active_names_ht):
        row_labels = []
        for j, receiver in enumerate(active_names_ht):
            if giver == receiver:
                heat_data[i, j] = np.nan
                row_labels.append('â€”')
            else:
                rxn = matrix.get((giver, receiver), '')
                weight = SENTIMENT_WEIGHTS.get(rxn, 0)
                heat_data[i, j] = weight
                emoji = REACTION_EMOJI.get(rxn, '?')
                row_labels.append(emoji)
        rxn_labels.append(row_labels)

    short_names = [n.split()[0] if len(n) > 12 else n for n in active_names_ht]

    fig = go.Figure(data=go.Heatmap(
        z=heat_data,
        x=short_names,
        y=short_names,
        colorscale=[
            [0, '#d73027'],
            [0.25, '#fc8d59'],
            [0.5, '#ffffbf'],
            [1.0, '#1a9850'],
        ],
        zmin=-1, zmax=1,
        text=[[rxn_labels[i][j] for j in range(len(active_names_ht))] for i in range(len(active_names_ht))],
        texttemplate='%{text}',
        textfont=dict(size=14),
        hovertemplate='%{y} â†’ %{x}: %{text}<extra></extra>',
        colorbar=dict(title="Sentimento", tickvals=[-1, -0.5, 0, 1],
                      ticktext=['Forte Neg', 'Leve Neg', 'Neutro', 'Positivo'])
    ))

    title = "Mapa de ReaÃ§Ãµes"
    if title_suffix:
        title += f" â€” {title_suffix}"

    fig.update_layout(
        title=title,
        xaxis_title="Receptor â†",
        yaxis_title="Emissor â†’",
        height=750,
        xaxis=dict(tickangle=45, side='bottom'),
        yaxis=dict(autorange='reversed')
    )

    return fig


def make_cross_table_html(participants, matrix, title_suffix=""):
    """Retorna HTML string com tabela cruzada de reaÃ§Ãµes (sticky header/column)."""
    active_names = sorted([p['name'] for p in participants
                           if not p.get('characteristics', {}).get('eliminated')])

    short_names = [n.split()[0] if len(n) > 10 else n for n in active_names]

    # Color mapping based on sentiment
    def get_cell_style(rxn):
        if not rxn:
            return "background: #444; color: #888;"
        weight = SENTIMENT_WEIGHTS.get(rxn, 0)
        if weight == 1:  # Positive
            return "background: #1a9850; color: #fff;"
        elif weight == -0.5:  # Mild negative
            return "background: #fc8d59; color: #000;"
        elif weight == -1:  # Strong negative
            return "background: #d73027; color: #fff;"
        return "background: #ffffbf; color: #000;"

    # Build HTML table
    html = []
    html.append(f'''
<div style="overflow-x: auto; max-width: 100%;">
<style>
.cross-table {{
    border-collapse: separate;
    border-spacing: 0;
    font-size: 0.85rem;
    width: max-content;
}}
.cross-table th, .cross-table td {{
    padding: 4px 6px;
    text-align: center;
    border: 1px solid #555;
    min-width: 36px;
    white-space: nowrap;
}}
.cross-table thead th {{
    position: sticky;
    top: 0;
    background: #222;
    z-index: 2;
    font-weight: bold;
}}
.cross-table tbody th {{
    position: sticky;
    left: 0;
    background: #222;
    z-index: 1;
    font-weight: bold;
    text-align: right;
}}
.cross-table thead th:first-child {{
    z-index: 3;
    left: 0;
}}
.cross-table td {{ font-size: 1.1rem; }}
.cross-table td:hover {{ outline: 2px solid #fff; }}
</style>
<table class="cross-table">
<thead>
<tr>
<th style="background: #222;">â†“ deu / recebeu â†’</th>
''')

    # Header row with receiver names
    for short in short_names:
        html.append(f'<th>{short}</th>')
    html.append('</tr></thead><tbody>')

    # Data rows
    for i, giver in enumerate(active_names):
        html.append(f'<tr><th>{short_names[i]}</th>')
        for j, receiver in enumerate(active_names):
            if giver == receiver:
                html.append('<td style="background: #333; color: #666;">â€”</td>')
            else:
                rxn = matrix.get((giver, receiver), '')
                emoji = REACTION_EMOJI.get(rxn, '?') if rxn else '?'
                style = get_cell_style(rxn)
                tooltip = f"{giver} â†’ {receiver}: {rxn or 'N/A'}"
                html.append(f'<td style="{style}" title="{tooltip}">{emoji}</td>')
        html.append('</tr>')

    html.append('</tbody></table></div>')

    return '\n'.join(html)


def make_reaction_summary_html(participants, collapsed_rows=5):
    """Retorna HTML com tabela de reaÃ§Ãµes recebidas, colapsÃ¡vel com cores."""
    summary_rows = []
    for p in sorted(participants, key=lambda x: calc_sentiment(x), reverse=True):
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        rxn_counts = {}
        for rxn in p.get('characteristics', {}).get('receivedReactions', []):
            emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
            rxn_counts[emoji] = rxn['amount']
        score = calc_sentiment(p)
        summary_rows.append({
            'name': name,
            'hearts': rxn_counts.get('â¤ï¸', 0),
            'planta': rxn_counts.get('ğŸŒ±', 0),
            'mala': rxn_counts.get('ğŸ’¼', 0),
            'biscoito': rxn_counts.get('ğŸª', 0),
            'cobra': rxn_counts.get('ğŸ', 0),
            'alvo': rxn_counts.get('ğŸ¯', 0),
            'vomito': rxn_counts.get('ğŸ¤®', 0),
            'mentiroso': rxn_counts.get('ğŸ¤¥', 0),
            'coracao_partido': rxn_counts.get('ğŸ’”', 0),
            'score': score
        })

    n_total = len(summary_rows)
    n_active = len([p for p in participants if not p.get('characteristics', {}).get('eliminated')])

    # Calculate max values for color scaling
    max_hearts = max((r['hearts'] for r in summary_rows), default=1)
    max_neg = max((r['cobra'] + r['alvo'] + r['vomito'] + r['mentiroso'] for r in summary_rows), default=1)

    def heart_color(val):
        if val == 0: return "color: #666;"
        intensity = min(val / max_hearts, 1)
        if intensity > 0.7: return "background: #1a9850; color: #fff; font-weight: bold;"
        if intensity > 0.4: return "background: #91cf60; color: #000;"
        return "color: #a6d96a;"

    def neg_color(val):
        if val == 0: return "color: #666;"
        if val >= 3: return "background: #d73027; color: #fff; font-weight: bold;"
        if val >= 2: return "background: #fc8d59; color: #000;"
        return "color: #fdae61;"

    def score_color(val):
        if val >= 10: return "background: #1a9850; color: #fff; font-weight: bold;"
        if val >= 5: return "color: #66bd63;"
        if val >= 0: return "color: #a6d96a;"
        if val >= -5: return "color: #fdae61;"
        if val >= -10: return "color: #f46d43;"
        return "background: #d73027; color: #fff; font-weight: bold;"

    html = []
    html.append(f'''
<style>
.summary-table {{
    border-collapse: collapse;
    font-size: 0.85rem;
    width: 100%;
}}
.summary-table th, .summary-table td {{
    padding: 6px 8px;
    text-align: center;
    border-bottom: 1px solid #444;
}}
.summary-table th {{
    background: #222;
    position: sticky;
    top: 0;
    z-index: 1;
}}
.summary-table th:first-child, .summary-table td:first-child {{
    text-align: left;
    position: sticky;
    left: 0;
    background: #222;
    z-index: 2;
}}
.summary-table thead th:first-child {{ z-index: 3; }}
.summary-table tbody tr:hover {{ background: #333; }}
.collapsed-rows {{ display: none; }}
.expand-btn {{
    display: block;
    width: 100%;
    padding: 10px;
    margin-top: 8px;
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 6px;
    color: #ccc;
    cursor: pointer;
    font-size: 0.9rem;
}}
.expand-btn:hover {{ background: #333; }}
</style>
<div style="overflow-x: auto; max-width: 100%;">
<table class="summary-table" id="reaction-summary-table">
<thead>
<tr>
<th>Participante</th>
<th>â¤ï¸</th>
<th>ğŸŒ±</th>
<th>ğŸ’¼</th>
<th>ğŸª</th>
<th>ğŸ</th>
<th>ğŸ¯</th>
<th>ğŸ¤®</th>
<th>ğŸ¤¥</th>
<th>ğŸ’”</th>
<th>Score</th>
</tr>
</thead>
<tbody>
''')

    for i, r in enumerate(summary_rows):
        row_class = 'collapsed-rows' if i >= collapsed_rows else ''
        html.append(f'<tr class="{row_class}">')
        html.append(f'<td>{r["name"]}</td>')
        html.append(f'<td style="{heart_color(r["hearts"])}">{r["hearts"]}</td>')
        html.append(f'<td style="{neg_color(r["planta"])}">{r["planta"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["mala"])}">{r["mala"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["biscoito"])}">{r["biscoito"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["cobra"])}">{r["cobra"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["alvo"])}">{r["alvo"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["vomito"])}">{r["vomito"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["mentiroso"])}">{r["mentiroso"] or "Â·"}</td>')
        html.append(f'<td style="{neg_color(r["coracao_partido"])}">{r["coracao_partido"] or "Â·"}</td>')
        html.append(f'<td style="{score_color(r["score"])}">{r["score"]:+.1f}</td>')
        html.append('</tr>')

    html.append('</tbody></table></div>')

    if n_total > collapsed_rows:
        html.append(f'''
<button class="expand-btn" onclick="
    var rows = document.querySelectorAll('.collapsed-rows');
    var btn = this;
    if (btn.dataset.expanded === 'true') {{
        rows.forEach(r => r.style.display = 'none');
        btn.innerHTML = 'â–¼ Ver todos os {n_total} participantes';
        btn.dataset.expanded = 'false';
    }} else {{
        rows.forEach(r => r.style.display = 'table-row');
        btn.innerHTML = 'â–² Mostrar menos';
        btn.dataset.expanded = 'true';
    }}
" data-expanded="false">â–¼ Ver todos os {n_total} participantes</button>
''')

    return '\n'.join(html)


def make_negative_givers_chart(participants, matrix, title_suffix=""):
    """Retorna go.Figure com perfil de emissÃ£o de reaÃ§Ãµes (â¤ï¸ vs negativos)."""
    active_ns = sorted([p['name'] for p in participants
                        if not p.get('characteristics', {}).get('eliminated')])

    giver_data = []
    for name in active_ns:
        pos_given = 0
        neg_given = 0
        for receiver in active_ns:
            if name == receiver:
                continue
            rxn = matrix.get((name, receiver), '')
            if rxn in POSITIVE:
                pos_given += 1
            elif rxn:
                neg_given += 1

        total = pos_given + neg_given
        neg_pct = (neg_given / total * 100) if total > 0 else 0

        giver_data.append({
            'Participante': name,
            'â¤ï¸ dados': pos_given,
            'Negativos dados': neg_given,
            '% Negativo': round(neg_pct, 1),
            'Grupo': MEMBER_OF.get(name, '?')
        })

    df_givers = pd.DataFrame(giver_data).sort_values('% Negativo', ascending=True)

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_givers['Participante'],
        x=df_givers['â¤ï¸ dados'],
        name='â¤ï¸ dados',
        orientation='h',
        marker_color='#1a9850'
    ))
    fig.add_trace(go.Bar(
        y=df_givers['Participante'],
        x=df_givers['Negativos dados'],
        name='Negativos dados',
        orientation='h',
        marker_color='#d73027'
    ))

    title = "Perfil de EmissÃ£o: Quem DÃ¡ Mais â¤ï¸ vs Negatividade?"
    if title_suffix:
        title += f" â€” {title_suffix}"

    fig.update_layout(
        title=title,
        xaxis_title="Quantidade de reaÃ§Ãµes dadas",
        yaxis_title="",
        barmode='stack',
                height=max(500, len(df_givers) * 25),
        margin=dict(l=150)
    )

    return fig
```

```{python}
#| label: compute-highlights
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DESTAQUES DO DIA - Auto-generated highlights answering "What changed today?"
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from datetime import datetime

highlights = []

if len(daily_snapshots) >= 2:
    today = daily_snapshots[-1]
    yesterday = daily_snapshots[-2]
    today_mat = daily_matrices[-1]
    yesterday_mat = daily_matrices[-2]

    # Get active participants for today
    today_active = [p for p in today['participants']
                    if not p.get('characteristics', {}).get('eliminated')]
    today_names = set(p['name'] for p in today_active)

    # 1. Top participant + check if leading for multiple days
    sentiment_today = {p['name']: calc_sentiment(p) for p in today_active}
    if sentiment_today:
        leader_name = max(sentiment_today, key=sentiment_today.get)
        leader_score = sentiment_today[leader_name]

        # Count consecutive days leading
        streak = 1
        for i in range(len(daily_snapshots) - 2, -1, -1):
            snap = daily_snapshots[i]
            snap_active = [p for p in snap['participants']
                           if not p.get('characteristics', {}).get('eliminated')]
            if not snap_active:
                break
            snap_sent = {p['name']: calc_sentiment(p) for p in snap_active}
            if snap_sent and max(snap_sent, key=snap_sent.get) == leader_name:
                streak += 1
            else:
                break

        streak_text = f" pelo {streak}Âº dia consecutivo" if streak > 1 else ""
        highlights.append(f"ğŸ† **{leader_name}** lidera o [ranking](#ranking){streak_text} ({leader_score:+.1f})")

    # 2. Total reactions changed
    common_pairs = set(today_mat.keys()) & set(yesterday_mat.keys())
    changes = [(pair, yesterday_mat[pair], today_mat[pair])
               for pair in common_pairs if yesterday_mat[pair] != today_mat[pair]]
    n_changes = len(changes)

    if n_changes > 0:
        total_possible = len(common_pairs)
        pct_changed = n_changes / total_possible * 100 if total_possible > 0 else 0
        highlights.append(f"ğŸ“Š **{n_changes} reaÃ§Ãµes** [mudaram](mudancas.html) ontem ({pct_changed:.0f}% do total)")

    # 3. Biggest single change (prioritize dramatic shifts)
    dramatic_changes = []
    for pair, old_rxn, new_rxn in changes:
        giver, receiver = pair
        old_pos = old_rxn in POSITIVE
        new_pos = new_rxn in POSITIVE
        old_strong_neg = old_rxn in STRONG_NEGATIVE
        new_strong_neg = new_rxn in STRONG_NEGATIVE

        # Dramatic: heart to strong negative or vice versa
        if old_pos and new_strong_neg:
            emoji_new = REACTION_EMOJI.get(new_rxn, '?')
            dramatic_changes.append((giver, receiver, 'â¤ï¸', emoji_new, 'heart_to_snake'))
        elif old_strong_neg and new_pos:
            emoji_old = REACTION_EMOJI.get(old_rxn, '?')
            dramatic_changes.append((giver, receiver, emoji_old, 'â¤ï¸', 'snake_to_heart'))

    if dramatic_changes:
        giver, receiver, old_e, new_e, _ = dramatic_changes[0]
        giver_short = giver.split()[0]
        receiver_short = receiver.split()[0]
        highlights.append(f"ğŸ’¥ [Maior mudanÃ§a](mudancas.html): **{giver_short}** â†’ **{receiver_short}** (de {old_e} para {new_e})")

    # 4. New one-sided hostilities
    new_hostilities = []
    for pair, old_rxn, new_rxn in changes:
        giver, receiver = pair
        # Check if giver now dislikes receiver, but receiver likes giver
        new_is_neg = new_rxn not in POSITIVE and new_rxn != ''
        old_is_pos = old_rxn in POSITIVE
        receiver_likes_giver = today_mat.get((receiver, giver), '') in POSITIVE

        if old_is_pos and new_is_neg and receiver_likes_giver:
            new_hostilities.append((giver, receiver, new_rxn))

    if new_hostilities:
        highlights.append(f"âš ï¸ **{len(new_hostilities)}** [nova(s) hostilidade(s)](trajetoria.html#hostilidades-dia) unilateral(is) surgiram")

# 5. ParedÃ£o status (from latest snapshot)
paredao_check = []
for p in latest['participants']:
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    if 'ParedÃ£o' in roles:
        paredao_check.append(p['name'])

if paredao_check:
    names_str = ", ".join(sorted(paredao_check))
    highlights.append(f"ğŸ—³ï¸ [**ParedÃ£o ativo**](paredao.html): {names_str}")

# Format the date
try:
    date_obj = datetime.strptime(latest['date'], '%Y-%m-%d')
    date_display_pt = date_obj.strftime('%d de %B').replace('January', 'Janeiro').replace('February', 'Fevereiro').replace('March', 'MarÃ§o').replace('April', 'Abril').replace('May', 'Maio').replace('June', 'Junho').replace('July', 'Julho').replace('August', 'Agosto').replace('September', 'Setembro').replace('October', 'Outubro').replace('November', 'Novembro').replace('December', 'Dezembro')
except:
    date_display_pt = latest['date']

# Output the highlights callout
if highlights:
    print(f'''
::: {{.callout-tip title="Destaques do Dia ({date_display_pt})" appearance="simple"}}
''')
    for h in highlights:
        print(f"- {h}")
    print('''
:::
''')
else:
    print(f'''
::: {{.callout-note title="Destaques do Dia ({date_display_pt})" appearance="simple"}}
Primeiro dia de dados â€” sem comparaÃ§Ãµes disponÃ­veis ainda.
:::
''')
```

# VisÃ£o Geral {#visao-geral}

```{python}
#| label: overview-stats
#| output: asis

active = [p for p in latest['participants'] if not p.get('characteristics', {}).get('eliminated')]
n_active = len(active)
active_names = set(p['name'] for p in active)

# Contar por grupo
groups = Counter(p.get('characteristics', {}).get('memberOf', '?') for p in active)

# Contar reaÃ§Ãµes por tipo
total_reactions = 0
total_hearts = 0
total_negative = 0
for p in active:
    for rxn in p.get('characteristics', {}).get('receivedReactions', []):
        amt = rxn.get('amount', 0)
        total_reactions += amt
        if rxn.get('label') == 'CoraÃ§Ã£o':
            total_hearts += amt
        else:
            total_negative += amt

# â”€â”€ Calculate hostility metrics for "game temperature" â”€â”€
n_two_sided = 0      # Mutual enemies (both hate each other)
n_one_sided = 0      # False friends (A hates B, but B gives â¤ï¸)
blind_spot_victims = set()   # People who give â¤ï¸ to enemies
attackers = set()            # People who attack those who love them

checked_pairs = set()
for (a, b), rxn_a_to_b in latest_matrix.items():
    if a not in active_names or b not in active_names:
        continue

    rxn_b_to_a = latest_matrix.get((b, a), '')
    a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
    b_dislikes_a = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''
    b_likes_a = rxn_b_to_a in POSITIVE

    pair = frozenset([a, b])

    if a_dislikes_b and b_dislikes_a:
        if pair not in checked_pairs:
            n_two_sided += 1
            checked_pairs.add(pair)
    elif a_dislikes_b and b_likes_a:
        n_one_sided += 1
        attackers.add(a)       # A attacks someone who loves them
        blind_spot_victims.add(b)  # B gives â¤ï¸ to an enemy

n_blind_spots = len(blind_spot_victims)
n_attackers = len(attackers)

# Check for paredÃ£o
paredao_names = []
for p in latest['participants']:
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    if 'ParedÃ£o' in roles:
        paredao_names.append(p['name'])

# Format date
from datetime import datetime
try:
    date_obj = datetime.strptime(latest['date'], '%Y-%m-%d')
    date_display = date_obj.strftime('%d/%m')
except:
    date_display = latest['date']

# KPI Value Boxes - Two rows with explanations
print(f'''
<div style="display: flex; flex-wrap: wrap; gap: 0.8rem; margin: 1.5rem 0;">

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_active}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">Participantes</div>
</div>

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{total_hearts}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">â¤ï¸ CoraÃ§Ãµes</div>
</div>

<div style="flex: 1 1 150px; min-width: 120px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3);">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{total_negative}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">Negativos</div>
</div>

<a href="trajetoria.html#hostilidades-dia" style="flex: 1 1 150px; min-width: 120px; text-decoration: none;">
<div style="background: linear-gradient(135deg, #d73027 0%, #a50026 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3); cursor: pointer; height: 100%; box-sizing: border-box;">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_two_sided}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">âš”ï¸ Inimigos</div>
<div style="font-size: 0.65rem; color: rgba(255,255,255,0.6); margin-top: 0.2rem;">pares mÃºtuos</div>
</div>
</a>

<a href="trajetoria.html#hostilidades-dia" style="flex: 1 1 150px; min-width: 120px; text-decoration: none;">
<div style="background: linear-gradient(135deg, #f39c12 0%, #d68910 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3); cursor: pointer; height: 100%; box-sizing: border-box;">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_one_sided}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">ğŸ­ Falsos Amigos</div>
<div style="font-size: 0.65rem; color: rgba(255,255,255,0.6); margin-top: 0.2rem;">A detesta B, B dÃ¡ â¤ï¸</div>
</div>
</a>

<a href="trajetoria.html#hostilidades-dia" style="flex: 1 1 150px; min-width: 120px; text-decoration: none;">
<div style="background: linear-gradient(135deg, #8e44ad 0%, #6c3483 100%); border-radius: 10px; padding: 1rem; text-align: center; box-shadow: 0 3px 6px rgba(0,0,0,0.3); cursor: pointer; height: 100%; box-sizing: border-box;">
<div style="font-size: 2rem; font-weight: bold; color: #fff;">{n_blind_spots}</div>
<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); text-transform: uppercase;">ğŸ‘ï¸ Pontos Cegos</div>
<div style="font-size: 0.65rem; color: rgba(255,255,255,0.6); margin-top: 0.2rem;">dÃ£o â¤ï¸ a inimigos</div>
</div>
</a>

</div>

<p class="text-muted small" style="margin-top: 0.3rem; text-align: center;">ğŸ“… Dados de <strong>{date_display}</strong> â€” {n_daily} dias de histÃ³rico</p>
''')
```

```{python}
#| label: paredao-status-card
#| output: asis

# ParedÃ£o Status Card - shows current paredÃ£o state
paredao_names = []
for p in latest['participants']:
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    if 'ParedÃ£o' in roles:
        paredao_names.append(p['name'])

if paredao_names:
    status_text = "Em VotaÃ§Ã£o"
    status_color = "#e74c3c"
    status_icon = "ğŸ—³ï¸"
    names_display = ", ".join(sorted(paredao_names))
    emparedados_html = f'<div style="color: #ccc; font-size: 0.95rem;">Emparedados: <strong>{names_display}</strong></div>'
else:
    status_text = "Aguardando formaÃ§Ã£o"
    status_color = "#6c757d"
    status_icon = "â³"
    emparedados_html = '<div style="color: #888; font-size: 0.9rem;">Nenhum paredÃ£o ativo no momento</div>'

print(f'''
<div style="background: #2a2a2a; border-radius: 12px; padding: 1rem 1.2rem; margin: 1rem 0 1.5rem 0; border-left: 4px solid {status_color}; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
<div>
<div style="font-size: 1.1rem; font-weight: bold; color: #fff; margin-bottom: 0.3rem;">
{status_icon} ParedÃ£o: <span style="color: {status_color};">{status_text}</span>
</div>
{emparedados_html}
</div>
<a href="paredao.html" style="background: {status_color}; color: #fff; padding: 0.5rem 1rem; border-radius: 6px; text-decoration: none; font-weight: 500; font-size: 0.9rem; white-space: nowrap;">
Ver anÃ¡lise â†’
</a>
</div>
''')
```

::: {.callout-warning title="ğŸ—³ï¸ ParedÃ£o"}
Para acompanhar o **paredÃ£o atual** (formaÃ§Ã£o, votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia entre reaÃ§Ãµes e votos), acesse a pÃ¡gina dedicada: **[ParedÃ£o](paredao.html)**

Para ver o **histÃ³rico de paredÃµes anteriores**, acesse: **[Arquivo de ParedÃµes](paredoes.html)**
:::

```{python}
#| label: watchlist-risco
#| output: asis

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WATCHLIST DE RISCO â€” Top 5 most vulnerable participants
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from collections import Counter

def get_vulnerability_data(matrix, active_names):
    """Calculate who gives â¤ï¸ to enemies and who attacks friends."""
    loving_victim = Counter()  # Who gives â¤ï¸ to people who hate them
    hostile_giver = Counter()  # Who attacks people who love them
    blind_spots = {}           # {victim: [list of attackers who receive â¤ï¸]}

    for (a, b), rxn_a_to_b in matrix.items():
        if a not in active_names or b not in active_names:
            continue

        rxn_b_to_a = matrix.get((b, a), '')
        a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
        b_likes_a = rxn_b_to_a in POSITIVE

        # A dislikes B, but B gives A a â¤ï¸
        if a_dislikes_b and b_likes_a:
            hostile_giver[a] += 1   # A is attacking someone who loves them
            loving_victim[b] += 1   # B gives â¤ï¸ to an enemy
            # Track who B's attackers are
            if b not in blind_spots:
                blind_spots[b] = []
            blind_spots[b].append(a)

    return loving_victim, hostile_giver, blind_spots

active_for_watchlist = set(p['name'] for p in latest['participants']
                           if not p.get('characteristics', {}).get('eliminated'))

loving_victim, hostile_giver, blind_spots = get_vulnerability_data(latest_matrix, active_for_watchlist)

# Calculate vulnerability scores: â¤ï¸ given to enemies / (attacks on friends + 1)
vulnerability_scores = []
for name in loving_victim:
    hearts_to_enemies = loving_victim[name]
    attacks_on_friends = hostile_giver.get(name, 0)
    ratio = hearts_to_enemies / (attacks_on_friends + 1)
    vulnerability_scores.append({
        'name': name,
        'hearts_to_enemies': hearts_to_enemies,
        'attacks_on_friends': attacks_on_friends,
        'ratio': ratio,
        'grupo': MEMBER_OF.get(name, '?'),
        'attackers': blind_spots.get(name, [])
    })

# Sort by vulnerability ratio, take top 5
top_vulnerable = sorted(vulnerability_scores, key=lambda x: (-x['ratio'], -x['hearts_to_enemies']))[:5]

if top_vulnerable:
    print('''
# Watchlist de Risco {#watchlist}

Participantes com **pontos cegos** â€” dÃ£o â¤ï¸ para quem os detesta. Podem ser surpreendidos em votaÃ§Ãµes.

<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin: 1.5rem 0;">
''')

    for i, p in enumerate(top_vulnerable):
        # Color by risk level
        if p['ratio'] >= 3:
            border_color = '#e74c3c'  # Red - high risk
            risk_label = 'Alto Risco'
        elif p['ratio'] >= 2:
            border_color = '#f39c12'  # Orange - medium risk
            risk_label = 'Risco MÃ©dio'
        else:
            border_color = '#f1c40f'  # Yellow - watch
            risk_label = 'AtenÃ§Ã£o'

        grupo_color = GROUP_COLORS.get(p['grupo'], '#666')
        avatar_url = AVATARS.get(p['name'], '')

        # Show up to 3 attackers
        attackers_display = ', '.join(p['attackers'][:3])
        if len(p['attackers']) > 3:
            attackers_display += f' +{len(p["attackers"]) - 3}'

        print(f'''
<div style="background: #2a2a2a; border-radius: 10px; border-left: 4px solid {border_color}; padding: 1rem; display: flex; gap: 0.8rem; align-items: flex-start;">
<div style="flex-shrink: 0;">
<img src="{avatar_url}" alt="{p['name']}" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid {grupo_color}; object-fit: cover;">
</div>
<div style="flex: 1; min-width: 0;">
<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.3rem;">
<span style="font-weight: bold; color: #fff; font-size: 1rem;">{p['name']}</span>
<span style="background: {border_color}; color: #fff; padding: 0.15rem 0.5rem; border-radius: 4px; font-size: 0.7rem; text-transform: uppercase;">{risk_label}</span>
</div>
<div style="color: #aaa; font-size: 0.8rem; margin-top: 0.4rem;">
DÃ¡ â¤ï¸ para <strong style="color: #e74c3c;">{p['hearts_to_enemies']}</strong> {('pessoa que o detesta' if p['hearts_to_enemies'] == 1 else 'pessoas que o detestam')}
</div>
<div style="color: #888; font-size: 0.75rem; margin-top: 0.3rem;">
ğŸ‘ï¸ Pontos cegos: <span style="color: #ccc;">{attackers_display}</span>
</div>
</div>
</div>
''')

    print('</div>')
    print(f'\n<p style="text-align: center; margin-top: 0.5rem;"><a href="trajetoria.html#hostilidades-dia" style="color: #6ea8fe; font-size: 0.85rem;">Ver anÃ¡lise completa â†’</a></p>')
else:
    print("*Nenhum participante com pontos cegos detectado.*")
```

# Ranking de Sentimento {#ranking}

Cada participante recebe reaÃ§Ãµes dos demais. O **score de sentimento** pondera: â¤ï¸ = +1, reaÃ§Ãµes leves (ğŸŒ±ğŸ’¼ğŸª) = -0.5, reaÃ§Ãµes fortes (ğŸğŸ¯ğŸ¤®ğŸ¤¥ğŸ’”) = -1.

```{python}
#| label: ranking-prep
#| include: false

# Pre-calculate data for ranking tabs
_n_today = len([p for p in latest['participants']
                if not p.get('characteristics', {}).get('eliminated')])
_ranking_height = max(500, _n_today * 32)

# Calculate sentiment scores for today
today_scores = {}
for p in latest['participants']:
    if not p.get('characteristics', {}).get('eliminated'):
        today_scores[p['name']] = {
            'score': calc_sentiment(p),
            'group': p.get('characteristics', {}).get('memberOf', '?')
        }

# Calculate yesterday scores (if available)
yesterday_scores = {}
if n_daily >= 2:
    yesterday = daily_snapshots[-2]
    for p in yesterday['participants']:
        if not p.get('characteristics', {}).get('eliminated'):
            yesterday_scores[p['name']] = calc_sentiment(p)

# Calculate 7-days-ago scores (if available)
week_ago_scores = {}
if n_daily >= 7:
    week_ago = daily_snapshots[-7]
    for p in week_ago['participants']:
        if not p.get('characteristics', {}).get('eliminated'):
            week_ago_scores[p['name']] = calc_sentiment(p)


def make_sentiment_change_table(today_scores, past_scores, period_label):
    """Create HTML table showing sentiment changes with colors."""
    if not past_scores:
        return f"<p class='text-muted'>Dados insuficientes para comparaÃ§Ã£o de {period_label}.</p>"

    # Calculate changes
    rows = []
    for name, data in today_scores.items():
        today_score = data['score']
        group = data['group']
        past_score = past_scores.get(name)

        if past_score is not None:
            delta = today_score - past_score
            rows.append({
                'name': name,
                'group': group,
                'past': past_score,
                'today': today_score,
                'delta': delta
            })

    # Sort by delta descending (biggest gainers first)
    rows.sort(key=lambda x: -x['delta'])

    # Build HTML table
    html = '''
<div style="max-height: 500px; overflow-y: auto; border-radius: 8px; border: 1px solid #444;">
<table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
<thead style="position: sticky; top: 0; background: #2a2a2a; z-index: 1;">
<tr style="border-bottom: 2px solid #555;">
<th style="padding: 0.6rem; text-align: left; color: #ccc;">Participante</th>
<th style="padding: 0.6rem; text-align: center; color: #ccc;">Antes</th>
<th style="padding: 0.6rem; text-align: center; color: #ccc;">Hoje</th>
<th style="padding: 0.6rem; text-align: center; color: #ccc;">Î”</th>
</tr>
</thead>
<tbody>
'''

    for row in rows:
        # Color for delta
        if row['delta'] > 1:
            delta_color = '#27ae60'  # Green
            delta_bg = 'rgba(39, 174, 96, 0.2)'
        elif row['delta'] > 0:
            delta_color = '#58d68d'  # Light green
            delta_bg = 'rgba(88, 214, 141, 0.1)'
        elif row['delta'] < -1:
            delta_color = '#e74c3c'  # Red
            delta_bg = 'rgba(231, 76, 60, 0.2)'
        elif row['delta'] < 0:
            delta_color = '#ec7063'  # Light red
            delta_bg = 'rgba(236, 112, 99, 0.1)'
        else:
            delta_color = '#888'
            delta_bg = 'transparent'

        # Arrow emoji
        if row['delta'] > 0:
            arrow = 'ğŸ“ˆ'
        elif row['delta'] < 0:
            arrow = 'ğŸ“‰'
        else:
            arrow = 'â–'

        # Group color dot
        group_color = GROUP_COLORS.get(row['group'], '#666')

        html += f'''
<tr style="border-bottom: 1px solid #333; background: {delta_bg};">
<td style="padding: 0.5rem;"><span style="color: {group_color}; margin-right: 0.3rem;">â—</span>{row['name']}</td>
<td style="padding: 0.5rem; text-align: center; color: #aaa;">{row['past']:+.1f}</td>
<td style="padding: 0.5rem; text-align: center; font-weight: 500;">{row['today']:+.1f}</td>
<td style="padding: 0.5rem; text-align: center; color: {delta_color}; font-weight: bold;">{arrow} {row['delta']:+.1f}</td>
</tr>
'''

    html += '</tbody></table></div>'
    return html
```

::: {.panel-tabset}

## Hoje

```{python}
#| label: sentiment-ranking-today

fig = make_sentiment_ranking(latest['participants'], latest_matrix, title_suffix=latest['label'], fixed_height=_ranking_height)
fig.show()
```

## Ontemâ†’Hoje

```{python}
#| label: sentiment-yesterday-today
#| output: asis

if n_daily >= 2:
    yesterday_label = daily_snapshots[-2]['label']
    print(f"<p class='text-muted small'>MudanÃ§as de <strong>{yesterday_label}</strong> para <strong>{latest['label']}</strong></p>")
    print(make_sentiment_change_table(today_scores, yesterday_scores, "ontem"))
else:
    print("<p class='text-muted'>Dados insuficientes (apenas 1 dia disponÃ­vel).</p>")
```

## Em 7 dias

```{python}
#| label: sentiment-7d-change
#| output: asis

if n_daily >= 7:
    week_ago_label = daily_snapshots[-7]['label']
    print(f"<p class='text-muted small'>MudanÃ§as de <strong>{week_ago_label}</strong> para <strong>{latest['label']}</strong></p>")
    print(make_sentiment_change_table(today_scores, week_ago_scores, "7 dias"))
else:
    print(f"<p class='text-muted'>Dados insuficientes (apenas {n_daily} dias disponÃ­veis).</p>")
```

## EvoluÃ§Ã£o

```{python}
#| label: sentiment-evolution
#| output: asis

# Build timeline data for sentiment evolution chart
timeline_data = []
if daily_metrics_map:
    for date_str in sorted(daily_metrics_map.keys()):
        entry = daily_metrics_map[date_str]
        for name, score in entry.get('sentiment', {}).items():
            timeline_data.append({
                'Data': pd.to_datetime(date_str),
                'Participante': name,
                'Sentimento': score,
                'Grupo': MEMBER_OF.get(name, '?')
            })
else:
    for snap in daily_snapshots:
        for p in snap['participants']:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            name = p['name']
            score = calc_sentiment(p)
            timeline_data.append({
                'Data': pd.to_datetime(snap['date']),
                'Participante': name,
                'Sentimento': score,
                'Grupo': p.get('characteristics', {}).get('memberOf', '?')
            })

df_timeline = pd.DataFrame(timeline_data)

if not df_timeline.empty and len(df_timeline['Data'].unique()) > 1:
    # Color palette for participants
    all_parts = sorted(df_timeline['Participante'].unique())
    palette = (
        px.colors.qualitative.Plotly + px.colors.qualitative.D3 +
        px.colors.qualitative.Set2 + px.colors.qualitative.Bold
    )
    part_colors = {name: palette[i % len(palette)] for i, name in enumerate(all_parts)}

    # Top 3 and bottom 3 by latest score - visible by default
    latest_scores_df = df_timeline.groupby('Participante')['Sentimento'].last()
    top3 = set(latest_scores_df.nlargest(3).index)
    bottom3 = set(latest_scores_df.nsmallest(3).index)
    highlight = top3 | bottom3

    fig = go.Figure()

    for name in all_parts:
        df_p = df_timeline[df_timeline['Participante'] == name].sort_values('Data')
        is_hl = name in highlight

        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Sentimento'],
            mode='lines+markers',
            name=name,
            line=dict(width=3 if is_hl else 1.5, color=part_colors[name]),
            marker=dict(size=6 if is_hl else 4),
            hovertemplate=f'{name}: ' + '%{y:+.1f}<extra></extra>',
            visible=True if is_hl else 'legendonly',
        ))

    # Zero line
    fig.add_shape(type='line', x0=df_timeline['Data'].min(), x1=df_timeline['Data'].max(),
                  y0=0, y1=0, line=dict(color='red', dash='dash', width=1))

    # ParedÃ£o date lines (load from paredoes.json)
    paredoes_file = Path("data/paredoes.json")
    if paredoes_file.exists():
        with open(paredoes_file, encoding="utf-8") as f:
            paredoes_data = json.load(f)
        for p in paredoes_data.get('paredoes', []):
            paredao_date = pd.to_datetime(p['data'])
            y_range = [df_timeline['Sentimento'].min() - 2, df_timeline['Sentimento'].max() + 2]
            fig.add_shape(
                type='line', x0=paredao_date, x1=paredao_date,
                y0=y_range[0], y1=y_range[1],
                line=dict(color='#FF6B6B', dash='dot', width=2),
            )
            # Add annotation
            fig.add_annotation(
                x=paredao_date, y=y_range[1],
                text=f"ğŸ—³ï¸ {p['numero']}Âº ParedÃ£o",
                showarrow=False,
                font=dict(size=11, color='#FF6B6B'),
                yshift=10,
            )

    fig.update_layout(
        title="EvoluÃ§Ã£o do Sentimento ao Longo do Tempo",
        xaxis_title="Data",
        yaxis_title="Score de Sentimento",
        height=_ranking_height,  # Same height as Ranking tabs
        hovermode='x unified',
        legend=dict(font=dict(size=11), itemsizing='constant'),
        margin=dict(r=180),  # More room for legend
    )

    fig.show()

    print("<p class='text-muted small' style='margin-top: 0.5rem;'>Top 3 e bottom 3 destacados por padrÃ£o. Clique na legenda para mostrar/esconder outros participantes.</p>")
else:
    print("<p class='text-muted'>Dados insuficientes para grÃ¡fico de evoluÃ§Ã£o.</p>")
```

:::

# Tabela Cruzada de ReaÃ§Ãµes {#crosstable}

<p class="text-muted small">ğŸ“¸ <strong>Dado do dia</strong> â€” mostra apenas a coleta mais recente.</p>

Quem deu qual reaÃ§Ã£o para quem. Cada cÃ©lula mostra a reaÃ§Ã£o que a **linha** (emissor) deu para a **coluna** (receptor).

```{python}
#| label: cross-table
#| output: asis

# Definir active_names (usado por outras seÃ§Ãµes abaixo)
active_names = sorted([p['name'] for p in latest['participants']
                        if not p.get('characteristics', {}).get('eliminated')])

# HTML table with sticky header/column (mobile-friendly)
print(make_cross_table_html(latest['participants'], latest_matrix, title_suffix=latest['label']))
```

```{python}
#| label: cross-table-summary
#| output: asis

print("\n### ReaÃ§Ãµes Recebidas por Participante\n")
print("<p class='text-muted small'>Ordenado por score de sentimento. CÃ©lulas coloridas indicam valores altos.</p>")
print(make_reaction_summary_html(latest['participants'], collapsed_rows=5))
```

# Perfis Individuais {#perfis}

<p class="text-muted small">ğŸ“¸ <strong>Dado do dia</strong> â€” mostra apenas a coleta mais recente.</p>

Detalhamento estratÃ©gico de cada participante ativo, incluindo anÃ¡lise de hostilidades e vulnerabilidades no jogo.

<details style="margin: 1.5rem 0;">
<summary style="cursor: pointer; color: #fff; font-weight: 600; background: #2a2a2a; border-radius: 12px; padding: 0.9rem 1.2rem; border-left: 4px solid #17a2b8;">
â„¹ï¸ Como calculamos Vulnerabilidade, Risco externo e Animosidade (clique para expandir)
</summary>
<div style="background: #2a2a2a; border-radius: 12px; padding: 1.2rem; margin-top: 0.8rem; border-left: 4px solid #17a2b8;">

**ğŸ¯ Vulnerabilidade a Votos Surpresa**

O badge avalia o risco de receber **votos inesperados** â€” de pessoas que o participante considera aliadas mas que, na verdade, sÃ£o hostis ("falsos amigos"). Quem tem muitos inimigos declarados mas zero falsos amigos estÃ¡ em posiÃ§Ã£o mais segura: sabe exatamente de onde vÃªm as ameaÃ§as.

| Badge | CritÃ©rio | Significado |
|-------|----------|-------------|
| ğŸ”´ **MUITO VULNERÃVEL** | 5+ falsos amigos | PosiÃ§Ã£o crÃ­tica. Muitas pessoas que considera amigas podem votar contra sem que espere. |
| ğŸŸ  **VULNERÃVEL** | 3-4 falsos amigos | PosiÃ§Ã£o frÃ¡gil. Alguns "amigos" sÃ£o hostis e podem surpreender em votaÃ§Ã£o. |
| ğŸŸ¡ **ATENÃ‡ÃƒO** | 1-2 falsos amigos | PosiÃ§Ã£o razoÃ¡vel, mas com pontos cegos. |
| ğŸŸ¢ **PROTEGIDO** | 0 falsos amigos | Sem pontos cegos â€” sabe quem sÃ£o seus aliados e inimigos. |

**ğŸ§­ Risco externo (semana atual)**

Mede exposiÃ§Ã£o real a votos/eventos negativos **na semana atual** (nÃ£o carrega para a semana seguinte).  
FÃ³rmula:

```
risco_externo = 1.0 * votos_recebidos
              + Î£ pesos_prejuizos_publicos
              + 0.5 Ã— Î£ pesos_prejuizos_secretos
              + 0.5 * auto_infligidos
              + 2 (se estiver no Paredao)
```

Faixas: ğŸŸ¢ **MUITO BAIXO** (<1), ğŸŸ¡ **BAIXO** (>=1), ğŸŸ  **MÃ‰DIO** (>=3), ğŸ”´ **ALTO** (>=6).

**ğŸ”¥ Animosidade (tendÃªncia)**

Mede o quanto o participante **gerou impacto negativo** recente na casa:

```
animosidade = 0.25 * reacoes_negativas_recebidas
            + 0.5 * hostilidades_recebidas
            + 1.5 * soma_eventos_negativos_com_decaimento
```

O decaimento usa: `peso = 1 / (1 + semanas_passadas)`.  
Faixas: ğŸŸ¢ **MUITO BAIXA** (<1), ğŸŸ¡ **BAIXA** (>=1), ğŸŸ  **MÃ‰DIA** (>=3), ğŸ”´ **ALTA** (>=6).

**Categorias de RelaÃ§Ã£o:**

- **âœ… Aliados** â€” â¤ï¸ mÃºtuo. Votos seguros, nÃ£o votarÃ£o contra.
- **âš”ï¸ Inimigos Declarados** â€” Negatividade mÃºtua. Votos contra esperados de ambos os lados.
- **âš ï¸ Falsos Amigos** â€” VocÃª dÃ¡ â¤ï¸, mas eles dÃ£o negativa. **PERIGO:** podem votar contra vocÃª!
- **ğŸ—¡ï¸ Inimigos NÃ£o Declarados** â€” VocÃª dÃ¡ negativa, eles dÃ£o â¤ï¸. Eles nÃ£o sabem que sÃ£o seus alvos.

**Novos sinais de jogo (dinÃ¢micas pÃºblicas):**
- **Poderes recebidos** (benefÃ­cios e prejuÃ­zos) mostram acontecimentos **pÃºblicos** na casa que podem mudar alianÃ§as.
- **Votos da casa recebidos** mostram o que o **pÃºblico** viu na formaÃ§Ã£o; quando hÃ¡ **dedo-duro**, o voto aparece marcado.
- O painel agora separa **Risco social** (percepÃ§Ã£o) e **Risco externo** (votos/eventos negativos).
- **Risco externo Ã© experimental** e serÃ¡ recalibrado semanalmente apÃ³s indicaÃ§Ãµes/contragolpes/votaÃ§Ãµes.

</div>
</details>

## SincerÃ£o vs QueridÃ´metro

```{python}
#| label: sincerao-vs-queridometro
#| output: asis

current_week = get_week_number(latest['date'])
sinc_agg = next((a for a in sincerao_data.get("aggregates", []) if a.get("week") == current_week), None)

if not sinc_agg:
    print("<p class='text-muted'>Sem dados detalhados do SincerÃ£o nesta semana.</p>")
else:
    scores = sinc_agg.get("scores", {})
    if not scores:
        print("<p class='text-muted'>SincerÃ£o registrado, mas sem pontuaÃ§Ãµes detalhadas.</p>")
    else:
        rows = []
        for p in latest['participants']:
            name = p['name']
            if name in scores:
                rows.append({
                    "name": name,
                    "sincerao_score": scores[name],
                    "sentiment_score": calc_sentiment(p),
                    "grupo": p.get("characteristics", {}).get("memberOf", "?"),
                })

        if not rows:
            print("<p class='text-muted'>Sem participantes com pontuaÃ§Ã£o no SincerÃ£o.</p>")
        else:
            df_sinc = pd.DataFrame(rows)
            fig = px.scatter(
                df_sinc,
                x="sincerao_score",
                y="sentiment_score",
                color="grupo",
                text="name",
                color_discrete_map=GROUP_COLORS,
                title="Impacto do SincerÃ£o (semana) vs Sentimento do QueridÃ´metro",
                labels={
                    "sincerao_score": "SincerÃ£o (peso agregado)",
                    "sentiment_score": "Sentimento (queridÃ´metro)",
                    "grupo": "Grupo",
                },
            )
            fig.update_traces(textposition="top center")
            fig.update_layout(height=420, margin=dict(l=20, r=20, t=60, b=20))
            fig.update_xaxes(zeroline=True, zerolinecolor="#555")
            fig.update_yaxes(zeroline=True, zerolinecolor="#555")
            fig.show()
```

```{python}
#| label: individual-profiles
#| output: asis

# Ordenar alfabeticamente
sorted_active = sorted(
    [p for p in latest['participants'] if not p.get('characteristics', {}).get('eliminated')],
    key=lambda x: x['name']
)

power_events = manual_events.get('power_events', []) + auto_events.get('events', [])
current_week = get_week_number(latest['date'])
sinc_edges = sincerao_data.get("edges", []) if sincerao_data else []
sinc_edges_week = [e for e in sinc_edges if e.get("week") == current_week]

SINC_EDGE_WEIGHTS = {
    "podio": {1: 0.6, 2: 0.4, 3: 0.2},
    "nao_ganha": -0.8,
    "bomba": -0.6,
}

def sinc_edge_modifier(edge):
    etype = edge.get("type")
    if etype == "podio":
        slot = edge.get("slot")
        return SINC_EDGE_WEIGHTS["podio"].get(slot, 0.2)
    return SINC_EDGE_WEIGHTS.get(etype, 0.0)

from collections import defaultdict
sinc_edge_mod = defaultdict(float)
for edge in sinc_edges_week:
    actor = edge.get("actor")
    target = edge.get("target")
    if actor and target:
        sinc_edge_mod[(actor, target)] += sinc_edge_modifier(edge)

def pair_sentiment(giver, receiver):
    label = latest_matrix.get((giver, receiver), "")
    base = SENTIMENT_WEIGHTS.get(label, 0)
    return base + sinc_edge_mod.get((giver, receiver), 0)

def normalize_actors(ev):
    actors = ev.get('actors')
    if isinstance(actors, list) and actors:
        return [a for a in actors if a]
    actor = ev.get('actor')
    return [actor] if actor else []

source_icons = {
    'big fone': 'ğŸ“',
    'caixas-surpresa': 'ğŸ',
    'prova do lÃ­der': 'ğŸ‘‘',
    'prova do anjo': 'ğŸ˜‡',
    'castigo do monstro': 'ğŸ‘¹',
    'dinÃ¢mica da casa': 'ğŸ¬',
}

def render_actor_avatars(actors, border_color="#666", color_lookup=None, size=24, skip_icons=None):
    if not actors:
        return ''
    parts = []
    for a in actors:
        color = border_color
        if color_lookup and a in color_lookup:
            color = color_lookup[a]
        if a in AVATARS and AVATARS[a]:
            parts.append(
                f'<img src="{AVATARS[a]}" style="width: {size}px; height: {size}px; border-radius: 50%; '
                f'border: 2px solid {color}; object-fit: cover; margin-right: -4px;">'
            )
        else:
            icon = None
            lower = a.lower() if isinstance(a, str) else ''
            for k, v in source_icons.items():
                if k in lower:
                    icon = v
                    break
            if "dinÃ¢mica da casa" in lower:
                continue
            if icon and skip_icons and icon in skip_icons:
                continue
            parts.append(f'<span style="font-size: 0.9rem;">{icon or "ğŸ¬"}</span>')
    return ''.join(parts)

# Votes received (from paredoes.json), accounting for voto duplo/anulado
votes_received = defaultdict(lambda: defaultdict(int))
votes_received_by_week = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))
votes_total = defaultdict(int)
votes_cast = defaultdict(int)
revealed_votes = defaultdict(set)

for par in paredoes_data.get('paredoes', []) if paredoes_data else []:
    votos = par.get('votos_casa', {}) or {}
    if not votos:
        continue
    week = par.get('semana')
    multiplier = defaultdict(lambda: 1)

    for voter in par.get('votos_anulados', []) or []:
        multiplier[voter] = 0
    for voter in par.get('impedidos_votar', []) or []:
        multiplier[voter] = 0

    for ev in power_events:
        if week and ev.get('week') == week:
            if ev.get('type') == 'voto_duplo':
                for a in normalize_actors(ev):
                    if a:
                        multiplier[a] = 2
            if ev.get('type') == 'voto_anulado':
                target = ev.get('target')
                if target:
                    multiplier[target] = 0

    for voter, target in votos.items():
        v = voter.strip()
        t = target.strip()
        mult = multiplier.get(v, 1)
        if mult <= 0:
            continue
        votes_received[t][v] += mult
        votes_received_by_week[week][t][v] += mult
        votes_total[t] += mult
        votes_cast[v] += mult

# Dedo-duro (revealed votes) from manual_events.weekly_events
for wev in manual_events.get('weekly_events', []) if manual_events else []:
    dd = wev.get('dedo_duro')
    if isinstance(dd, dict):
        voter = dd.get('votante')
        target = dd.get('alvo')
        if voter and target:
            revealed_votes[target].add(voter)
    elif isinstance(dd, list):
        for item in dd:
            voter = item.get('votante')
            target = item.get('alvo')
            if voter and target:
                revealed_votes[target].add(voter)

def make_event_chips(events, border_color, color_lookup=None):
    if not events:
        return "<span style='color:#777;'>â€”</span>"
    grouped = defaultdict(lambda: {'count': 0, 'actors': []})
    for ev in events:
        etype = ev.get('type')
        actors = normalize_actors(ev)
        key = (etype, tuple(actors))
        grouped[key]['count'] += 1
        grouped[key]['actors'] = actors

    chips = []
    for (etype, actors), meta in grouped.items():
        emoji = POWER_EVENT_EMOJI.get(etype, 'â€¢')
        label = POWER_EVENT_LABELS.get(etype, etype)
        count = meta['count']
        count_prefix = f"{count}x " if count > 1 else ""
        chip_colors = {color_lookup.get(a) for a in actors} if color_lookup else set()
        chip_colors.discard(None)
        chip_border = chip_colors.pop() if len(chip_colors) == 1 else border_color
        actor_html = render_actor_avatars(
            actors,
            chip_border,
            color_lookup=color_lookup,
            size=22,
            skip_icons={emoji} if emoji else None
        )
        actor_label = " + ".join(actors) if actors else ""
        title = f"{label} â€” {actor_label}" if actor_label else label
        chips.append(
            f"<span style='display:inline-flex; align-items:center; gap:0.3rem; background:#2f2f2f; "
            f"border:1px solid {chip_border}; color:#ddd; border-radius:10px; padding:0.18rem 0.5rem; "
            f"font-size:0.72rem; margin:0.15rem; min-height: 28px; line-height: 1;' title='{title}'>"
            f"{count_prefix}{emoji} {label} {actor_html}</span>"
        )
    return ' '.join(chips)

for p in sorted_active:
    name = p['name']
    first_name = name.split()[0]
    member_of = p.get('characteristics', {}).get('memberOf', '?')
    group = p.get('characteristics', {}).get('group', '?')
    balance = p.get('characteristics', {}).get('balance', 0)
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    score = calc_sentiment(p)

    # ReaÃ§Ãµes recebidas
    rxn_summary = []
    for rxn in p.get('characteristics', {}).get('receivedReactions', []):
        emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
        rxn_summary.append(f"{emoji}Ã—{rxn['amount']}")

    # ReaÃ§Ãµes que este participante deu
    given = {}
    for other_name in active_names:
        if other_name == name:
            continue
        rxn = latest_matrix.get((name, other_name), '')
        if rxn:
            emoji = REACTION_EMOJI.get(rxn, rxn)
            given[emoji] = given.get(emoji, 0) + 1

    given_summary = " | ".join(f"{e}Ã—{c}" for e, c in sorted(given.items(), key=lambda x: -x[1]))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ANÃLISE ESTRATÃ‰GICA DE RELAÃ‡Ã•ES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    allies = []           # â¤ï¸ mÃºtuo â€” aliados seguros
    enemies = []          # Neg mÃºtua â€” inimigos declarados (votos previsÃ­veis)
    false_friends = []    # Dou â¤ï¸, recebo neg â€” PERIGO: podem me votar
    blind_targets = []    # Dou neg, recebo â¤ï¸ â€” posso votar neles sem retaliaÃ§Ã£o esperada

    for other_name in active_names:
        if other_name == name:
            continue
        my_rxn = latest_matrix.get((name, other_name), '')
        their_rxn = latest_matrix.get((other_name, name), '')

        my_score = pair_sentiment(name, other_name)
        their_score = pair_sentiment(other_name, name)

        my_is_positive = my_score > 0
        their_is_positive = their_score > 0
        my_is_negative = my_score < 0
        their_is_negative = their_score < 0

        if my_is_positive and their_is_positive:
            allies.append(other_name)
        elif my_is_negative and their_is_negative:
            my_emoji = REACTION_EMOJI.get(my_rxn, '?')
            their_emoji = REACTION_EMOJI.get(their_rxn, '?')
            enemies.append((other_name, my_emoji, their_emoji))
        elif my_is_positive and their_is_negative:
            their_emoji = REACTION_EMOJI.get(their_rxn, '?')
            false_friends.append((other_name, their_emoji))
        elif my_is_negative and their_is_positive:
            my_emoji = REACTION_EMOJI.get(my_rxn, '?')
            blind_targets.append((other_name, my_emoji))

    # Calculate metrics
    n_false_friends = len(false_friends)
    n_blind_targets = len(blind_targets)
    n_enemies = len(enemies)
    n_allies = len(allies)
    total_relations = n_allies + n_enemies + n_false_friends + n_blind_targets

    # Vulnerability assessment - based on false friends (blind spots for incoming votes)
    # Thresholds calibrated to current data: avg ~2.6 false friends, max 9
    if n_false_friends >= 5:
        risk_level = "ğŸ”´ MUITO VULNERÃVEL"
        risk_color = "#dc3545"
    elif n_false_friends >= 3:
        risk_level = "ğŸŸ  VULNERÃVEL"
        risk_color = "#fd7e14"
    elif n_false_friends >= 1:
        risk_level = "ğŸŸ¡ ATENÃ‡ÃƒO"
        risk_color = "#ffc107"
    else:
        risk_level = "ğŸŸ¢ PROTEGIDO"
        risk_color = "#28a745"

    # Power events (received)
    target_events_all = [ev for ev in power_events if ev.get('target') == name]
    target_events_week = [ev for ev in target_events_all if ev.get('week') == current_week]
    target_events_hist = [ev for ev in target_events_all if ev.get('week') != current_week]
    pos_events = [ev for ev in target_events_week if ev.get('impacto') == 'positivo']
    neg_events = [ev for ev in target_events_week if ev.get('impacto') == 'negativo']
    pos_events_hist = [ev for ev in target_events_hist if ev.get('impacto') == 'positivo']
    neg_events_hist = [ev for ev in target_events_hist if ev.get('impacto') == 'negativo']

    ally_names = set(allies)
    enemy_names = {n for n, *_ in enemies}
    false_friend_names = {n for n, *_ in false_friends}
    blind_names = {n for n, *_ in blind_targets}

    relation_colors = {}
    relation_colors.update({n: "#28a745" for n in ally_names})
    relation_colors.update({n: "#dc3545" for n in enemy_names})
    relation_colors.update({n: "#ffc107" for n in false_friend_names})
    relation_colors.update({n: "#6f42c1" for n in blind_names})

    pos_html = make_event_chips(pos_events, "#28a745", relation_colors)
    neg_html = make_event_chips(neg_events, "#dc3545", relation_colors)
    pos_hist_html = make_event_chips(pos_events_hist, "#2ecc71", relation_colors) if pos_events_hist else ""
    neg_hist_html = make_event_chips(neg_events_hist, "#e74c3c", relation_colors) if neg_events_hist else ""
    hist_html = ""
    if pos_events_hist:
        hist_html += f"<span style='color:#28a745;'>{pos_hist_html}</span>"
    if neg_events_hist:
        hist_html += f"<span style='color:#dc3545; margin-left:0.35rem;'>{neg_hist_html}</span>"

    vote_map = votes_received_by_week.get(current_week, {}).get(name, {})
    if vote_map:
        vote_chips = []
        for voter, count in sorted(vote_map.items(), key=lambda x: (-x[1], x[0])):
            count_prefix = f"{count}x " if count > 1 else ""
            is_revealed = voter in revealed_votes.get(name, set())
            border = relation_colors.get(voter, "#666")
            reveal_glow = "box-shadow: 0 0 0 2px #17a2b8 inset;" if is_revealed else ""
            badge = " ğŸ‘ï¸" if is_revealed else ""
            avatar_html = render_actor_avatars([voter], border, color_lookup=relation_colors, size=22)
            title = f"Voto revelado de {voter}" if is_revealed else f"Voto de {voter}"
            vote_chips.append(
                f"<span style='display:inline-flex; align-items:center; gap:0.3rem; background:#2f2f2f; "
                f"border:1px solid {border}; color:#ddd; border-radius:999px; padding:0.2rem 0.45rem; "
                f"font-size:0.72rem; margin:0.15rem; min-height: 28px; line-height: 1; {reveal_glow}' title='{title}'>"
                f"{count_prefix}{avatar_html}{voter}{badge}</span>"
            )
        votes_html = ' '.join(vote_chips)
    else:
        votes_html = ""

    def is_self_inflicted(ev):
        actors = normalize_actors(ev)
        return any(a == name for a in actors)

    neg_public = [ev for ev in neg_events if ev.get('visibility', 'public') != 'secret' and not is_self_inflicted(ev)]
    neg_secret = [ev for ev in neg_events if ev.get('visibility', 'public') == 'secret']
    neg_self = [ev for ev in neg_events if is_self_inflicted(ev)]

    NEG_EVENT_WEIGHTS = {
        'indicacao': 2.5,
        'contragolpe': 2.5,
        'emparedado': 2.0,
        'veto_prova': 1.5,
        'monstro': 1.2,
        'perdeu_voto': 1.0,
        'voto_anulado': 0.8,
        'voto_duplo': 0.6,
        'exposto': 0.5,
    }

    def event_weight_neg(ev):
        return NEG_EVENT_WEIGHTS.get(ev.get('type'), 1.0)

    votes_count = sum(vote_map.values()) if vote_map else 0
    external_score = (
        1.0 * votes_count +
        sum(event_weight_neg(ev) for ev in neg_public) +
        sum(event_weight_neg(ev) * 0.5 for ev in neg_secret) +
        0.5 * len(neg_self)
    )
    if 'ParedÃ£o' in roles:
        external_score += 2

    def event_weight(ev):
        ev_week = ev.get('week') or current_week
        diff = max(0, current_week - ev_week)
        return 1 / (1 + diff)

    animosity_events = [ev for ev in power_events if ev.get('impacto') == 'negativo' and name in normalize_actors(ev)]
    ANIMOSITY_WEIGHTS = {
        'indicacao': 2.0,
        'contragolpe': 2.0,
        'monstro': 1.2,
        'perdeu_voto': 0.8,
        'voto_anulado': 0.8,
        'voto_duplo': 0.6,
        'exposto': 0.5,
    }

    def animosity_event_weight(ev):
        return ANIMOSITY_WEIGHTS.get(ev.get('type'), 1.0)
    animosity_score = (
        0.25 * sum(1 for rxn in p.get('characteristics', {}).get('receivedReactions', [])
                   if rxn.get('label') not in POSITIVE) +
        0.5 * sum(1 for other_name in active_names
                  if latest_matrix.get((name, other_name), '') and latest_matrix.get((name, other_name), '') not in POSITIVE) +
        1.5 * sum(event_weight(ev) * animosity_event_weight(ev) for ev in animosity_events)
    )

    if animosity_score >= 6:
        animosity_level = "ğŸ”´ ALTA"
        animosity_color = "#dc3545"
    elif animosity_score >= 3:
        animosity_level = "ğŸŸ  MÃ‰DIA"
        animosity_color = "#fd7e14"
    elif animosity_score >= 1:
        animosity_level = "ğŸŸ¡ BAIXA"
        animosity_color = "#ffc107"
    else:
        animosity_level = "ğŸŸ¢ MUITO BAIXA"
        animosity_color = "#28a745"

    if external_score >= 6:
        external_level = "ğŸ”´ ALTO"
        external_color = "#dc3545"
    elif external_score >= 3:
        external_level = "ğŸŸ  MÃ‰DIO"
        external_color = "#fd7e14"
    elif external_score >= 1:
        external_level = "ğŸŸ¡ BAIXO"
        external_color = "#ffc107"
    else:
        external_level = "ğŸŸ¢ MUITO BAIXO"
        external_color = "#28a745"

    # Get avatar
    avatar_url = AVATARS.get(name, '')
    cor_grupo = GROUP_COLORS.get(member_of, '#666')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PROFILE CARD - Using HTML tables for better formatting
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f'''
<div style="margin-top: 2rem; margin-bottom: 1rem; border: 1px solid #444; border-radius: 12px; overflow: hidden; background: #2a2a2a;">

<!-- Header with avatar -->
<div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: linear-gradient(90deg, rgba(48,48,48,0.9), rgba(48,48,48,0.3)); border-left: 5px solid {cor_grupo};">
''')
    if avatar_url:
        print(f'<img src="{avatar_url}" alt="{name}" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid {cor_grupo}; flex-shrink: 0;">')

    role_text = f" | {', '.join(roles)}" if roles else ""
    print(f'''
<div>
<h3 style="margin: 0 0 0.3rem 0; color: #fff; font-size: 1.4em;">{name}
  <span style="font-size: 0.5em; padding: 3px 10px; border-radius: 4px; background: {risk_color}; color: #fff; vertical-align: middle; font-weight: bold;">{risk_level}</span>
  <span style="font-size: 0.5em; padding: 3px 10px; border-radius: 4px; background: {external_color}; color: #fff; vertical-align: middle; font-weight: bold;">Risco externo {external_level}</span>
  <span style="font-size: 0.5em; padding: 3px 10px; border-radius: 4px; background: {animosity_color}; color: #fff; vertical-align: middle; font-weight: bold;">Animosidade {animosity_level}</span>
</h3>
<div style="color: #aaa; font-size: 0.95em;">
<strong style="color: {cor_grupo};">{member_of}</strong> | {group} | Saldo: {balance:,} | Sentimento: <strong style="color: {'#28a745' if score >= 0 else '#dc3545'};">{score:+.1f}</strong>{role_text}
</div>
</div>
</div>

<!-- Reactions -->
<div style="padding: 0.8rem 1rem; border-bottom: 1px solid #444; background: #333;">
<div style="display: flex; flex-wrap: wrap; gap: 1.5rem;">
<div><strong style="color: #888;">Recebeu:</strong> {' '.join(rxn_summary)}</div>
<div><strong style="color: #888;">Deu:</strong> {given_summary}</div>
</div>
</div>

{f'''
<!-- Game Dynamics -->
<div style="padding: 0.8rem 1rem; border-bottom: 1px solid #444; background: #2f2f2f;">
<div style="font-weight: bold; color: #fff; margin-bottom: 0.5rem;">âš¡ DinÃ¢micas do Jogo</div>
<div style="display: grid; grid-template-columns: 1fr; gap: 0.4rem; font-size: 0.9em;">
  {f"<div style='display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;'><strong style='color: #28a745;'>+ BenefÃ­cios (semana):</strong> {pos_html}</div>" if pos_events else ""}
  {f"<div style='display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;'><strong style='color: #dc3545;'>âˆ’ PrejuÃ­zos (semana):</strong> {neg_html}</div>" if neg_events else ""}
  {f"<div style='display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;'><strong style='color: #ffc107;'>ğŸ—³ï¸ Votos recebidos:</strong> {votes_html}</div>" if vote_map else ""}
  {f"<div style='display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;'><strong style='color: #999;'>HistÃ³rico da temporada:</strong> {hist_html}</div>" if (pos_events_hist or neg_events_hist) else ""}
</div>
</div>
''' if (pos_events_hist or neg_events_hist or pos_events or neg_events or vote_map) else ''}

<!-- Strategic Map -->
<div style="padding: 1rem;">
<h4 style="margin: 0 0 0.8rem 0; color: #fff; font-size: 1em; border-bottom: 1px solid #444; padding-bottom: 0.5rem;">ğŸ—ºï¸ Mapa EstratÃ©gico</h4>
''')

    # Allies
    if allies:
        allies_str = ', '.join(sorted(allies))
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border-left: 3px solid #28a745;">
<div style="font-weight: bold; color: #28a745; margin-bottom: 0.3rem;">âœ… Aliados ({n_allies})</div>
<div style="color: #ccc; font-size: 0.9em;">{allies_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Votos seguros. NÃ£o votarÃ£o contra.</div>
</div>
''')

    # Enemies
    if enemies:
        enemy_items = [f"{n} <span style='color:#888;'>({me}â†”{te})</span>" for n, me, te in sorted(enemies, key=lambda x: x[0])]
        enemies_str = ', '.join(enemy_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(220, 53, 69, 0.1); border-radius: 6px; border-left: 3px solid #dc3545;">
<div style="font-weight: bold; color: #dc3545; margin-bottom: 0.3rem;">âš”ï¸ Inimigos Declarados ({n_enemies})</div>
<div style="color: #ccc; font-size: 0.9em;">{enemies_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Hostilidade mÃºtua. Votos contra esperados de ambos os lados.</div>
</div>
''')

    # False Friends - DANGER
    if false_friends:
        ff_items = [f"<strong>{n}</strong> <span style='color:#dc3545;'>({e})</span>" for n, e in sorted(false_friends, key=lambda x: x[0])]
        ff_str = ', '.join(ff_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(255, 193, 7, 0.15); border-radius: 6px; border-left: 3px solid #ffc107;">
<div style="font-weight: bold; color: #ffc107; margin-bottom: 0.3rem;">âš ï¸ Falsos Amigos ({n_false_friends}) â€” PERIGO!</div>
<div style="color: #ccc; font-size: 0.9em;">{ff_str}</div>
<div style="color: #dc3545; font-size: 0.8em; margin-top: 0.3rem;">â†’ {first_name} dÃ¡ â¤ï¸ mas recebe negatividade. Podem votar contra sem que {first_name} espere!</div>
</div>
''')

    # Blind Targets - Undeclared enemies (they don't know)
    if blind_targets:
        bt_items = [f"{n} <span style='color:#6f42c1;'>({e})</span>" for n, e in sorted(blind_targets, key=lambda x: x[0])]
        bt_str = ', '.join(bt_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(111, 66, 193, 0.1); border-radius: 6px; border-left: 3px solid #6f42c1;">
<div style="font-weight: bold; color: #6f42c1; margin-bottom: 0.3rem;">ğŸ—¡ï¸ Inimigos NÃ£o Declarados ({n_blind_targets})</div>
<div style="color: #ccc; font-size: 0.9em;">{bt_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Eles dÃ£o â¤ï¸ para {first_name}, mas {first_name} Ã© hostil. Eles nÃ£o sabem que sÃ£o alvos.</div>
</div>
''')

    # Game Analysis
    insights = []
    if n_false_friends == 0 and n_enemies == 0:
        insights.append("ğŸ›¡ï¸ PosiÃ§Ã£o confortÃ¡vel: sem inimigos e sem falsos amigos.")
    if n_false_friends >= 3:
        insights.append(f"ğŸš¨ <strong style='color:#dc3545;'>PosiÃ§Ã£o vulnerÃ¡vel</strong>: {n_false_friends} pessoas que considera amigas sÃ£o hostis.")
    elif n_false_friends >= 1:
        insights.append(f"âš¡ AtenÃ§Ã£o: {n_false_friends} falso(s) amigo(s) pode(m) surpreender em votaÃ§Ã£o.")
    if n_blind_targets >= 3:
        insights.append(f"ğŸ—¡ï¸ {n_blind_targets} inimigos nÃ£o declarados: confiam em {first_name} sem saber que sÃ£o alvos.")
    if n_enemies >= 3:
        insights.append(f"ğŸ”¥ Polarizante: {n_enemies} inimigos declarados. Alvo provÃ¡vel em paredÃµes.")
    if n_allies >= 10 and total_relations > 0:
        pct = n_allies * 100 // total_relations
        insights.append(f"ğŸ’ª Base sÃ³lida: {n_allies} aliados ({pct}% das relaÃ§Ãµes).")

    if insights:
        print(f'''
<div style="padding: 0.6rem; background: #383838; border-radius: 6px; margin-top: 0.5rem;">
<div style="font-weight: bold; color: #fff; margin-bottom: 0.4rem; font-size: 0.9em;">ğŸ“Š AnÃ¡lise de Jogo</div>
<ul style="margin: 0; padding-left: 1.2rem; color: #ccc; font-size: 0.85em;">
''')
        for insight in insights:
            print(f'<li style="margin-bottom: 0.2rem;">{insight}</li>')
        print('</ul></div>')

    print('</div></div>')  # Close strategic map and card
```

---

<div class="alert alert-info" role="alert">
<strong>ğŸ’¡ Sobre este painel:</strong> Este painel acompanha as reaÃ§Ãµes do queridÃ´metro do BBB 26. As reaÃ§Ãµes <strong>mudam diariamente</strong> â€” os participantes podem trocar suas escolhas a cada Raio-X. SeÃ§Ãµes marcadas com ğŸ“¸ mostram apenas o dia mais recente; seÃ§Ãµes marcadas com ğŸ“ˆ mostram a evoluÃ§Ã£o ao longo do tempo. Acompanhamento desde 13 de janeiro de 2026.
</div>
