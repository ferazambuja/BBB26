---
title: "BBB 26 â€” Painel de ReaÃ§Ãµes"
subtitle: "AnÃ¡lise das reaÃ§Ãµes entre os participantes do Big Brother Brasil 2026"
author: "Dashboard Automatizado"
date: today
lang: pt-BR
format:
  html:
    code-fold: true
    code-summary: "Ver cÃ³digo"
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

REACTION_SLUG_TO_LABEL = {
    'coracao': 'CoraÃ§Ã£o', 'planta': 'Planta', 'mala': 'Mala', 'biscoito': 'Biscoito',
    'cobra': 'Cobra', 'alvo': 'Alvo', 'vomito': 'VÃ´mito', 'mentiroso': 'Mentiroso',
    'coracao-partido': 'CoraÃ§Ã£o partido'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0,
    'CoraÃ§Ã£o partido': -0.5  # Mild negative (disappointment, not hostility)
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito', 'CoraÃ§Ã£o partido'}  # ğŸ’” = disappointment, not hostility
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}  # preenchido ao carregar dados

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Plotly Dark Theme Configuration (matches Bootswatch darkly)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PLOT_BG = '#303030'  # Darkly body background
PAPER_BG = '#303030'
GRID_COLOR = '#444444'
TEXT_COLOR = '#fff'

# Standard layout applied to ALL plots
import plotly.io as pio

pio.templates['bbb_dark'] = go.layout.Template(
    layout=go.Layout(
        paper_bgcolor=PAPER_BG,
        plot_bgcolor=PLOT_BG,
        font=dict(color=TEXT_COLOR, family='Lato, -apple-system, sans-serif', size=13),
        title=dict(font=dict(size=16), x=0.5, xanchor='center', y=0.95),
        margin=dict(l=70, r=30, t=70, b=60),
        xaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        yaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        legend=dict(
            bgcolor='rgba(0,0,0,0)',
            bordercolor='rgba(0,0,0,0)',
        ),
        colorway=['#00bc8c', '#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6'],
    )
)
pio.templates.default = 'bbb_dark'
```

```{python}
#| label: load-data

def load_snapshot(filepath):
    """Carrega um snapshot JSON (formato novo ou antigo)."""
    with open(filepath, encoding="utf-8") as f:
        data = json.load(f)
    if isinstance(data, dict) and "participants" in data:
        return data["participants"], data.get("_metadata")
    return data, None

def get_all_snapshots():
    """Retorna lista de (filepath, date_str) ordenada cronologicamente."""
    if not DATA_DIR.exists():
        return []
    snapshots = sorted(DATA_DIR.glob("*.json"))
    result = []
    for fp in snapshots:
        parts = fp.stem.split("_")
        date_str = parts[0]
        result.append((fp, date_str))
    return result

def parse_roles(roles_data):
    """Extrai nomes de roles (pode ser lista de strings ou lista de dicts)."""
    if not roles_data:
        return []
    result = []
    for r in roles_data:
        if isinstance(r, str):
            result.append(r)
        elif isinstance(r, dict):
            result.append(r.get('label', str(r)))
    return result

def build_reaction_matrix(participants):
    """ConstrÃ³i dicionÃ¡rio {(giver_name, receiver_name): reaction_label}."""
    matrix = {}
    for receiver in participants:
        rname = receiver['name']
        for rxn in receiver.get('characteristics', {}).get('receivedReactions', []):
            label = rxn.get('label', '')
            for giver in rxn.get('participants', []):
                gname = giver['name']
                matrix[(gname, rname)] = label
    return matrix

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label legÃ­vel e flag de sintÃ©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

# Detectar participantes que entraram apÃ³s o primeiro snapshot
first_snap_names = set(p['name'] for p in snapshots[0]['participants'])
late_entrants = {}
_seen_names = set(first_snap_names)
for snap in snapshots[1:]:
    current_names = set(p['name'] for p in snap['participants'])
    new_names = current_names - _seen_names
    for name in new_names:
        if name not in late_entrants:
            late_entrants[name] = snap['date']
    _seen_names |= current_names

if late_entrants:
    # Group by entry date
    _by_date = {}
    for n, d in late_entrants.items():
        _by_date.setdefault(d, []).append(n)

    _parts = []
    for d, names in sorted(_by_date.items()):
        names_str = ', '.join(sorted(names))
        _parts.append(f"{names_str} (entraram em {d})")
    _late_str = '; '.join(_parts)

    late_caption = (
        f"âš ï¸ Participantes que entraram apÃ³s o inÃ­cio do confinamento ({_late_str}) "
        f"tÃªm menos dias de dados comparados aos demais participantes que estavam presentes "
        f"desde o inÃ­cio da temporada, e isso pode afetar comparaÃ§Ãµes temporais."
    )
else:
    late_caption = ""

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (Ãºltima do dia) â€” usada para anÃ¡lises de reaÃ§Ãµes
# ReaÃ§Ãµes mudam 1x/dia (no Raio-X da manhÃ£); coletas extras no mesmo dia
# tÃªm reaÃ§Ãµes idÃªnticas mas podem diferir em saldo/papÃ©is.
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)
```

```{python}
#| label: viz-functions
#| include: false

def get_snapshot_for_date(target_date, snapshots_list=None, matrices_list=None):
    """Retorna (snapshot, matrix, index) do snapshot mais prÃ³ximo antes/em target_date."""
    snaps = snapshots_list or snapshots
    mats = matrices_list or all_matrices
    closest_idx = 0
    for i, snap in enumerate(snaps):
        if snap['date'] <= target_date:
            closest_idx = i
    return snaps[closest_idx], mats[closest_idx], closest_idx


def make_sentiment_ranking(participants, matrix, title_suffix="", show_avatars=False, avatars_dict=None):
    """Retorna go.Figure com ranking horizontal de sentimento."""
    sentiment_data = []
    for p in participants:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        score = calc_sentiment(p)
        hearts = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                     if r['label'] == 'CoraÃ§Ã£o')
        neg = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                  if r['label'] != 'CoraÃ§Ã£o')
        member_of = p.get('characteristics', {}).get('memberOf', '?')
        avatar = (avatars_dict or {}).get(name, '') if show_avatars else ''
        sentiment_data.append({
            'name': name, 'score': score, 'hearts': hearts,
            'negative': neg, 'memberOf': member_of, 'avatar': avatar
        })

    df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

    color_map = {name: GROUP_COLORS.get(m, '#999')
                 for name, m in zip(df_sent['name'], df_sent['memberOf'])}

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_sent['name'],
        x=df_sent['score'],
        orientation='h',
        marker_color=[color_map[n] for n in df_sent['name']],
        text=[f"{s:+.1f}" for s in df_sent['score']],
        textposition='outside',
        hovertemplate='%{y}: %{x:+.1f}<br>â¤ï¸: %{customdata[0]} | Neg: %{customdata[1]}<extra></extra>',
        customdata=list(zip(df_sent['hearts'], df_sent['negative'])),
        showlegend=False
    ))

    title = "Ranking de Sentimento"
    if title_suffix:
        title += f" â€” {title_suffix}"

    # Calculate left margin - need more space for avatars
    left_margin = 180 if show_avatars else 150

    fig.update_layout(
        title=title,
        xaxis_title="Score de Sentimento",
        yaxis_title="",
        height=max(500, len(df_sent) * 32),
        margin=dict(l=left_margin),
        shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                     line=dict(color='red', dash='dash', width=1))]
    )

    # Add avatar images as layout images (positioned in paper coordinates)
    if show_avatars and avatars_dict:
        images = []
        n_participants = len(df_sent)
        for i, (_, row) in enumerate(df_sent.iterrows()):
            avatar_url = row.get('avatar', '')
            if avatar_url:
                # Position each avatar to the left of the y-axis label
                # y position: map bar index to paper coordinates
                y_pos = i / (n_participants - 1) if n_participants > 1 else 0.5
                images.append(dict(
                    source=avatar_url,
                    xref="paper", yref="paper",
                    x=-0.01, y=y_pos,  # Just left of the chart
                    sizex=0.04, sizey=0.04,  # Size relative to plot
                    xanchor="right", yanchor="middle",
                    layer="above"
                ))
        if images:
            fig.update_layout(images=images)

    for group, color in GROUP_COLORS.items():
        fig.add_trace(go.Scatter(
            x=[None], y=[None], mode='markers',
            marker=dict(size=10, color=color),
            name=group, showlegend=True
        ))

    return fig


def make_cross_table_heatmap(participants, matrix, title_suffix=""):
    """Retorna go.Figure com heatmap da tabela cruzada de reaÃ§Ãµes."""
    active_names_ht = sorted([p['name'] for p in participants
                              if not p.get('characteristics', {}).get('eliminated')])

    heat_data = np.zeros((len(active_names_ht), len(active_names_ht)))
    rxn_labels = []
    for i, giver in enumerate(active_names_ht):
        row_labels = []
        for j, receiver in enumerate(active_names_ht):
            if giver == receiver:
                heat_data[i, j] = np.nan
                row_labels.append('â€”')
            else:
                rxn = matrix.get((giver, receiver), '')
                weight = SENTIMENT_WEIGHTS.get(rxn, 0)
                heat_data[i, j] = weight
                emoji = REACTION_EMOJI.get(rxn, '?')
                row_labels.append(emoji)
        rxn_labels.append(row_labels)

    short_names = [n.split()[0] if len(n) > 12 else n for n in active_names_ht]

    fig = go.Figure(data=go.Heatmap(
        z=heat_data,
        x=short_names,
        y=short_names,
        colorscale=[
            [0, '#d73027'],
            [0.25, '#fc8d59'],
            [0.5, '#ffffbf'],
            [1.0, '#1a9850'],
        ],
        zmin=-1, zmax=1,
        text=[[rxn_labels[i][j] for j in range(len(active_names_ht))] for i in range(len(active_names_ht))],
        texttemplate='%{text}',
        textfont=dict(size=14),
        hovertemplate='%{y} â†’ %{x}: %{text}<extra></extra>',
        colorbar=dict(title="Sentimento", tickvals=[-1, -0.5, 0, 1],
                      ticktext=['Forte Neg', 'Leve Neg', 'Neutro', 'Positivo'])
    ))

    title = "Mapa de ReaÃ§Ãµes"
    if title_suffix:
        title += f" â€” {title_suffix}"

    fig.update_layout(
        title=title,
        xaxis_title="Receptor â†",
        yaxis_title="Emissor â†’",
        height=750,
        xaxis=dict(tickangle=45, side='bottom'),
        yaxis=dict(autorange='reversed')
    )

    return fig


def make_reaction_summary_md(participants):
    """Retorna string markdown com tabela de reaÃ§Ãµes recebidas por participante."""
    summary_rows = []
    for p in sorted(participants, key=lambda x: calc_sentiment(x), reverse=True):
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        rxn_counts = {}
        for rxn in p.get('characteristics', {}).get('receivedReactions', []):
            emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
            rxn_counts[emoji] = rxn['amount']
        score = calc_sentiment(p)
        summary_rows.append({
            'Participante': name,
            'â¤ï¸': rxn_counts.get('â¤ï¸', 0),
            'ğŸŒ±': rxn_counts.get('ğŸŒ±', 0),
            'ğŸ’¼': rxn_counts.get('ğŸ’¼', 0),
            'ğŸª': rxn_counts.get('ğŸª', 0),
            'ğŸ': rxn_counts.get('ğŸ', 0),
            'ğŸ¯': rxn_counts.get('ğŸ¯', 0),
            'ğŸ¤®': rxn_counts.get('ğŸ¤®', 0),
            'ğŸ¤¥': rxn_counts.get('ğŸ¤¥', 0),
            'ğŸ’”': rxn_counts.get('ğŸ’”', 0),
            'Score': f"{score:+.1f}"
        })

    df_summary = pd.DataFrame(summary_rows)
    return df_summary.to_markdown(index=False)


def make_negative_givers_chart(participants, matrix, title_suffix=""):
    """Retorna go.Figure com perfil de emissÃ£o de reaÃ§Ãµes (â¤ï¸ vs negativos)."""
    active_ns = sorted([p['name'] for p in participants
                        if not p.get('characteristics', {}).get('eliminated')])

    giver_data = []
    for name in active_ns:
        pos_given = 0
        neg_given = 0
        for receiver in active_ns:
            if name == receiver:
                continue
            rxn = matrix.get((name, receiver), '')
            if rxn in POSITIVE:
                pos_given += 1
            elif rxn:
                neg_given += 1

        total = pos_given + neg_given
        neg_pct = (neg_given / total * 100) if total > 0 else 0

        giver_data.append({
            'Participante': name,
            'â¤ï¸ dados': pos_given,
            'Negativos dados': neg_given,
            '% Negativo': round(neg_pct, 1),
            'Grupo': MEMBER_OF.get(name, '?')
        })

    df_givers = pd.DataFrame(giver_data).sort_values('% Negativo', ascending=True)

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_givers['Participante'],
        x=df_givers['â¤ï¸ dados'],
        name='â¤ï¸ dados',
        orientation='h',
        marker_color='#1a9850'
    ))
    fig.add_trace(go.Bar(
        y=df_givers['Participante'],
        x=df_givers['Negativos dados'],
        name='Negativos dados',
        orientation='h',
        marker_color='#d73027'
    ))

    title = "Perfil de EmissÃ£o: Quem DÃ¡ Mais â¤ï¸ vs Negatividade?"
    if title_suffix:
        title += f" â€” {title_suffix}"

    fig.update_layout(
        title=title,
        xaxis_title="Quantidade de reaÃ§Ãµes dadas",
        yaxis_title="",
        barmode='stack',
                height=max(500, len(df_givers) * 25),
        margin=dict(l=150)
    )

    return fig
```

# VisÃ£o Geral {#visao-geral}

O **Big Brother Brasil 26** estreou em 12 de janeiro de 2026 com um formato inÃ©dito: trÃªs grupos â€” **Camarote** (famosos), **Veteranos** (ex-BBBs) e **Pipoca** (anÃ´nimos escolhidos pelo pÃºblico via Casas de Vidro nas 5 regiÃµes do Brasil). Os participantes dÃ£o reaÃ§Ãµes uns aos outros diariamente, e essas reaÃ§Ãµes **mudam todos os dias** â€” nÃ£o sÃ£o cumulativas.

```{python}
#| label: overview-stats
#| output: asis

active = [p for p in latest['participants'] if not p.get('characteristics', {}).get('eliminated')]
n_active = len(active)

# Contar por grupo
groups = Counter(p.get('characteristics', {}).get('memberOf', '?') for p in active)

# Todas as reaÃ§Ãµes do Ãºltimo snapshot
total_reactions = sum(
    rxn.get('amount', 0)
    for p in active
    for rxn in p.get('characteristics', {}).get('receivedReactions', [])
)

n_synthetic = sum(1 for s in snapshots if s.get('synthetic'))
groups_str = " | ".join(f"{g}: {c}" for g, c in sorted(groups.items()))

print(f"ğŸ“Š **{n_daily} dias** com dados ({n_snapshots} coletas no total)")
if n_synthetic:
    print(f"  ({n_synthetic} sintÃ©tica(s) â€” reaÃ§Ãµes reconstruÃ­das de artigos GShow)")
print(f"""
ğŸ‘¥ **{n_active} participantes ativos** â€” {groups_str}

ğŸ’¬ **{total_reactions} reaÃ§Ãµes** registradas na Ãºltima coleta

ğŸ“… Ãšltimo dado: **{latest['label']}**
""")
```

## Cronologia do Jogo

```{python}
#| label: timeline-events

events_data = []
all_names_seen = set()

for i, snap in enumerate(snapshots):
    current_names = set(p['name'] for p in snap['participants'])
    active_names = set(p['name'] for p in snap['participants']
                       if not p.get('characteristics', {}).get('eliminated'))

    if i > 0:
        prev_names = set(p['name'] for p in snapshots[i-1]['participants'])
        appeared = current_names - prev_names
        disappeared = prev_names - current_names

        if appeared:
            events_data.append({
                'Data': snap['date'],
                'Evento': f"âœ… Entraram: {', '.join(sorted(appeared))}",
                'Participantes': len(active_names)
            })
        if disappeared:
            for name in disappeared:
                events_data.append({
                    'Data': snap['date'],
                    'Evento': f"âŒ Saiu: {name}",
                    'Participantes': len(active_names)
                })

    # Detectar roles especiais
    for p in snap['participants']:
        roles = parse_roles(p.get('characteristics', {}).get('roles', []))
        for role in roles:
            if role in ('LÃ­der', 'ParedÃ£o') and i > 0:
                prev_snap_p = {pp['name']: pp for pp in snapshots[i-1]['participants']}
                if p['name'] in prev_snap_p:
                    prev_roles = parse_roles(prev_snap_p[p['name']].get('characteristics', {}).get('roles', []))
                    if role not in prev_roles:
                        events_data.append({
                            'Data': snap['date'],
                            'Evento': f"ğŸ† {p['name']} â†’ {role}",
                            'Participantes': len(active_names)
                        })

    all_names_seen |= current_names

if events_data:
    df_events = pd.DataFrame(events_data).drop_duplicates()
    # Mostrar apenas eventos importantes (entradas/saÃ­das/roles)
    key_events = df_events[df_events['Evento'].str.contains('Entraram|Saiu|LÃ­der')]
    if not key_events.empty:
        display(key_events.style.hide(axis='index'))
```

::: {.callout-warning title="ğŸ—³ï¸ ParedÃ£o"}
Para acompanhar o **paredÃ£o atual** (formaÃ§Ã£o, votaÃ§Ã£o da casa, anÃ¡lise de coerÃªncia entre reaÃ§Ãµes e votos), acesse a pÃ¡gina dedicada: **[ParedÃ£o](paredao.html)**

Para ver o **histÃ³rico de paredÃµes anteriores**, acesse: **[Arquivo de ParedÃµes](paredoes.html)**
:::

# Ranking de Sentimento {#ranking}

<p class="text-muted small">ğŸ“¸ <strong>Dado do dia</strong> â€” mostra apenas a coleta mais recente.</p>

Cada participante recebe reaÃ§Ãµes dos demais. O **score de sentimento** pondera: â¤ï¸ = +1, reaÃ§Ãµes leves (ğŸŒ±ğŸ’¼ğŸª) = -0.5, reaÃ§Ãµes fortes (ğŸğŸ¯ğŸ¤®ğŸ¤¥ğŸ’”) = -1.

```{python}
#| label: sentiment-ranking

fig = make_sentiment_ranking(latest['participants'], latest_matrix, title_suffix=latest['label'])
fig.show()
```

::: {.callout-note title="ğŸ“… O Que Mudou Hoje?"}
Para ver as mudanÃ§as diÃ¡rias nas reaÃ§Ãµes (quem ganhou/perdeu sentimento, mapa de diferenÃ§as, fluxo de reaÃ§Ãµes, mudanÃ§as dramÃ¡ticas), acesse a pÃ¡gina dedicada: **[O Que Mudou](mudancas.html)**
:::

::: {.callout-note title="ğŸ“ˆ EvoluÃ§Ã£o do Sentimento"}
Para ver como o sentimento de cada participante evoluiu ao longo do tempo, acesse: **[TrajetÃ³ria](trajetoria.html#evolucao)**
:::

# Tabela Cruzada de ReaÃ§Ãµes {#crosstable}

<p class="text-muted small">ğŸ“¸ <strong>Dado do dia</strong> â€” mostra apenas a coleta mais recente.</p>

Quem deu qual reaÃ§Ã£o para quem. Cada cÃ©lula mostra a reaÃ§Ã£o que a **linha** (emissor) deu para a **coluna** (receptor).

```{python}
#| label: cross-table

# Definir active_names (usado por outras seÃ§Ãµes abaixo)
active_names = sorted([p['name'] for p in latest['participants']
                        if not p.get('characteristics', {}).get('eliminated')])

fig = make_cross_table_heatmap(latest['participants'], latest_matrix, title_suffix=latest['label'])
fig.show()
```

```{python}
#| label: cross-table-summary
#| output: asis

print("\n### ReaÃ§Ãµes Recebidas por Participante\n")
print(make_reaction_summary_md(latest['participants']))
```

::: {.callout-note title="ğŸ“ˆ AlianÃ§as e Rivalidades"}
Para ver as alianÃ§as mais consistentes e rivalidades mais persistentes ao longo do tempo, acesse: **[TrajetÃ³ria](trajetoria.html#aliancas)**
:::

::: {.callout-note title="Grafo de RelaÃ§Ãµes"}
Para ver o grafo de relaÃ§Ãµes (alianÃ§as e rivalidades), acesse: **[TrajetÃ³ria â†’ Grafo](trajetoria.html#grafo)**
:::

::: {.callout-note title="Hostilidades"}
Para anÃ¡lise de hostilidades unilaterais e mÃºtuas, acesse: **[TrajetÃ³ria â†’ Hostilidades](trajetoria.html#hostilidades-dia)**
:::

::: {.callout-note title="Clusters de Afinidade"}
Para ver os clusters de afinidade (agrupamento por sentimento mÃºtuo), acesse: **[TrajetÃ³ria â†’ Clusters](trajetoria.html#clusters)**
:::

::: {.callout-note title="Saldo vs Sentimento"}
Para ver a correlaÃ§Ã£o entre saldo e sentimento, acesse: **[TrajetÃ³ria â†’ Saldo](trajetoria.html#saldo)**
:::

::: {.callout-note title="Quem DÃ¡ Mais Negatividade"}
Para ver o ranking de quem distribui mais reaÃ§Ãµes negativas, acesse: **[TrajetÃ³ria â†’ Emissores](trajetoria.html#emissores)**
:::

# Perfis Individuais {#perfis}

<p class="text-muted small">ğŸ“¸ <strong>Dado do dia</strong> â€” mostra apenas a coleta mais recente.</p>

Detalhamento estratÃ©gico de cada participante ativo, incluindo anÃ¡lise de hostilidades e vulnerabilidades no jogo.

<div style="background: #2a2a2a; border-radius: 12px; padding: 1.2rem; margin: 1.5rem 0; border-left: 4px solid #17a2b8;">

**ğŸ¯ Vulnerabilidade a Votos Surpresa**

O badge avalia o risco de receber **votos inesperados** â€” de pessoas que o participante considera aliadas mas que, na verdade, sÃ£o hostis ("falsos amigos"). Quem tem muitos inimigos declarados mas zero falsos amigos estÃ¡ em posiÃ§Ã£o mais segura: sabe exatamente de onde vÃªm as ameaÃ§as.

| Badge | CritÃ©rio | Significado |
|-------|----------|-------------|
| ğŸ”´ **MUITO VULNERÃVEL** | 5+ falsos amigos | PosiÃ§Ã£o crÃ­tica. Muitas pessoas que considera amigas podem votar contra sem que espere. |
| ğŸŸ  **VULNERÃVEL** | 3-4 falsos amigos | PosiÃ§Ã£o frÃ¡gil. Alguns "amigos" sÃ£o hostis e podem surpreender em votaÃ§Ã£o. |
| ğŸŸ¡ **ATENÃ‡ÃƒO** | 1-2 falsos amigos | PosiÃ§Ã£o razoÃ¡vel, mas com pontos cegos. |
| ğŸŸ¢ **PROTEGIDO** | 0 falsos amigos | Sem pontos cegos â€” sabe quem sÃ£o seus aliados e inimigos. |

**Categorias de RelaÃ§Ã£o:**

- **âœ… Aliados** â€” â¤ï¸ mÃºtuo. Votos seguros, nÃ£o votarÃ£o contra.
- **âš”ï¸ Inimigos Declarados** â€” Negatividade mÃºtua. Votos contra esperados de ambos os lados.
- **âš ï¸ Falsos Amigos** â€” VocÃª dÃ¡ â¤ï¸, mas eles dÃ£o negativa. **PERIGO:** podem votar contra vocÃª!
- **ğŸ—¡ï¸ Inimigos NÃ£o Declarados** â€” VocÃª dÃ¡ negativa, eles dÃ£o â¤ï¸. Eles nÃ£o sabem que sÃ£o seus alvos.

</div>

```{python}
#| label: individual-profiles
#| output: asis

# Ordenar alfabeticamente
sorted_active = sorted(
    [p for p in latest['participants'] if not p.get('characteristics', {}).get('eliminated')],
    key=lambda x: x['name']
)

for p in sorted_active:
    name = p['name']
    first_name = name.split()[0]
    member_of = p.get('characteristics', {}).get('memberOf', '?')
    group = p.get('characteristics', {}).get('group', '?')
    balance = p.get('characteristics', {}).get('balance', 0)
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    score = calc_sentiment(p)

    # ReaÃ§Ãµes recebidas
    rxn_summary = []
    for rxn in p.get('characteristics', {}).get('receivedReactions', []):
        emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
        rxn_summary.append(f"{emoji}Ã—{rxn['amount']}")

    # ReaÃ§Ãµes que este participante deu
    given = {}
    for other_name in active_names:
        if other_name == name:
            continue
        rxn = latest_matrix.get((name, other_name), '')
        if rxn:
            emoji = REACTION_EMOJI.get(rxn, rxn)
            given[emoji] = given.get(emoji, 0) + 1

    given_summary = " | ".join(f"{e}Ã—{c}" for e, c in sorted(given.items(), key=lambda x: -x[1]))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ANÃLISE ESTRATÃ‰GICA DE RELAÃ‡Ã•ES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    allies = []           # â¤ï¸ mÃºtuo â€” aliados seguros
    enemies = []          # Neg mÃºtua â€” inimigos declarados (votos previsÃ­veis)
    false_friends = []    # Dou â¤ï¸, recebo neg â€” PERIGO: podem me votar
    blind_targets = []    # Dou neg, recebo â¤ï¸ â€” posso votar neles sem retaliaÃ§Ã£o esperada

    for other_name in active_names:
        if other_name == name:
            continue
        my_rxn = latest_matrix.get((name, other_name), '')
        their_rxn = latest_matrix.get((other_name, name), '')

        my_is_positive = my_rxn in POSITIVE
        their_is_positive = their_rxn in POSITIVE
        my_is_negative = my_rxn and my_rxn not in POSITIVE
        their_is_negative = their_rxn and their_rxn not in POSITIVE

        if my_is_positive and their_is_positive:
            allies.append(other_name)
        elif my_is_negative and their_is_negative:
            my_emoji = REACTION_EMOJI.get(my_rxn, '?')
            their_emoji = REACTION_EMOJI.get(their_rxn, '?')
            enemies.append((other_name, my_emoji, their_emoji))
        elif my_is_positive and their_is_negative:
            their_emoji = REACTION_EMOJI.get(their_rxn, '?')
            false_friends.append((other_name, their_emoji))
        elif my_is_negative and their_is_positive:
            my_emoji = REACTION_EMOJI.get(my_rxn, '?')
            blind_targets.append((other_name, my_emoji))

    # Calculate metrics
    n_false_friends = len(false_friends)
    n_blind_targets = len(blind_targets)
    n_enemies = len(enemies)
    n_allies = len(allies)
    total_relations = n_allies + n_enemies + n_false_friends + n_blind_targets

    # Vulnerability assessment - based on false friends (blind spots for incoming votes)
    # Thresholds calibrated to current data: avg ~2.6 false friends, max 9
    if n_false_friends >= 5:
        risk_level = "ğŸ”´ MUITO VULNERÃVEL"
        risk_color = "#dc3545"
    elif n_false_friends >= 3:
        risk_level = "ğŸŸ  VULNERÃVEL"
        risk_color = "#fd7e14"
    elif n_false_friends >= 1:
        risk_level = "ğŸŸ¡ ATENÃ‡ÃƒO"
        risk_color = "#ffc107"
    else:
        risk_level = "ğŸŸ¢ PROTEGIDO"
        risk_color = "#28a745"

    # Get avatar
    avatar_url = AVATARS.get(name, '')
    cor_grupo = GROUP_COLORS.get(member_of, '#666')

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PROFILE CARD - Using HTML tables for better formatting
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print(f'''
<div style="margin-top: 2rem; margin-bottom: 1rem; border: 1px solid #444; border-radius: 12px; overflow: hidden; background: #2a2a2a;">

<!-- Header with avatar -->
<div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: linear-gradient(90deg, rgba(48,48,48,0.9), rgba(48,48,48,0.3)); border-left: 5px solid {cor_grupo};">
''')
    if avatar_url:
        print(f'<img src="{avatar_url}" alt="{name}" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid {cor_grupo}; flex-shrink: 0;">')

    role_text = f" | {', '.join(roles)}" if roles else ""
    print(f'''
<div>
<h3 style="margin: 0 0 0.3rem 0; color: #fff; font-size: 1.4em;">{name} <span style="font-size: 0.5em; padding: 3px 10px; border-radius: 4px; background: {risk_color}; color: #fff; vertical-align: middle; font-weight: bold;">{risk_level}</span></h3>
<div style="color: #aaa; font-size: 0.95em;">
<strong style="color: {cor_grupo};">{member_of}</strong> | {group} | Saldo: {balance:,} | Sentimento: <strong style="color: {'#28a745' if score >= 0 else '#dc3545'};">{score:+.1f}</strong>{role_text}
</div>
</div>
</div>

<!-- Reactions -->
<div style="padding: 0.8rem 1rem; border-bottom: 1px solid #444; background: #333;">
<div style="display: flex; flex-wrap: wrap; gap: 1.5rem;">
<div><strong style="color: #888;">Recebeu:</strong> {' '.join(rxn_summary)}</div>
<div><strong style="color: #888;">Deu:</strong> {given_summary}</div>
</div>
</div>

<!-- Strategic Map -->
<div style="padding: 1rem;">
<h4 style="margin: 0 0 0.8rem 0; color: #fff; font-size: 1em; border-bottom: 1px solid #444; padding-bottom: 0.5rem;">ğŸ—ºï¸ Mapa EstratÃ©gico</h4>
''')

    # Allies
    if allies:
        allies_str = ', '.join(sorted(allies))
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(40, 167, 69, 0.1); border-radius: 6px; border-left: 3px solid #28a745;">
<div style="font-weight: bold; color: #28a745; margin-bottom: 0.3rem;">âœ… Aliados ({n_allies})</div>
<div style="color: #ccc; font-size: 0.9em;">{allies_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Votos seguros. NÃ£o votarÃ£o contra.</div>
</div>
''')

    # Enemies
    if enemies:
        enemy_items = [f"{n} <span style='color:#888;'>({me}â†”{te})</span>" for n, me, te in sorted(enemies, key=lambda x: x[0])]
        enemies_str = ', '.join(enemy_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(220, 53, 69, 0.1); border-radius: 6px; border-left: 3px solid #dc3545;">
<div style="font-weight: bold; color: #dc3545; margin-bottom: 0.3rem;">âš”ï¸ Inimigos Declarados ({n_enemies})</div>
<div style="color: #ccc; font-size: 0.9em;">{enemies_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Hostilidade mÃºtua. Votos contra esperados de ambos os lados.</div>
</div>
''')

    # False Friends - DANGER
    if false_friends:
        ff_items = [f"<strong>{n}</strong> <span style='color:#dc3545;'>({e})</span>" for n, e in sorted(false_friends, key=lambda x: x[0])]
        ff_str = ', '.join(ff_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(255, 193, 7, 0.15); border-radius: 6px; border-left: 3px solid #ffc107;">
<div style="font-weight: bold; color: #ffc107; margin-bottom: 0.3rem;">âš ï¸ Falsos Amigos ({n_false_friends}) â€” PERIGO!</div>
<div style="color: #ccc; font-size: 0.9em;">{ff_str}</div>
<div style="color: #dc3545; font-size: 0.8em; margin-top: 0.3rem;">â†’ {first_name} dÃ¡ â¤ï¸ mas recebe negatividade. Podem votar contra sem que {first_name} espere!</div>
</div>
''')

    # Blind Targets - Undeclared enemies (they don't know)
    if blind_targets:
        bt_items = [f"{n} <span style='color:#6f42c1;'>({e})</span>" for n, e in sorted(blind_targets, key=lambda x: x[0])]
        bt_str = ', '.join(bt_items)
        print(f'''
<div style="margin-bottom: 0.8rem; padding: 0.6rem; background: rgba(111, 66, 193, 0.1); border-radius: 6px; border-left: 3px solid #6f42c1;">
<div style="font-weight: bold; color: #6f42c1; margin-bottom: 0.3rem;">ğŸ—¡ï¸ Inimigos NÃ£o Declarados ({n_blind_targets})</div>
<div style="color: #ccc; font-size: 0.9em;">{bt_str}</div>
<div style="color: #6c757d; font-size: 0.8em; margin-top: 0.3rem;">â†’ Eles dÃ£o â¤ï¸ para {first_name}, mas {first_name} Ã© hostil. Eles nÃ£o sabem que sÃ£o alvos.</div>
</div>
''')

    # Game Analysis
    insights = []
    if n_false_friends == 0 and n_enemies == 0:
        insights.append("ğŸ›¡ï¸ PosiÃ§Ã£o confortÃ¡vel: sem inimigos e sem falsos amigos.")
    if n_false_friends >= 3:
        insights.append(f"ğŸš¨ <strong style='color:#dc3545;'>PosiÃ§Ã£o vulnerÃ¡vel</strong>: {n_false_friends} pessoas que considera amigas sÃ£o hostis.")
    elif n_false_friends >= 1:
        insights.append(f"âš¡ AtenÃ§Ã£o: {n_false_friends} falso(s) amigo(s) pode(m) surpreender em votaÃ§Ã£o.")
    if n_blind_targets >= 3:
        insights.append(f"ğŸ—¡ï¸ {n_blind_targets} inimigos nÃ£o declarados: confiam em {first_name} sem saber que sÃ£o alvos.")
    if n_enemies >= 3:
        insights.append(f"ğŸ”¥ Polarizante: {n_enemies} inimigos declarados. Alvo provÃ¡vel em paredÃµes.")
    if n_allies >= 10 and total_relations > 0:
        pct = n_allies * 100 // total_relations
        insights.append(f"ğŸ’ª Base sÃ³lida: {n_allies} aliados ({pct}% das relaÃ§Ãµes).")

    if insights:
        print(f'''
<div style="padding: 0.6rem; background: #383838; border-radius: 6px; margin-top: 0.5rem;">
<div style="font-weight: bold; color: #fff; margin-bottom: 0.4rem; font-size: 0.9em;">ğŸ“Š AnÃ¡lise de Jogo</div>
<ul style="margin: 0; padding-left: 1.2rem; color: #ccc; font-size: 0.85em;">
''')
        for insight in insights:
            print(f'<li style="margin-bottom: 0.2rem;">{insight}</li>')
        print('</ul></div>')

    print('</div></div>')  # Close strategic map and card
```

---

<div class="alert alert-info" role="alert">
<strong>ğŸ’¡ Sobre este painel:</strong> Este painel acompanha as reaÃ§Ãµes do queridÃ´metro do BBB 26. As reaÃ§Ãµes <strong>mudam diariamente</strong> â€” os participantes podem trocar suas escolhas a cada Raio-X. SeÃ§Ãµes marcadas com ğŸ“¸ mostram apenas o dia mais recente; seÃ§Ãµes marcadas com ğŸ“ˆ mostram a evoluÃ§Ã£o ao longo do tempo. Acompanhamento desde 13 de janeiro de 2026.
</div>
