---
title: "BBB 26 â€” Painel de ReaÃ§Ãµes"
subtitle: "AnÃ¡lise das reaÃ§Ãµes entre os participantes do Big Brother Brasil 2026"
author: "Dashboard Automatizado"
date: today
lang: pt-BR
format:
  html:
    code-fold: true
    code-summary: "Ver cÃ³digo"
    toc: true
    toc-depth: 3
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

REACTION_SLUG_TO_LABEL = {
    'coracao': 'CoraÃ§Ã£o', 'planta': 'Planta', 'mala': 'Mala', 'biscoito': 'Biscoito',
    'cobra': 'Cobra', 'alvo': 'Alvo', 'vomito': 'VÃ´mito', 'mentiroso': 'Mentiroso',
    'coracao-partido': 'CoraÃ§Ã£o partido'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0, 'CoraÃ§Ã£o partido': -1.0
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito'}
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso', 'CoraÃ§Ã£o partido'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}  # preenchido ao carregar dados
```

```{python}
#| label: load-data

def load_snapshot(filepath):
    """Carrega um snapshot JSON (formato novo ou antigo)."""
    with open(filepath, encoding="utf-8") as f:
        data = json.load(f)
    if isinstance(data, dict) and "participants" in data:
        return data["participants"], data.get("_metadata")
    return data, None

def get_all_snapshots():
    """Retorna lista de (filepath, date_str) ordenada cronologicamente."""
    if not DATA_DIR.exists():
        return []
    snapshots = sorted(DATA_DIR.glob("*.json"))
    result = []
    for fp in snapshots:
        parts = fp.stem.split("_")
        date_str = parts[0]
        result.append((fp, date_str))
    return result

def parse_roles(roles_data):
    """Extrai nomes de roles (pode ser lista de strings ou lista de dicts)."""
    if not roles_data:
        return []
    result = []
    for r in roles_data:
        if isinstance(r, str):
            result.append(r)
        elif isinstance(r, dict):
            result.append(r.get('label', str(r)))
    return result

def build_reaction_matrix(participants):
    """ConstrÃ³i dicionÃ¡rio {(giver_name, receiver_name): reaction_label}."""
    matrix = {}
    for receiver in participants:
        rname = receiver['name']
        for rxn in receiver.get('characteristics', {}).get('receivedReactions', []):
            label = rxn.get('label', '')
            for giver in rxn.get('participants', []):
                gname = giver['name']
                matrix[(gname, rname)] = label
    return matrix

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]
```

# VisÃ£o Geral {#visao-geral}

O **Big Brother Brasil 26** estreou em 12 de janeiro de 2026 com um formato inÃ©dito: trÃªs grupos â€” **Camarote** (famosos), **Veteranos** (ex-BBBs) e **Pipoca** (anÃ´nimos escolhidos pelo pÃºblico via Casas de Vidro nas 5 regiÃµes do Brasil). Os participantes dÃ£o reaÃ§Ãµes uns aos outros diariamente, e essas reaÃ§Ãµes **mudam todos os dias** â€” nÃ£o sÃ£o cumulativas.

```{python}
#| label: overview-stats

active = [p for p in latest['participants'] if not p.get('characteristics', {}).get('eliminated')]
n_active = len(active)

# Contar por grupo
groups = Counter(p.get('characteristics', {}).get('memberOf', '?') for p in active)

# Todas as reaÃ§Ãµes do Ãºltimo snapshot
total_reactions = sum(
    rxn.get('amount', 0)
    for p in active
    for rxn in p.get('characteristics', {}).get('receivedReactions', [])
)

print(f"ğŸ“Š **{n_snapshots} snapshots** analisados (13 a 24 de janeiro de 2026)")
print(f"ğŸ‘¥ **{n_active} participantes ativos** â€” ", end="")
print(" | ".join(f"{g}: {c}" for g, c in sorted(groups.items())))
print(f"ğŸ’¬ **{total_reactions} reaÃ§Ãµes** registradas no Ãºltimo snapshot")
print(f"ğŸ“… Ãšltimo dado: **{latest['date']}**")
```

## Cronologia do Jogo

```{python}
#| label: timeline-events

events_data = []
all_names_seen = set()

for i, snap in enumerate(snapshots):
    current_names = set(p['name'] for p in snap['participants'])
    active_names = set(p['name'] for p in snap['participants']
                       if not p.get('characteristics', {}).get('eliminated'))

    if i > 0:
        prev_names = set(p['name'] for p in snapshots[i-1]['participants'])
        appeared = current_names - prev_names
        disappeared = prev_names - current_names

        if appeared:
            events_data.append({
                'Data': snap['date'],
                'Evento': f"âœ… Entraram: {', '.join(sorted(appeared))}",
                'Participantes': len(active_names)
            })
        if disappeared:
            for name in disappeared:
                events_data.append({
                    'Data': snap['date'],
                    'Evento': f"âŒ Saiu: {name}",
                    'Participantes': len(active_names)
                })

    # Detectar roles especiais
    for p in snap['participants']:
        roles = parse_roles(p.get('characteristics', {}).get('roles', []))
        for role in roles:
            if role in ('LÃ­der', 'ParedÃ£o') and i > 0:
                prev_snap_p = {pp['name']: pp for pp in snapshots[i-1]['participants']}
                if p['name'] in prev_snap_p:
                    prev_roles = parse_roles(prev_snap_p[p['name']].get('characteristics', {}).get('roles', []))
                    if role not in prev_roles:
                        events_data.append({
                            'Data': snap['date'],
                            'Evento': f"ğŸ† {p['name']} â†’ {role}",
                            'Participantes': len(active_names)
                        })

    all_names_seen |= current_names

if events_data:
    df_events = pd.DataFrame(events_data).drop_duplicates()
    # Mostrar apenas eventos importantes (entradas/saÃ­das/roles)
    key_events = df_events[df_events['Evento'].str.contains('Entraram|Saiu|LÃ­der')]
    if not key_events.empty:
        display(key_events.style.hide(axis='index'))
```

## Resultado do ParedÃ£o

::: {.callout-warning}
**Dados manuais:** Os resultados do ParedÃ£o nÃ£o vÃªm da API de reaÃ§Ãµes â€” sÃ£o coletados manualmente de fontes pÃºblicas (GShow, transmissÃ£o ao vivo). Para manter o painel atualizado, edite a seÃ§Ã£o `paredao_data` no cÃ³digo abaixo a cada eliminaÃ§Ã£o.
:::

```{python}
#| label: paredao-results
#| output: asis

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  DADOS MANUAIS â€” Atualizar a cada novo ParedÃ£o             â•‘
# â•‘  Fonte: GShow / transmissÃ£o ao vivo                        â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

paredoes = [
    {
        'numero': 1,
        'data': '2026-01-20',
        'titulo': '1Âº ParedÃ£o â€” 20 de Janeiro de 2026',
        'formacao': (
            "Marcelo atendeu o Big Fone e indicou Aline Campos, "
            "que contra-atacou Ana Paula Renault. O LÃ­der Alberto Cowboy indicou Milena. "
            "Paulo Augusto, mais votado pela casa, escapou na Prova Bate e Volta."
        ),
        'participantes': [
            {'nome': 'Aline Campos', 'voto_total': 61.64, 'resultado': 'ELIMINADA', 'grupo': 'Camarote'},
            {'nome': 'Milena', 'voto_total': 32.50, 'resultado': 'Salva', 'grupo': 'Pipoca'},
            {'nome': 'Ana Paula Renault', 'voto_total': 5.86, 'resultado': 'Salva', 'grupo': 'Veterano'},
        ],
        # TODO: Preencher quando disponÃ­vel
        # 'voto_unico_pct': {'Aline Campos': ..., 'Milena': ..., 'Ana Paula Renault': ...},
        # 'voto_torcida_pct': {'Aline Campos': ..., 'Milena': ..., 'Ana Paula Renault': ...},
    },
    # Adicionar novos paredÃµes aqui:
    # {
    #     'numero': 2,
    #     'data': '2026-01-27',
    #     'titulo': '2Âº ParedÃ£o â€” 27 de Janeiro de 2026',
    #     'formacao': '...',
    #     'participantes': [...],
    # },
]

for paredao in paredoes:
    df_p = pd.DataFrame(paredao['participantes'])

    colors = ['#E6194B' if r == 'ELIMINADA' else '#3CB44B' for r in df_p['resultado']]

    fig = go.Figure()

    fig.add_trace(go.Bar(
        x=df_p['nome'],
        y=df_p['voto_total'],
        text=[f"{v:.1f}%" for v in df_p['voto_total']],
        textposition='outside',
        marker_color=colors,
        hovertemplate='%{x}: %{y:.1f}%<extra></extra>',
        name='Total'
    ))

    fig.update_layout(
        title=paredao['titulo'],
        xaxis_title="",
        yaxis_title="Votos (%)",
        yaxis_range=[0, max(df_p['voto_total']) * 1.2],
        template="plotly_white",
        height=400,
        annotations=[
            dict(
                text="ğŸ”´ = Eliminada | ğŸŸ¢ = Salva",
                xref="paper", yref="paper",
                x=1, y=1.08, showarrow=False,
                font=dict(size=12)
            )
        ]
    )

    fig.show()

    # Mostrar formaÃ§Ã£o
    print(f"\n**Como foi formado:** {paredao['formacao']}")
```

# Ranking de Sentimento {#ranking}

Cada participante recebe reaÃ§Ãµes dos demais. O **score de sentimento** pondera: â¤ï¸ = +1, reaÃ§Ãµes leves (ğŸŒ±ğŸ’¼ğŸª) = -0.5, reaÃ§Ãµes fortes (ğŸğŸ¯ğŸ¤®ğŸ¤¥ğŸ’”) = -1.

```{python}
#| label: sentiment-ranking

# Calcular sentimento do Ãºltimo snapshot
sentiment_data = []
for p in latest['participants']:
    if p.get('characteristics', {}).get('eliminated'):
        continue
    name = p['name']
    score = calc_sentiment(p)
    hearts = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
                 if r['label'] == 'CoraÃ§Ã£o')
    neg = sum(r['amount'] for r in p['characteristics'].get('receivedReactions', [])
              if r['label'] != 'CoraÃ§Ã£o')
    member_of = p.get('characteristics', {}).get('memberOf', '?')
    sentiment_data.append({
        'name': name, 'score': score, 'hearts': hearts,
        'negative': neg, 'memberOf': member_of
    })

df_sent = pd.DataFrame(sentiment_data).sort_values('score', ascending=True)

# Plotar com Plotly
color_map = {name: GROUP_COLORS.get(m, '#999')
             for name, m in zip(df_sent['name'], df_sent['memberOf'])}

fig = go.Figure()

fig.add_trace(go.Bar(
    y=df_sent['name'],
    x=df_sent['score'],
    orientation='h',
    marker_color=[color_map[n] for n in df_sent['name']],
    text=[f"{s:+.1f}" for s in df_sent['score']],
    textposition='outside',
    hovertemplate='%{y}: %{x:+.1f}<br>â¤ï¸: %{customdata[0]} | Neg: %{customdata[1]}<extra></extra>',
    customdata=list(zip(df_sent['hearts'], df_sent['negative']))
))

fig.update_layout(
    title=f"Ranking de Sentimento â€” {latest['date']}",
    xaxis_title="Score de Sentimento",
    yaxis_title="",
    template="plotly_white",
    height=max(500, len(df_sent) * 28),
    margin=dict(l=150),
    shapes=[dict(type='line', x0=0, x1=0, y0=-0.5, y1=len(df_sent)-0.5,
                 line=dict(color='red', dash='dash', width=1))]
)

# Legenda de cores
for group, color in GROUP_COLORS.items():
    fig.add_trace(go.Scatter(
        x=[None], y=[None], mode='markers',
        marker=dict(size=10, color=color),
        name=group, showlegend=True
    ))

fig.show()
```

# EvoluÃ§Ã£o do Sentimento {#evolucao}

Como o sentimento de cada participante mudou ao longo do tempo.

```{python}
#| label: sentiment-timeline

# Calcular sentimento para cada participante em cada snapshot
timeline_data = []
for i, snap in enumerate(snapshots):
    for p in snap['participants']:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        name = p['name']
        score = calc_sentiment(p)
        timeline_data.append({
            'Data': pd.to_datetime(snap['date']),
            'Participante': name,
            'Sentimento': score,
            'Grupo': p.get('characteristics', {}).get('memberOf', '?')
        })

df_timeline = pd.DataFrame(timeline_data)

if not df_timeline.empty:
    # Paleta com cores distintas para cada participante
    all_participants = sorted(df_timeline['Participante'].unique())
    palette = (
        px.colors.qualitative.Plotly + px.colors.qualitative.D3 +
        px.colors.qualitative.Set2 + px.colors.qualitative.Bold
    )
    participant_colors = {name: palette[i % len(palette)] for i, name in enumerate(all_participants)}

    # Top 3 e bottom 3 pelo Ãºltimo score â€” visÃ­veis por padrÃ£o
    latest_scores = df_timeline.groupby('Participante')['Sentimento'].last()
    top3 = set(latest_scores.nlargest(3).index)
    bottom3 = set(latest_scores.nsmallest(3).index)
    highlight = top3 | bottom3

    fig = go.Figure()

    for name in all_participants:
        df_p = df_timeline[df_timeline['Participante'] == name].sort_values('Data')
        is_hl = name in highlight

        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Sentimento'],
            mode='lines+markers',
            name=name,
            line=dict(width=3 if is_hl else 1.5, color=participant_colors[name]),
            marker=dict(size=6 if is_hl else 4),
            hovertemplate=f'{name}: ' + '%{y:+.1f}<extra></extra>',
            visible=True if is_hl else 'legendonly',
        ))

    fig.update_layout(
        title="EvoluÃ§Ã£o do Sentimento ao Longo do Tempo",
        xaxis_title="Data",
        yaxis_title="Score de Sentimento",
        template="plotly_white",
        height=600,
        hovermode='x unified',
        legend=dict(font=dict(size=10), itemsizing='constant'),
        shapes=[dict(type='line', x0=df_timeline['Data'].min(), x1=df_timeline['Data'].max(),
                     y0=0, y1=0, line=dict(color='red', dash='dash', width=1))]
    )

    fig.show()
```

# Tabela Cruzada de ReaÃ§Ãµes {#crosstable}

Quem deu qual reaÃ§Ã£o para quem. Cada cÃ©lula mostra a reaÃ§Ã£o que a **linha** (emissor) deu para a **coluna** (receptor).

```{python}
#| label: cross-table

# Construir cross-table do Ãºltimo snapshot
active_names = sorted([p['name'] for p in latest['participants']
                        if not p.get('characteristics', {}).get('eliminated')])

# Criar DataFrame com emojis
cross_data = []
for giver in active_names:
    row = {'Emissor': giver}
    for receiver in active_names:
        if giver == receiver:
            row[receiver] = 'â€”'
        else:
            rxn = latest_matrix.get((giver, receiver), '')
            row[receiver] = REACTION_EMOJI.get(rxn, '?')
    cross_data.append(row)

df_cross = pd.DataFrame(cross_data).set_index('Emissor')

# VersÃ£o com heatmap numÃ©rico para Plotly
heat_data = np.zeros((len(active_names), len(active_names)))
rxn_labels = []
for i, giver in enumerate(active_names):
    row_labels = []
    for j, receiver in enumerate(active_names):
        if giver == receiver:
            heat_data[i, j] = np.nan
            row_labels.append('â€”')
        else:
            rxn = latest_matrix.get((giver, receiver), '')
            weight = SENTIMENT_WEIGHTS.get(rxn, 0)
            heat_data[i, j] = weight
            emoji = REACTION_EMOJI.get(rxn, '?')
            row_labels.append(emoji)
    rxn_labels.append(row_labels)

# Usar nomes curtos
short_names = [n.split()[0] if len(n) > 12 else n for n in active_names]

fig = go.Figure(data=go.Heatmap(
    z=heat_data,
    x=short_names,
    y=short_names,
    colorscale=[
        [0, '#d73027'],     # -1.0 (forte negativo)
        [0.25, '#fc8d59'],  # -0.5 (leve negativo)
        [0.5, '#ffffbf'],   #  0.0 (neutro)
        [1.0, '#1a9850'],   # +1.0 (positivo)
    ],
    zmin=-1, zmax=1,
    text=[[rxn_labels[i][j] for j in range(len(active_names))] for i in range(len(active_names))],
    texttemplate='%{text}',
    textfont=dict(size=9),
    hovertemplate='%{y} â†’ %{x}: %{text}<extra></extra>',
    colorbar=dict(title="Sentimento", tickvals=[-1, -0.5, 0, 1],
                  ticktext=['Forte Neg', 'Leve Neg', 'Neutro', 'Positivo'])
))

fig.update_layout(
    title=f"Mapa de ReaÃ§Ãµes â€” {latest['date']}",
    xaxis_title="Receptor â†",
    yaxis_title="Emissor â†’",
    height=700,
    width=900,
    template="plotly_white",
    xaxis=dict(tickangle=45, side='bottom'),
    yaxis=dict(autorange='reversed')
)

fig.show()
```

```{python}
#| label: cross-table-summary
#| output: asis

# Resumo: total de cada reaÃ§Ã£o por participante
print("\n### ReaÃ§Ãµes Recebidas por Participante\n")

summary_rows = []
for p in sorted(latest['participants'], key=lambda x: calc_sentiment(x), reverse=True):
    if p.get('characteristics', {}).get('eliminated'):
        continue
    name = p['name']
    rxn_counts = {}
    for rxn in p.get('characteristics', {}).get('receivedReactions', []):
        emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
        rxn_counts[emoji] = rxn['amount']
    score = calc_sentiment(p)
    summary_rows.append({
        'Participante': name,
        'â¤ï¸': rxn_counts.get('â¤ï¸', 0),
        'ğŸŒ±': rxn_counts.get('ğŸŒ±', 0),
        'ğŸ’¼': rxn_counts.get('ğŸ’¼', 0),
        'ğŸª': rxn_counts.get('ğŸª', 0),
        'ğŸ': rxn_counts.get('ğŸ', 0),
        'ğŸ¯': rxn_counts.get('ğŸ¯', 0),
        'ğŸ¤®': rxn_counts.get('ğŸ¤®', 0),
        'ğŸ¤¥': rxn_counts.get('ğŸ¤¥', 0),
        'ğŸ’”': rxn_counts.get('ğŸ’”', 0),
        'Score': f"{score:+.1f}"
    })

df_summary = pd.DataFrame(summary_rows)
print(df_summary.to_markdown(index=False))
```

# AlianÃ§as e Rivalidades {#aliancas}

## AlianÃ§as Mais Consistentes

Pares que trocaram â¤ï¸ mÃºtuo na maior quantidade de snapshots.

```{python}
#| label: alliances

# Calcular alianÃ§as mÃºtuas ao longo do tempo
mutual_heart_history = defaultdict(int)
mutual_neg_history = defaultdict(int)
total_coexist = defaultdict(int)

for idx, matrix in enumerate(all_matrices):
    snap = snapshots[idx]
    active_set = set(p['name'] for p in snap['participants']
                     if not p.get('characteristics', {}).get('eliminated'))

    checked_heart = set()
    checked_neg = set()

    for (giver, receiver), label in matrix.items():
        if giver not in active_set or receiver not in active_set:
            continue
        pair = tuple(sorted([giver, receiver]))
        total_coexist[pair] += 1  # conta dobrada mas consistente

        if pair not in checked_heart and label == 'CoraÃ§Ã£o':
            reverse = matrix.get((receiver, giver))
            if reverse == 'CoraÃ§Ã£o':
                mutual_heart_history[pair] += 1
                checked_heart.add(pair)

        if pair not in checked_neg and label not in POSITIVE:
            reverse = matrix.get((receiver, giver))
            if reverse is not None and reverse not in POSITIVE:
                mutual_neg_history[pair] += 1
                checked_neg.add(pair)

# Top alianÃ§as
top_alliances = sorted(mutual_heart_history.items(), key=lambda x: -x[1])[:15]

alliance_data = []
for (a, b), count in top_alliances:
    alliance_data.append({
        'Par': f"{a} â†” {b}",
        'Snapshots com â¤ï¸ mÃºtuo': count,
        'Total de snapshots': n_snapshots,
        'ConsistÃªncia': f"{count/n_snapshots*100:.0f}%"
    })

df_alliances = pd.DataFrame(alliance_data)

fig = go.Figure(go.Bar(
    x=[a['Snapshots com â¤ï¸ mÃºtuo'] for a in alliance_data],
    y=[a['Par'] for a in alliance_data],
    orientation='h',
    marker_color='#1a9850',
    text=[a['ConsistÃªncia'] for a in alliance_data],
    textposition='outside',
    hovertemplate='%{y}: â¤ï¸ mÃºtuo em %{x}/' + str(n_snapshots) + ' snapshots<extra></extra>'
))

fig.update_layout(
    title="Top 15 AlianÃ§as Mais Consistentes (â¤ï¸ MÃºtuo)",
    xaxis_title=f"Snapshots com â¤ï¸ mÃºtuo (de {n_snapshots})",
    yaxis_title="",
    template="plotly_white",
    height=500,
    margin=dict(l=250),
    xaxis_range=[0, n_snapshots + 1]
)

fig.show()
```

## Rivalidades Mais Persistentes

Pares que trocaram reaÃ§Ãµes negativas mÃºtuas na maior quantidade de snapshots.

```{python}
#| label: rivalries

top_rivalries = sorted(mutual_neg_history.items(), key=lambda x: -x[1])[:15]

rivalry_data = []
for (a, b), count in top_rivalries:
    rivalry_data.append({
        'Par': f"{a} vs {b}",
        'Snapshots com rivalidade': count,
        'Total': n_snapshots,
        'PersistÃªncia': f"{count/n_snapshots*100:.0f}%"
    })

if rivalry_data:
    fig = go.Figure(go.Bar(
        x=[r['Snapshots com rivalidade'] for r in rivalry_data],
        y=[r['Par'] for r in rivalry_data],
        orientation='h',
        marker_color='#d73027',
        text=[r['PersistÃªncia'] for r in rivalry_data],
        textposition='outside',
        hovertemplate='%{y}: rivalidade em %{x}/' + str(n_snapshots) + ' snapshots<extra></extra>'
    ))

    fig.update_layout(
        title="Top 15 Rivalidades Mais Persistentes (Negativa MÃºtua)",
        xaxis_title=f"Snapshots com rivalidade (de {n_snapshots})",
        yaxis_title="",
        template="plotly_white",
        height=500,
        margin=dict(l=300),
        xaxis_range=[0, n_snapshots + 1]
    )

    fig.show()
```

## Grafo de RelaÃ§Ãµes

Rede mostrando alianÃ§as (â¤ï¸ mÃºtuo = verde) e rivalidades (negativa mÃºtua = vermelho) no Ãºltimo snapshot.

```{python}
#| label: network-graph

import networkx as nx

G = nx.Graph()

active_names_net = [p['name'] for p in latest['participants']
                     if not p.get('characteristics', {}).get('eliminated')]

for name in active_names_net:
    member_of = MEMBER_OF.get(name, '?')
    G.add_node(name, group=member_of)

# Adicionar arestas de alianÃ§a e rivalidade
checked = set()
for (giver, receiver), label in latest_matrix.items():
    pair = tuple(sorted([giver, receiver]))
    if pair in checked:
        continue
    checked.add(pair)

    reverse = latest_matrix.get((receiver, giver))
    if label == 'CoraÃ§Ã£o' and reverse == 'CoraÃ§Ã£o':
        G.add_edge(giver, receiver, weight=1, color='green', relation='alliance')
    elif label not in POSITIVE and reverse is not None and reverse not in POSITIVE:
        G.add_edge(giver, receiver, weight=1, color='red', relation='rivalry')

pos = nx.spring_layout(G, k=2.5, iterations=80, seed=42)

# Separar arestas por tipo
edge_traces = []
for edge_type, color, dash in [('alliance', '#2ca02c', 'solid'), ('rivalry', '#d62728', 'dash')]:
    edge_x, edge_y = [], []
    for u, v, data in G.edges(data=True):
        if data.get('relation') != edge_type:
            continue
        x0, y0 = pos[u]
        x1, y1 = pos[v]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])

    edge_traces.append(go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=1.5, color=color, dash=dash),
        hoverinfo='none',
        mode='lines',
        name='AlianÃ§a (â¤ï¸ mÃºtuo)' if edge_type == 'alliance' else 'Rivalidade (neg. mÃºtua)',
        showlegend=True
    ))

# NÃ³s
node_x = [pos[n][0] for n in G.nodes()]
node_y = [pos[n][1] for n in G.nodes()]
node_colors = [GROUP_COLORS.get(G.nodes[n].get('group', '?'), '#999') for n in G.nodes()]
node_text = list(G.nodes())

# Score de sentimento para tamanho
sent_scores = {}
for p in latest['participants']:
    if not p.get('characteristics', {}).get('eliminated'):
        sent_scores[p['name']] = calc_sentiment(p)

node_sizes = [max(10, min(35, 15 + sent_scores.get(n, 0))) for n in G.nodes()]

node_trace = go.Scatter(
    x=node_x, y=node_y,
    mode='markers+text',
    text=[n.split()[0] for n in node_text],
    textposition='top center',
    textfont=dict(size=9),
    marker=dict(size=node_sizes, color=node_colors, line=dict(width=1, color='white')),
    hovertemplate='%{hovertext}<extra></extra>',
    hovertext=[f"{n}<br>Grupo: {G.nodes[n].get('group','?')}<br>Sentimento: {sent_scores.get(n,0):+.1f}" for n in G.nodes()],
    showlegend=False
)

fig = go.Figure(data=edge_traces + [node_trace])

fig.update_layout(
    title=f"Grafo de RelaÃ§Ãµes â€” {latest['date']}",
    template="plotly_white",
    height=650,
    showlegend=True,
    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    annotations=[
        dict(text="Tamanho do nÃ³ = sentimento | Cor = grupo (ğŸ”´ Camarote, ğŸŸ¢ Veterano, ğŸ”µ Pipoca)",
             xref="paper", yref="paper", x=0.5, y=-0.05, showarrow=False, font=dict(size=11))
    ]
)

fig.show()
```

# DinÃ¢mica das ReaÃ§Ãµes {#dinamica}

## MudanÃ§as Entre Snapshots

Quantas reaÃ§Ãµes mudaram entre cada par de snapshots consecutivos.

```{python}
#| label: reaction-changes

change_counts = []
for i in range(1, len(snapshots)):
    prev_m = all_matrices[i-1]
    curr_m = all_matrices[i]

    common_pairs = set(prev_m.keys()) & set(curr_m.keys())
    changes = sum(1 for pair in common_pairs if prev_m[pair] != curr_m[pair])
    pos_to_neg = sum(1 for pair in common_pairs
                     if prev_m[pair] in POSITIVE and curr_m[pair] not in POSITIVE)
    neg_to_pos = sum(1 for pair in common_pairs
                     if prev_m[pair] not in POSITIVE and curr_m[pair] in POSITIVE)

    change_counts.append({
        'TransiÃ§Ã£o': f"{snapshots[i-1]['date']} â†’ {snapshots[i]['date']}",
        'Data': pd.to_datetime(snapshots[i]['date']),
        'Total': changes,
        'â¤ï¸â†’Neg': pos_to_neg,
        'Negâ†’â¤ï¸': neg_to_pos
    })

df_changes = pd.DataFrame(change_counts)

if not df_changes.empty:
    fig = go.Figure()

    fig.add_trace(go.Bar(
        x=df_changes['TransiÃ§Ã£o'], y=df_changes['â¤ï¸â†’Neg'],
        name='â¤ï¸ â†’ Negativa', marker_color='#d73027'
    ))
    fig.add_trace(go.Bar(
        x=df_changes['TransiÃ§Ã£o'], y=df_changes['Negâ†’â¤ï¸'],
        name='Negativa â†’ â¤ï¸', marker_color='#1a9850'
    ))

    fig.update_layout(
        title="MudanÃ§as de ReaÃ§Ã£o Entre Snapshots",
        xaxis_title="", yaxis_title="Quantidade de mudanÃ§as",
        barmode='group',
        template="plotly_white",
        height=400,
        xaxis=dict(tickangle=45)
    )

    fig.show()
```

## Quem Muda Mais de OpiniÃ£o? ("Vira-Casacas")

Participantes que mais mudaram suas reaÃ§Ãµes ao longo do tempo.

```{python}
#| label: flip-floppers

giver_change_count = Counter()
for i in range(1, len(snapshots)):
    prev_m = all_matrices[i-1]
    curr_m = all_matrices[i]
    common_pairs = set(prev_m.keys()) & set(curr_m.keys())
    for pair in common_pairs:
        if prev_m[pair] != curr_m[pair]:
            giver_change_count[pair[0]] += 1

# Normalizar pelo nÃºmero de transiÃ§Ãµes em que estiveram ativos
giver_transitions = Counter()
for i in range(1, len(snapshots)):
    prev_active = set(p['name'] for p in snapshots[i-1]['participants']
                      if not p.get('characteristics', {}).get('eliminated'))
    curr_active = set(p['name'] for p in snapshots[i]['participants']
                      if not p.get('characteristics', {}).get('eliminated'))
    for name in prev_active & curr_active:
        giver_transitions[name] += 1

flipflop_data = []
for name, changes in giver_change_count.most_common():
    trans = giver_transitions.get(name, 1)
    if trans >= 3:  # mÃ­nimo de 3 transiÃ§Ãµes
        flipflop_data.append({
            'Participante': name,
            'MudanÃ§as': changes,
            'TransiÃ§Ãµes': trans,
            'Taxa': round(changes / trans, 1)
        })

df_flip = pd.DataFrame(flipflop_data).sort_values('MudanÃ§as', ascending=True)

if not df_flip.empty:
    fig = go.Figure(go.Bar(
        y=df_flip['Participante'],
        x=df_flip['MudanÃ§as'],
        orientation='h',
        marker_color=[GROUP_COLORS.get(MEMBER_OF.get(n, '?'), '#999')
                      for n in df_flip['Participante']],
        text=[f"{m} ({t:.1f}/snap)" for m, t in zip(df_flip['MudanÃ§as'], df_flip['Taxa'])],
        textposition='outside',
        hovertemplate='%{y}: %{x} mudanÃ§as totais<extra></extra>'
    ))

    fig.update_layout(
        title="Vira-Casacas: Quem Muda Mais de OpiniÃ£o?",
        xaxis_title="Total de mudanÃ§as de reaÃ§Ã£o",
        yaxis_title="",
        template="plotly_white",
        height=max(400, len(df_flip) * 25),
        margin=dict(l=150)
    )

    fig.show()
```

# Saldo e Economia {#saldo}

## EvoluÃ§Ã£o do Saldo

O saldo (Estalecas) de cada participante ao longo do tempo.

```{python}
#| label: balance-timeline

balance_data = []
for i, snap in enumerate(snapshots):
    for p in snap['participants']:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        balance_data.append({
            'Data': pd.to_datetime(snap['date']),
            'Participante': p['name'],
            'Saldo': p.get('characteristics', {}).get('balance', 0),
            'Grupo': p.get('characteristics', {}).get('memberOf', '?')
        })

df_balance = pd.DataFrame(balance_data)

if not df_balance.empty:
    # Paleta com cores distintas para cada participante
    all_bal_participants = sorted(df_balance['Participante'].unique())
    palette_bal = (
        px.colors.qualitative.Plotly + px.colors.qualitative.D3 +
        px.colors.qualitative.Set2 + px.colors.qualitative.Bold
    )
    bal_colors = {name: palette_bal[i % len(palette_bal)] for i, name in enumerate(all_bal_participants)}

    # Top 3 e bottom 3 pelo Ãºltimo saldo â€” visÃ­veis por padrÃ£o
    latest_bal = df_balance.groupby('Participante')['Saldo'].last()
    top3_bal = set(latest_bal.nlargest(3).index)
    bottom3_bal = set(latest_bal.nsmallest(3).index)
    highlight_bal = top3_bal | bottom3_bal

    fig = go.Figure()

    for name in all_bal_participants:
        df_p = df_balance[df_balance['Participante'] == name].sort_values('Data')
        is_hl = name in highlight_bal

        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Saldo'],
            mode='lines+markers',
            name=name,
            line=dict(width=3 if is_hl else 1.5, color=bal_colors[name]),
            marker=dict(size=6 if is_hl else 4),
            hovertemplate=f'{name}: ' + '%{y:,} Estalecas<extra></extra>',
            visible=True if is_hl else 'legendonly',
        ))

    fig.update_layout(
        title="EvoluÃ§Ã£o do Saldo (Estalecas)",
        xaxis_title="Data",
        yaxis_title="Saldo (Estalecas)",
        template="plotly_white",
        height=600,
        hovermode='x unified',
        legend=dict(font=dict(size=10), itemsizing='constant'),
    )

    fig.show()
```

## Saldo vs Sentimento

Existe correlaÃ§Ã£o entre ter mais Estalecas e ser bem-visto pelos colegas?

```{python}
#| label: balance-vs-sentiment

bal_sent_data = []
for p in latest['participants']:
    if p.get('characteristics', {}).get('eliminated'):
        continue
    bal_sent_data.append({
        'Participante': p['name'],
        'Saldo': p.get('characteristics', {}).get('balance', 0),
        'Sentimento': calc_sentiment(p),
        'Grupo': p.get('characteristics', {}).get('memberOf', '?')
    })

df_bs = pd.DataFrame(bal_sent_data)

if len(df_bs) > 2:
    corr = df_bs['Saldo'].corr(df_bs['Sentimento'])

    fig = px.scatter(
        df_bs, x='Saldo', y='Sentimento',
        text='Participante',
        color='Grupo',
        color_discrete_map=GROUP_COLORS,
        title=f"Saldo vs Sentimento (correlaÃ§Ã£o: r = {corr:.2f})",
        labels={'Saldo': 'Saldo (Estalecas)', 'Sentimento': 'Score de Sentimento'}
    )

    fig.update_traces(textposition='top center', textfont_size=9, marker_size=12)
    fig.update_layout(template="plotly_white", height=500)

    # Linha de tendÃªncia
    z = np.polyfit(df_bs['Saldo'], df_bs['Sentimento'], 1)
    x_line = np.linspace(df_bs['Saldo'].min(), df_bs['Saldo'].max(), 100)
    y_line = np.polyval(z, x_line)
    fig.add_trace(go.Scatter(x=x_line, y=y_line, mode='lines',
                             line=dict(dash='dash', color='gray'),
                             name='TendÃªncia', showlegend=True))

    fig.show()
```

# DinÃ¢mica Vip vs Xepa {#grupos}

## Favoritismo Intragrupo

Os membros do mesmo grupo (Vip/Xepa) favorecem uns aos outros com mais â¤ï¸?

```{python}
#| label: group-favoritism

fav_data = []
for i, snap in enumerate(snapshots):
    matrix = all_matrices[i]
    name_to_group = {}
    for p in snap['participants']:
        if not p.get('characteristics', {}).get('eliminated'):
            name_to_group[p['name']] = p.get('characteristics', {}).get('group', '?')

    unique_groups = set(name_to_group.values())
    if len(unique_groups) <= 1:
        continue

    in_hearts, in_total = 0, 0
    out_hearts, out_total = 0, 0

    for (giver, receiver), label in matrix.items():
        if giver not in name_to_group or receiver not in name_to_group:
            continue
        same = name_to_group[giver] == name_to_group[receiver]
        is_heart = label == 'CoraÃ§Ã£o'
        if same:
            in_total += 1
            if is_heart: in_hearts += 1
        else:
            out_total += 1
            if is_heart: out_hearts += 1

    in_pct = (in_hearts / in_total * 100) if in_total > 0 else 0
    out_pct = (out_hearts / out_total * 100) if out_total > 0 else 0

    fav_data.append({
        'Data': pd.to_datetime(snap['date']),
        'Intragrupo (%)': round(in_pct, 1),
        'Intergrupo (%)': round(out_pct, 1),
        'ViÃ©s': round(in_pct - out_pct, 1)
    })

df_fav = pd.DataFrame(fav_data)

if not df_fav.empty:
    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=df_fav['Data'], y=df_fav['Intragrupo (%)'],
        mode='lines+markers', name='Mesmo grupo',
        line=dict(color='#2196F3', width=2)
    ))
    fig.add_trace(go.Scatter(
        x=df_fav['Data'], y=df_fav['Intergrupo (%)'],
        mode='lines+markers', name='Grupo diferente',
        line=dict(color='#FF9800', width=2)
    ))

    fig.update_layout(
        title="Favoritismo: â¤ï¸ Dentro do Grupo vs Entre Grupos",
        xaxis_title="Data",
        yaxis_title="% de reaÃ§Ãµes que sÃ£o â¤ï¸",
        template="plotly_white",
        height=400,
        yaxis_range=[50, 100]
    )

    fig.show()

    avg_bias = df_fav['ViÃ©s'].mean()
    if avg_bias > 2:
        print(f"ğŸ“Š ViÃ©s mÃ©dio: **{avg_bias:+.1f} pontos percentuais** a favor do prÃ³prio grupo.")
    elif avg_bias < -2:
        print(f"ğŸ“Š ViÃ©s mÃ©dio: **{avg_bias:+.1f} pp** â€” surpreendentemente, hÃ¡ *mais* â¤ï¸ para o grupo oposto!")
    else:
        print(f"ğŸ“Š ViÃ©s mÃ©dio: **{avg_bias:+.1f} pp** â€” praticamente nenhum favoritismo de grupo.")
```

# Quem DÃ¡ Mais Negatividade? {#emissores}

Ranking de quem distribui mais reaÃ§Ãµes negativas.

```{python}
#| label: negative-givers

giver_data = []
for name in active_names:
    pos_given = 0
    neg_given = 0
    for receiver in active_names:
        if name == receiver:
            continue
        rxn = latest_matrix.get((name, receiver), '')
        if rxn in POSITIVE:
            pos_given += 1
        elif rxn:
            neg_given += 1

    total = pos_given + neg_given
    neg_pct = (neg_given / total * 100) if total > 0 else 0

    giver_data.append({
        'Participante': name,
        'â¤ï¸ dados': pos_given,
        'Negativos dados': neg_given,
        '% Negativo': round(neg_pct, 1),
        'Grupo': MEMBER_OF.get(name, '?')
    })

df_givers = pd.DataFrame(giver_data).sort_values('% Negativo', ascending=True)

fig = go.Figure()

fig.add_trace(go.Bar(
    y=df_givers['Participante'],
    x=df_givers['â¤ï¸ dados'],
    name='â¤ï¸ dados',
    orientation='h',
    marker_color='#1a9850'
))

fig.add_trace(go.Bar(
    y=df_givers['Participante'],
    x=df_givers['Negativos dados'],
    name='Negativos dados',
    orientation='h',
    marker_color='#d73027'
))

fig.update_layout(
    title="Perfil de EmissÃ£o: Quem DÃ¡ Mais â¤ï¸ vs Negatividade?",
    xaxis_title="Quantidade de reaÃ§Ãµes dadas",
    yaxis_title="",
    barmode='stack',
    template="plotly_white",
    height=max(500, len(df_givers) * 25),
    margin=dict(l=150)
)

fig.show()
```

# Perfis Individuais {#perfis}

Detalhamento de cada participante ativo.

```{python}
#| label: individual-profiles
#| output: asis

# Ordenar por sentimento
sorted_active = sorted(
    [p for p in latest['participants'] if not p.get('characteristics', {}).get('eliminated')],
    key=lambda x: calc_sentiment(x),
    reverse=True
)

for p in sorted_active:
    name = p['name']
    member_of = p.get('characteristics', {}).get('memberOf', '?')
    group = p.get('characteristics', {}).get('group', '?')
    balance = p.get('characteristics', {}).get('balance', 0)
    roles = parse_roles(p.get('characteristics', {}).get('roles', []))
    score = calc_sentiment(p)

    # ReaÃ§Ãµes recebidas
    rxn_summary = []
    for rxn in p.get('characteristics', {}).get('receivedReactions', []):
        emoji = REACTION_EMOJI.get(rxn['label'], rxn['label'])
        rxn_summary.append(f"{emoji}Ã—{rxn['amount']}")

    # ReaÃ§Ãµes que este participante deu
    given = {}
    for other_name in active_names:
        if other_name == name:
            continue
        rxn = latest_matrix.get((name, other_name), '')
        if rxn:
            emoji = REACTION_EMOJI.get(rxn, rxn)
            given[emoji] = given.get(emoji, 0) + 1

    given_summary = " | ".join(f"{e}Ã—{c}" for e, c in sorted(given.items(), key=lambda x: -x[1]))

    # AlianÃ§as (â¤ï¸ mÃºtuo)
    allies = []
    enemies = []
    for other_name in active_names:
        if other_name == name:
            continue
        my_rxn = latest_matrix.get((name, other_name), '')
        their_rxn = latest_matrix.get((other_name, name), '')
        if my_rxn == 'CoraÃ§Ã£o' and their_rxn == 'CoraÃ§Ã£o':
            allies.append(other_name)
        elif my_rxn not in POSITIVE and their_rxn not in POSITIVE and my_rxn and their_rxn:
            enemies.append(other_name)

    print(f"\n### {name}")
    print(f"**{member_of}** | {group} | Saldo: {balance:,} | Sentimento: **{score:+.1f}**")
    if roles:
        print(f" | PapÃ©is: {', '.join(roles)}")
    print(f"\n- **Recebeu**: {' | '.join(rxn_summary)}")
    print(f"- **Deu**: {given_summary}")
    if allies:
        print(f"- **Aliados** (â¤ï¸ mÃºtuo): {', '.join(sorted(allies))}")
    if enemies:
        print(f"- **Rivais** (neg. mÃºtua): {', '.join(sorted(enemies))}")
    print("")
```

---

::: {.callout-tip}
## Sobre este painel
Este painel Ã© atualizado automaticamente com dados da API GloboPlay. As reaÃ§Ãµes **mudam diariamente** â€” cada snapshot captura o estado completo do jogo naquele momento. Dados coletados desde 13 de janeiro de 2026.
:::
