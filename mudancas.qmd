---
title: "BBB 26 â€” O Que Mudou"
subtitle: "Acompanhe as mudanÃ§as diÃ¡rias nas reaÃ§Ãµes entre os participantes"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import load_snapshot, get_all_snapshots, parse_roles, build_reaction_matrix

# ConfiguraÃ§Ãµes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# DiretÃ³rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

# Categorias de reaÃ§Ãµes
REACTION_EMOJI = {
    'CoraÃ§Ã£o': 'â¤ï¸', 'Planta': 'ğŸŒ±', 'Mala': 'ğŸ’¼', 'Biscoito': 'ğŸª',
    'Cobra': 'ğŸ', 'Alvo': 'ğŸ¯', 'VÃ´mito': 'ğŸ¤®', 'Mentiroso': 'ğŸ¤¥',
    'CoraÃ§Ã£o partido': 'ğŸ’”'
}

REACTION_SLUG_TO_LABEL = {
    'coracao': 'CoraÃ§Ã£o', 'planta': 'Planta', 'mala': 'Mala', 'biscoito': 'Biscoito',
    'cobra': 'Cobra', 'alvo': 'Alvo', 'vomito': 'VÃ´mito', 'mentiroso': 'Mentiroso',
    'coracao-partido': 'CoraÃ§Ã£o partido'
}

SENTIMENT_WEIGHTS = {
    'CoraÃ§Ã£o': 1.0,
    'Planta': -0.5, 'Mala': -0.5, 'Biscoito': -0.5,
    'Cobra': -1.0, 'Alvo': -1.0, 'VÃ´mito': -1.0, 'Mentiroso': -1.0,
    'CoraÃ§Ã£o partido': -0.5  # Mild negative (disappointment, not hostility)
}

POSITIVE = {'CoraÃ§Ã£o'}
MILD_NEGATIVE = {'Planta', 'Mala', 'Biscoito', 'CoraÃ§Ã£o partido'}  # ğŸ’” = disappointment, not hostility
STRONG_NEGATIVE = {'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso'}

# Cores dos grupos
GROUP_COLORS = {
    'Camarote': '#E6194B',
    'Veterano': '#3CB44B',
    'Pipoca': '#4363D8',
}

MEMBER_OF = {}  # preenchido ao carregar dados

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Plotly Dark Theme Configuration (matches Bootswatch darkly)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PLOT_BG = '#303030'  # Darkly body background
PAPER_BG = '#303030'
GRID_COLOR = '#444444'
TEXT_COLOR = '#fff'

# Standard layout applied to ALL plots
import plotly.io as pio

pio.templates['bbb_dark'] = go.layout.Template(
    layout=go.Layout(
        paper_bgcolor=PAPER_BG,
        plot_bgcolor=PLOT_BG,
        font=dict(color=TEXT_COLOR, family='Lato, -apple-system, sans-serif', size=13),
        title=dict(font=dict(size=16), x=0.5, xanchor='center', y=0.95),
        margin=dict(l=70, r=30, t=70, b=60),
        xaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        yaxis=dict(
            gridcolor=GRID_COLOR,
            linecolor=GRID_COLOR,
            zerolinecolor=GRID_COLOR,
            title=dict(standoff=15),
        ),
        legend=dict(
            bgcolor='rgba(0,0,0,0)',
            bordercolor='rgba(0,0,0,0)',
        ),
        colorway=['#00bc8c', '#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6'],
    )
)
pio.templates.default = 'bbb_dark'
```

```{python}
#| label: load-data

def calc_sentiment(participant):
    """Calcula o score de sentimento recebido por um participante."""
    total = 0
    for rxn in participant.get('characteristics', {}).get('receivedReactions', []):
        weight = SENTIMENT_WEIGHTS.get(rxn.get('label', ''), 0)
        total += weight * rxn.get('amount', 0)
    return total


def make_difference_table_html(changes_list, common_names, prev_date, curr_date):
    """Retorna HTML string com tabela de diferenÃ§as (sticky header/column)."""
    if not changes_list:
        return "<p>Nenhuma mudanÃ§a detectada.</p>"

    active_names_sorted = sorted(common_names)
    short_names = [n.split()[0] if len(n) > 10 else n for n in active_names_sorted]
    name_to_idx = {n: i for i, n in enumerate(active_names_sorted)}

    # Build change lookup
    change_lookup = {}
    for c in changes_list:
        key = (c['Emissor'], c['Receptor'])
        change_lookup[key] = c

    # Color based on delta
    def get_cell_style(delta):
        if delta >= 1.5:
            return "background: #1a9850; color: #fff;"  # Strong improvement
        elif delta >= 0.5:
            return "background: #91cf60; color: #000;"  # Mild improvement
        elif delta <= -1.5:
            return "background: #d73027; color: #fff;"  # Strong deterioration
        elif delta <= -0.5:
            return "background: #fc8d59; color: #000;"  # Mild deterioration
        return "background: #ffffbf; color: #000;"  # Lateral

    html = []
    html.append(f'''
<div style="overflow-x: auto; max-width: 100%;">
<p class="text-muted small">MudanÃ§as: {prev_date} â†’ {curr_date} | â­ = mudanÃ§a dramÃ¡tica</p>
<style>
.diff-table {{
    border-collapse: separate;
    border-spacing: 0;
    font-size: 0.8rem;
    width: max-content;
}}
.diff-table th, .diff-table td {{
    padding: 3px 5px;
    text-align: center;
    border: 1px solid #555;
    min-width: 40px;
    white-space: nowrap;
}}
.diff-table thead th {{
    position: sticky;
    top: 0;
    background: #222;
    z-index: 2;
    font-weight: bold;
    font-size: 0.75rem;
}}
.diff-table tbody th {{
    position: sticky;
    left: 0;
    background: #222;
    z-index: 1;
    font-weight: bold;
    text-align: right;
    font-size: 0.75rem;
}}
.diff-table thead th:first-child {{
    z-index: 3;
    left: 0;
}}
.diff-table td {{ font-size: 0.9rem; }}
.diff-table td:hover {{ outline: 2px solid #fff; }}
</style>
<table class="diff-table">
<thead>
<tr>
<th style="background: #222;">â†“ / â†’</th>
''')

    # Header row
    for short in short_names:
        html.append(f'<th>{short}</th>')
    html.append('</tr></thead><tbody>')

    # Data rows
    for i, giver in enumerate(active_names_sorted):
        html.append(f'<tr><th>{short_names[i]}</th>')
        for j, receiver in enumerate(active_names_sorted):
            if giver == receiver:
                html.append('<td style="background: #333; color: #555;">â€”</td>')
            else:
                key = (giver, receiver)
                if key in change_lookup:
                    c = change_lookup[key]
                    delta = c['Delta']
                    antes = c['Antes']
                    depois = c['Depois']
                    style = get_cell_style(delta)
                    star = "â­" if abs(delta) >= 1.5 else ""
                    tooltip = f"{giver} â†’ {receiver}: {antes}â†’{depois} (Î”{delta:+.1f})"
                    html.append(f'<td style="{style}" title="{tooltip}">{antes}â†’{depois}{star}</td>')
                else:
                    html.append('<td style="background: #2a2a2a; color: #555;">Â·</td>')
        html.append('</tr>')

    html.append('</tbody></table></div>')
    return '\n'.join(html)


# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de reaÃ§Ã£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label legÃ­vel e flag de sintÃ©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sintÃ©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

# Detectar participantes que entraram apÃ³s o primeiro snapshot
first_snap_names = set(p['name'] for p in snapshots[0]['participants'])
late_entrants = {}
_seen_names = set(first_snap_names)
for snap in snapshots[1:]:
    current_names = set(p['name'] for p in snap['participants'])
    new_names = current_names - _seen_names
    for name in new_names:
        if name not in late_entrants:
            late_entrants[name] = snap['date']
    _seen_names |= current_names

if late_entrants:
    _by_date = {}
    for n, d in late_entrants.items():
        _by_date.setdefault(d, []).append(n)
    _parts = []
    for d, names in sorted(_by_date.items()):
        names_str = ', '.join(sorted(names))
        _parts.append(f"{names_str} (entraram em {d})")
    _late_str = '; '.join(_parts)
    late_caption = (
        f"âš ï¸ Participantes que entraram apÃ³s o inÃ­cio do confinamento ({_late_str}) "
        f"tÃªm menos dias de dados comparados aos demais participantes."
    )
else:
    late_caption = ""

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (Ãºltima do dia) â€” usada para anÃ¡lises de reaÃ§Ãµes
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)
```

# O Que Mudou Hoje? {#mudancas-hoje}

Esta pÃ¡gina mostra as **mudanÃ§as nas reaÃ§Ãµes** entre os participantes do Big Brother Brasil 26. Enquanto o [Painel](index.html) mostra o estado atual, aqui vocÃª encontra a **dinÃ¢mica** â€” quem ganhou coraÃ§Ãµes, quem perdeu, quem mudou de opiniÃ£o.

```{python}
#| label: date-info
#| output: asis

if n_daily >= 2:
    today = daily_snapshots[-1]
    yesterday = daily_snapshots[-2]
    print(f"""
<div class="alert alert-info">
ğŸ“… Comparando: <strong>{yesterday['label']}</strong> â†’ <strong>{today['label']}</strong>
</div>
""")
else:
    print("""
<div class="alert alert-warning">
âš ï¸ Dados insuficientes para comparaÃ§Ã£o. Ã‰ necessÃ¡rio pelo menos 2 dias de dados.
</div>
""")
```

```{python}
#| label: daily-changes-detail
#| output: asis

if n_daily >= 2:
    prev_snap = daily_snapshots[-2]
    curr_snap = daily_snapshots[-1]
    prev_matrix = daily_matrices[-2]
    curr_matrix = daily_matrices[-1]

    prev_date = prev_snap['date']
    curr_date = curr_snap['date']

    # Find common participants
    prev_names = set(p['name'] for p in prev_snap['participants']
                     if not p.get('characteristics', {}).get('eliminated'))
    curr_names = set(p['name'] for p in curr_snap['participants']
                     if not p.get('characteristics', {}).get('eliminated'))
    common_names = prev_names & curr_names

    # Collect all changes
    changes_list = []
    for giver in sorted(common_names):
        for receiver in sorted(common_names):
            if giver == receiver:
                continue
            prev_rxn = prev_matrix.get((giver, receiver), '')
            curr_rxn = curr_matrix.get((giver, receiver), '')
            if prev_rxn != curr_rxn:
                prev_emoji = REACTION_EMOJI.get(prev_rxn, '?')
                curr_emoji = REACTION_EMOJI.get(curr_rxn, '?')
                prev_weight = SENTIMENT_WEIGHTS.get(prev_rxn, 0)
                curr_weight = SENTIMENT_WEIGHTS.get(curr_rxn, 0)
                delta = curr_weight - prev_weight

                if delta > 0:
                    change_type = 'Melhora'
                    change_color = '#1a9850'
                elif delta < 0:
                    change_type = 'Piora'
                    change_color = '#d73027'
                else:
                    change_type = 'Lateral'
                    change_color = '#888'

                changes_list.append({
                    'Emissor': giver,
                    'Receptor': receiver,
                    'Antes': prev_emoji,
                    'Depois': curr_emoji,
                    'prev_rxn': prev_rxn,
                    'curr_rxn': curr_rxn,
                    'Tipo': change_type,
                    'Delta': delta,
                    'Color': change_color,
                    'emissor_grupo': MEMBER_OF.get(giver, '?'),
                    'receptor_grupo': MEMBER_OF.get(receiver, '?'),
                })

    if changes_list:
        # Summary stats
        n_changes = len(changes_list)
        n_melhora = sum(1 for c in changes_list if c['Tipo'] == 'Melhora')
        n_piora = sum(1 for c in changes_list if c['Tipo'] == 'Piora')
        n_lateral = sum(1 for c in changes_list if c['Tipo'] == 'Lateral')
        total_possible = len(common_names) * (len(common_names) - 1)
        pct_changed = n_changes / total_possible * 100

        # Who benefited most / suffered most (as receivers)
        receiver_delta = defaultdict(float)
        for c in changes_list:
            receiver_delta[c['Receptor']] += c['Delta']

        # Who changed opinions most (as givers)
        giver_changes = Counter(c['Emissor'] for c in changes_list)
        giver_volatility = giver_changes.most_common()

        benefited = [(k, v) for k, v in receiver_delta.items() if v > 0]
        suffered = [(k, v) for k, v in receiver_delta.items() if v < 0]
        benefited.sort(key=lambda x: -x[1])
        suffered.sort(key=lambda x: x[1])

        print(f"## Resumo: {prev_date} â†’ {curr_date}\n")
        print(f"**{n_changes} mudanÃ§as** ({pct_changed:.0f}% das relaÃ§Ãµes): "
              f"ğŸŸ¢ {n_melhora} melhorias | ğŸ”´ {n_piora} pioras | âšª {n_lateral} laterais\n")

else:
    print("*Dados insuficientes â€” sÃ£o necessÃ¡rias pelo menos 2 coletas diÃ¡rias.*")
    changes_list = []
```

## Quem Ganhou e Quem Perdeu

```{python}
#| label: winners-losers-chart
#| output: asis

if n_daily >= 2 and changes_list:
    # Diverging bar chart: receivers sorted by net delta
    receiver_data = []
    for name in common_names:
        delta = receiver_delta.get(name, 0)
        if delta != 0:
            receiver_data.append({
                'name': name,
                'delta': delta,
                'group': MEMBER_OF.get(name, '?'),
                'color': '#1a9850' if delta > 0 else '#d73027'
            })

    receiver_data.sort(key=lambda x: x['delta'])

    if receiver_data:
        fig = go.Figure()

        fig.add_trace(go.Bar(
            y=[d['name'] for d in receiver_data],
            x=[d['delta'] for d in receiver_data],
            orientation='h',
            marker_color=[d['color'] for d in receiver_data],
            text=[f"{d['delta']:+.1f}" for d in receiver_data],
            textposition='outside',
            hovertemplate='%{y}: %{x:+.1f} pontos<extra></extra>',
        ))

        # Add vertical line at 0
        fig.add_vline(x=0, line_width=2, line_color='white')

        fig.update_layout(
            title=f"Impacto LÃ­quido: Quem Ganhou/Perdeu Pontos de Sentimento",
            xaxis_title="Î” Sentimento (soma das mudanÃ§as recebidas)",
            yaxis_title="",
            height=max(400, len(receiver_data) * 28),
            margin=dict(l=150),
            showlegend=False,
        )

        fig.show()

        # Text summary
        if benefited:
            top_ben = benefited[:3]
            print(f"**Ganhadores do dia:** {', '.join(f'{n} (+{v:.1f})' for n, v in top_ben)}")
        if suffered:
            top_suf = suffered[:3]
            print(f"\n**Perdedores do dia:** {', '.join(f'{n} ({v:.1f})' for n, v in top_suf)}")
```

## Mapa de DiferenÃ§as

Tabela mostrando apenas as cÃ©lulas que mudaram. Verde = melhora na relaÃ§Ã£o, vermelho = piora. CÃ©lulas com `Â·` nÃ£o mudaram.

```{python}
#| label: difference-heatmap
#| output: asis

if n_daily >= 2 and changes_list:
    # HTML table with sticky header/column (mobile-friendly)
    print(make_difference_table_html(changes_list, common_names, prev_date, curr_date))
else:
    print("<p class='text-muted'>Dados insuficientes para comparaÃ§Ã£o.</p>")
```

## Quem Mais Mudou de OpiniÃ£o?

Participantes que mais alteraram suas reaÃ§Ãµes (volatilidade).

```{python}
#| label: volatility-chart
#| output: asis

if n_daily >= 2 and changes_list:
    # Bar chart: who changed the most opinions (as giver)
    giver_data = []
    for name, count in giver_volatility:
        # Count how many were improvements vs deteriorations given
        given_melhora = sum(1 for c in changes_list if c['Emissor'] == name and c['Tipo'] == 'Melhora')
        given_piora = sum(1 for c in changes_list if c['Emissor'] == name and c['Tipo'] == 'Piora')
        given_lateral = sum(1 for c in changes_list if c['Emissor'] == name and c['Tipo'] == 'Lateral')
        giver_data.append({
            'name': name,
            'total': count,
            'melhora': given_melhora,
            'piora': given_piora,
            'lateral': given_lateral,
            'group': MEMBER_OF.get(name, '?')
        })

    giver_data.sort(key=lambda x: x['total'], reverse=True)

    if giver_data:
        fig = go.Figure()

        # Stacked bar: green (gave more hearts), red (gave more negativity), gray (lateral)
        fig.add_trace(go.Bar(
            y=[d['name'] for d in giver_data],
            x=[d['melhora'] for d in giver_data],
            name='Melhorou opiniÃ£o',
            orientation='h',
            marker_color='#1a9850',
            hovertemplate='%{y}: %{x} melhoras<extra></extra>',
        ))
        fig.add_trace(go.Bar(
            y=[d['name'] for d in giver_data],
            x=[d['piora'] for d in giver_data],
            name='Piorou opiniÃ£o',
            orientation='h',
            marker_color='#d73027',
            hovertemplate='%{y}: %{x} pioras<extra></extra>',
        ))
        fig.add_trace(go.Bar(
            y=[d['name'] for d in giver_data],
            x=[d['lateral'] for d in giver_data],
            name='MudanÃ§a lateral',
            orientation='h',
            marker_color='#888',
            hovertemplate='%{y}: %{x} laterais<extra></extra>',
        ))

        fig.update_layout(
            title=dict(text="Volatilidade: Quem Mais Mudou de OpiniÃ£o?", y=0.98, x=0.5, xanchor='center'),
            xaxis_title="NÃºmero de opiniÃµes alteradas",
            yaxis_title="",
            barmode='stack',
            height=max(500, len(giver_data) * 28),
            margin=dict(l=150, t=100),
            legend=dict(orientation='h', yanchor='top', y=1.12, xanchor='center', x=0.5),
        )

        fig.show()

        # Highlight the most volatile
        top_volatile = giver_data[:3]
        volatile_str = ', '.join(f"{d['name']} ({d['total']} mudanÃ§as)" for d in top_volatile)
        print(f"**Mais volÃ¡teis:** {volatile_str}")
```

## Fluxo de ReaÃ§Ãµes (Sankey)

VisualizaÃ§Ã£o do fluxo de mudanÃ§as: de qual reaÃ§Ã£o para qual reaÃ§Ã£o as pessoas mudaram.

```{python}
#| label: sankey-reactions
#| output: asis

if n_daily >= 2 and changes_list:
    # Count transitions between reaction types
    transition_counts = Counter()
    for c in changes_list:
        transition_counts[(c['prev_rxn'], c['curr_rxn'])] += 1

    # Build Sankey diagram
    all_reactions = ['CoraÃ§Ã£o', 'Planta', 'Mala', 'Biscoito', 'Cobra', 'Alvo', 'VÃ´mito', 'Mentiroso', 'CoraÃ§Ã£o partido']
    reaction_colors = {
        'CoraÃ§Ã£o': '#1a9850',
        'Planta': '#91cf60', 'Mala': '#d9ef8b', 'Biscoito': '#fee08b',
        'Cobra': '#fc8d59', 'Alvo': '#f46d43', 'VÃ´mito': '#d73027',
        'Mentiroso': '#a50026', 'CoraÃ§Ã£o partido': '#67001f'
    }

    # Nodes: "Before" reactions on left, "After" reactions on right
    # We'll use indices: 0-8 for "before", 9-17 for "after"
    before_labels = [f"{REACTION_EMOJI.get(r, r)} antes" for r in all_reactions]
    after_labels = [f"{REACTION_EMOJI.get(r, r)} depois" for r in all_reactions]
    node_labels = before_labels + after_labels
    node_colors = [reaction_colors.get(r, '#999') for r in all_reactions] * 2

    # Links
    sources = []
    targets = []
    values = []
    link_colors = []

    for (from_rxn, to_rxn), count in transition_counts.items():
        if from_rxn in all_reactions and to_rxn in all_reactions:
            from_idx = all_reactions.index(from_rxn)
            to_idx = all_reactions.index(to_rxn) + len(all_reactions)
            sources.append(from_idx)
            targets.append(to_idx)
            values.append(count)
            # Color by whether it's improvement or deterioration
            from_weight = SENTIMENT_WEIGHTS.get(from_rxn, 0)
            to_weight = SENTIMENT_WEIGHTS.get(to_rxn, 0)
            if to_weight > from_weight:
                link_colors.append('rgba(26, 152, 80, 0.5)')  # green
            elif to_weight < from_weight:
                link_colors.append('rgba(215, 48, 39, 0.5)')  # red
            else:
                link_colors.append('rgba(136, 136, 136, 0.5)')  # gray

    if values:
        fig = go.Figure(data=[go.Sankey(
            node=dict(
                pad=15,
                thickness=20,
                line=dict(color='black', width=0.5),
                label=node_labels,
                color=node_colors,
            ),
            link=dict(
                source=sources,
                target=targets,
                value=values,
                color=link_colors,
            )
        )])

        fig.update_layout(
            title=f"Fluxo de ReaÃ§Ãµes: {prev_date} â†’ {curr_date}",
            font_size=10,
            height=500,
        )

        fig.show()

        # Summary of flows
        hearts_lost = sum(v for (f, t), v in transition_counts.items() if f == 'CoraÃ§Ã£o' and t != 'CoraÃ§Ã£o')
        hearts_gained = sum(v for (f, t), v in transition_counts.items() if f != 'CoraÃ§Ã£o' and t == 'CoraÃ§Ã£o')
        print(f"**CoraÃ§Ãµes perdidos:** {hearts_lost} | **CoraÃ§Ãµes ganhos:** {hearts_gained}")
```

## Quem EstÃ¡ no Centro do Drama?

Participantes envolvidos nas maiores mudanÃ§as de sentimento (|Î”| â‰¥ 1.5: de â¤ï¸ para negativo forte ou vice-versa).

```{python}
#| label: dramatic-changes
#| fig-cap: "MudanÃ§as dramÃ¡ticas: quem deu e quem recebeu as maiores viradas de opiniÃ£o"

if n_daily >= 2 and changes_list:
    # Filter for dramatic changes (|delta| >= 1.5)
    dramatic = [c for c in changes_list if abs(c['Delta']) >= 1.5]

    if dramatic:
        # Count involvement per person (as giver and receiver)
        drama_given = Counter()  # who changed their opinion dramatically
        drama_received = Counter()  # whose perception changed dramatically
        drama_details_given = {}  # store details for hover
        drama_details_received = {}

        for c in dramatic:
            giver = c['Emissor']
            receiver = c['Receptor']
            drama_given[giver] += 1
            drama_received[receiver] += 1

            # Store details
            detail = f"{c['Antes']}â†’{c['Depois']} (Î”{c['Delta']:+.1f})"
            if giver not in drama_details_given:
                drama_details_given[giver] = []
            drama_details_given[giver].append(f"â†’{receiver}: {detail}")

            if receiver not in drama_details_received:
                drama_details_received[receiver] = []
            drama_details_received[receiver].append(f"â†{giver}: {detail}")

        # Get all participants involved
        all_dramatic_people = set(drama_given.keys()) | set(drama_received.keys())

        if all_dramatic_people:
            # Create a scatter/bubble chart showing given vs received
            drama_data = []
            for name in all_dramatic_people:
                given = drama_given.get(name, 0)
                received = drama_received.get(name, 0)
                hover_lines = []
                if name in drama_details_given:
                    hover_lines.append("Mudou opiniÃ£o sobre:")
                    hover_lines.extend(drama_details_given[name][:5])
                if name in drama_details_received:
                    if hover_lines:
                        hover_lines.append("")
                    hover_lines.append("OpiniÃ£o mudada por:")
                    hover_lines.extend(drama_details_received[name][:5])
                drama_data.append({
                    'name': name,
                    'given': given,
                    'received': received,
                    'total': given + received,
                    'group': MEMBER_OF.get(name, '?'),
                    'hover': '<br>'.join(hover_lines)
                })

            df_drama = pd.DataFrame(drama_data)

            fig = go.Figure()

            for group, color in GROUP_COLORS.items():
                mask = df_drama['group'] == group
                if mask.any():
                    fig.add_trace(go.Scatter(
                        x=df_drama[mask]['given'],
                        y=df_drama[mask]['received'],
                        mode='markers+text',
                        marker=dict(
                            size=df_drama[mask]['total'] * 12 + 20,
                            color=color,
                            opacity=0.7,
                            line=dict(width=2, color='white')
                        ),
                        text=df_drama[mask]['name'].apply(lambda x: x.split()[0]),
                        textposition='middle center',
                        textfont=dict(size=10, color='white'),
                        name=group,
                        customdata=df_drama[mask]['hover'],
                        hovertemplate='<b>%{text}</b><br>Deu: %{x} | Recebeu: %{y}<br><br>%{customdata}<extra></extra>'
                    ))

            fig.update_layout(
                title=f"Centro do Drama: {prev_date} â†’ {curr_date}",
                xaxis_title="MudanÃ§as dramÃ¡ticas DADAS (mudou opiniÃ£o)",
                yaxis_title="MudanÃ§as dramÃ¡ticas RECEBIDAS (opiniÃ£o mudou)",
                height=550,
                showlegend=True,
                legend=dict(orientation='h', y=-0.15)
            )

            # Add quadrant annotations
            max_val = max(df_drama['given'].max(), df_drama['received'].max(), 1)
            fig.add_annotation(x=max_val*0.8, y=0.2, text="VolÃ¡til<br>(muda muito)", showarrow=False, font=dict(size=10, color='gray'))
            fig.add_annotation(x=0.2, y=max_val*0.8, text="Alvo<br>(opiniÃ£o muda)", showarrow=False, font=dict(size=10, color='gray'))

            fig.show()
    else:
        dramatic = []  # For the summary below
else:
    dramatic = []
```

```{python}
#| label: dramatic-changes-summary
#| output: asis
#| echo: false

if n_daily >= 2 and changes_list:
    dramatic = [c for c in changes_list if abs(c['Delta']) >= 1.5]
    if dramatic:
        n_falls = sum(1 for c in dramatic if c['Delta'] < 0)
        n_rises = sum(1 for c in dramatic if c['Delta'] > 0)
        print(f"""
<div style="background: #2a2a2a; border-radius: 8px; padding: 1rem; margin-top: 1rem;">
<strong>Total de mudanÃ§as dramÃ¡ticas:</strong> {len(dramatic)}<br>
â€¢ Quedas (â¤ï¸â†’negativo forte): {n_falls}<br>
â€¢ Subidas (negativo forteâ†’â¤ï¸): {n_rises}
</div>
""")
    else:
        print("*Nenhuma mudanÃ§a dramÃ¡tica (|Î”| â‰¥ 1.5) detectada hoje.*")
else:
    print("*Dados insuficientes para anÃ¡lise.*")
```

## EvoluÃ§Ã£o das Hostilidades

VisualizaÃ§Ã£o das mudanÃ§as em relacionamentos hostis: novas inimizades, reconciliaÃ§Ãµes e pontos cegos.

```{python}
#| label: hostility-changes

if n_daily >= 2:
    # Build hostility sets for yesterday and today
    def get_hostility_pairs(matrix, active_names):
        """Returns (one_sided, two_sided) sets."""
        one_sided = set()  # (hostile_person, friendly_person)
        two_sided = set()  # frozenset({a, b})

        for (a, b), rxn_a_to_b in matrix.items():
            if a not in active_names or b not in active_names:
                continue

            rxn_b_to_a = matrix.get((b, a), '')
            a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
            b_dislikes_a = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''
            b_likes_a = rxn_b_to_a in POSITIVE

            if a_dislikes_b and b_dislikes_a:
                two_sided.add(frozenset([a, b]))
            elif a_dislikes_b and b_likes_a:
                one_sided.add((a, b))

        return one_sided, two_sided

    prev_one, prev_two = get_hostility_pairs(prev_matrix, prev_names)
    curr_one, curr_two = get_hostility_pairs(curr_matrix, curr_names)

    # Changes in two-sided hostility
    new_two = curr_two - prev_two
    resolved_two = prev_two - curr_two

    # Changes in one-sided hostility
    new_one = curr_one - prev_one
    resolved_one = prev_one - curr_one

    has_changes = new_two or resolved_two or new_one or resolved_one

    if has_changes:
        # Create a summary bar chart of hostility changes
        categories = []
        values = []
        colors = []
        hover_texts = []

        if new_two:
            categories.append('ğŸ”¥ Novas<br>MÃºtuas')
            values.append(len(new_two))
            colors.append('#d73027')
            details = [f"{sorted(p)[0]} â†” {sorted(p)[1]}" for p in new_two]
            hover_texts.append('<br>'.join(details))

        if resolved_two:
            categories.append('âœ… Resolvidas<br>MÃºtuas')
            values.append(len(resolved_two))
            colors.append('#1a9850')
            details = [f"{sorted(p)[0]} â†” {sorted(p)[1]}" for p in resolved_two]
            hover_texts.append('<br>'.join(details))

        if new_one:
            categories.append('ğŸ˜  Novas<br>Unilaterais')
            values.append(len(new_one))
            colors.append('#fc8d59')
            details = [f"{h} â†’ {f}" for h, f in sorted(new_one)]
            hover_texts.append('<br>'.join(details[:10]))

        if resolved_one:
            categories.append('ğŸ’š Resolvidas<br>Unilaterais')
            values.append(len(resolved_one))
            colors.append('#91cf60')
            details = [f"{h} â†’ {f}" for h, f in sorted(resolved_one)]
            hover_texts.append('<br>'.join(details[:10]))

        fig = go.Figure(data=[
            go.Bar(
                x=categories,
                y=values,
                marker_color=colors,
                text=values,
                textposition='outside',
                customdata=hover_texts,
                hovertemplate='<b>%{x}</b><br>Quantidade: %{y}<br><br>%{customdata}<extra></extra>'
            )
        ])

        fig.update_layout(
            title=f"MudanÃ§as em Hostilidades: {prev_date} â†’ {curr_date}",
            yaxis_title="Quantidade",
            height=400,
            showlegend=False
        )

        fig.show()

        # Store data for the next cell
        hostility_data = {
            'new_two': new_two,
            'resolved_two': resolved_two,
            'new_one': new_one,
            'resolved_one': resolved_one,
            'has_changes': True
        }
    else:
        hostility_data = {'has_changes': False}
else:
    hostility_data = {'has_changes': False}
```

```{python}
#| label: hostility-details
#| output: asis
#| echo: false

if n_daily >= 2:
    # Rebuild hostility data for this cell
    def get_hostility_pairs_v2(matrix, active_names):
        one_sided = set()
        two_sided = set()
        for (a, b), rxn_a_to_b in matrix.items():
            if a not in active_names or b not in active_names:
                continue
            rxn_b_to_a = matrix.get((b, a), '')
            a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
            b_dislikes_a = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''
            b_likes_a = rxn_b_to_a in POSITIVE
            if a_dislikes_b and b_dislikes_a:
                two_sided.add(frozenset([a, b]))
            elif a_dislikes_b and b_likes_a:
                one_sided.add((a, b))
        return one_sided, two_sided

    prev_one, prev_two = get_hostility_pairs_v2(prev_matrix, prev_names)
    curr_one, curr_two = get_hostility_pairs_v2(curr_matrix, curr_names)

    new_two = curr_two - prev_two
    resolved_two = prev_two - curr_two
    new_one = curr_one - prev_one
    resolved_one = prev_one - curr_one

    has_changes = new_two or resolved_two or new_one or resolved_one

    if has_changes:
        print("::: {.callout-note collapse='true'}")
        print("## ğŸ“‹ Detalhes das MudanÃ§as em Hostilidades\n")

        if new_two:
            print("### ğŸ”¥ Novas Hostilidades MÃºtuas\n")
            print("Pares que passaram a se odiar mutuamente:\n")
            for pair in sorted(new_two, key=lambda x: tuple(sorted(x))):
                a, b = sorted(pair)
                rxn_ab = curr_matrix.get((a, b), '')
                rxn_ba = curr_matrix.get((b, a), '')
                emoji_ab = REACTION_EMOJI.get(rxn_ab, '?')
                emoji_ba = REACTION_EMOJI.get(rxn_ba, '?')
                print(f"- **{a}** {emoji_ab}â†”{emoji_ba} **{b}**")
            print()

        if resolved_two:
            print("### âœ… Hostilidades MÃºtuas Resolvidas\n")
            for pair in sorted(resolved_two, key=lambda x: tuple(sorted(x))):
                a, b = sorted(pair)
                print(f"- {a} â†” {b}")
            print()

        if new_one:
            print("### ğŸ˜  Novas Hostilidades Unilaterais (Pontos Cegos)\n")
            print("A passou a dar negativa para B, mas B ainda dÃ¡ â¤ï¸ para A:\n")
            for hostile, friendly in sorted(new_one):
                rxn = curr_matrix.get((hostile, friendly), '')
                emoji = REACTION_EMOJI.get(rxn, '?')
                print(f"- **{hostile}** {emoji}â†’ {friendly} (que dÃ¡ â¤ï¸)")
            print()

        if resolved_one:
            print("### ğŸ’š Hostilidades Unilaterais Resolvidas\n")
            for hostile, friendly in sorted(resolved_one):
                print(f"- {hostile} â†” {friendly}")
            print()

        print(":::")

        # Net change summary
        net_mutual = len(new_two) - len(resolved_two)
        net_one = len(new_one) - len(resolved_one)
        print(f"""
<div style="background: #2a2a2a; border-radius: 8px; padding: 1rem; margin-top: 1rem;">
<strong>Saldo do dia:</strong> Hostilidades mÃºtuas <span style="color: {'#dc3545' if net_mutual > 0 else '#28a745' if net_mutual < 0 else '#888'};">{net_mutual:+d}</span> | Unilaterais <span style="color: {'#dc3545' if net_one > 0 else '#28a745' if net_one < 0 else '#888'};">{net_one:+d}</span>
</div>
""")
    else:
        print("*Nenhuma mudanÃ§a em hostilidades hoje â€” relacionamentos estÃ¡veis.*")
else:
    print("*Dados insuficientes para anÃ¡lise.*")
```

---

<div class="alert alert-secondary mt-5">
<h5>ğŸ“ NavegaÃ§Ã£o</h5>
<p class="mb-0">
<a href="index.html"><strong>ğŸ“Š Painel</strong></a> â€” Estado atual das reaÃ§Ãµes |
<a href="trajetoria.html"><strong>ğŸ“ˆ TrajetÃ³ria</strong></a> â€” EvoluÃ§Ã£o ao longo da temporada |
<a href="paredao.html"><strong>ğŸ—³ï¸ ParedÃ£o</strong></a> â€” ParedÃ£o atual |
<a href="paredoes.html"><strong>ğŸ“š Arquivo</strong></a> â€” HistÃ³rico de paredÃµes
</p>
</div>
