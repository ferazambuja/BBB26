---
title: "BBB 26 ‚Äî Evolu√ß√£o"
subtitle: "Como o jogo est√° evoluindo: rankings, sentimento, impacto e pulso di√°rio"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
from collections import Counter

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    load_snapshots_full,
    require_clean_manual_events, calc_sentiment, setup_bbb_dark_theme,
    load_daily_metrics, load_relations_scores, load_paredoes_raw, load_roles_daily,
    avatar_img,
    REACTION_EMOJI, SENTIMENT_WEIGHTS,
    GROUP_COLORS,
    render_cronologia_html,
    make_horizontal_bar, make_line_evolution, make_stacked_bar, make_visibility_buttons,
)

require_clean_manual_events()
setup_bbb_dark_theme()
```

```{python}
#| label: load-data
#| include: false

# ‚îÄ‚îÄ Load precomputed data ‚îÄ‚îÄ
daily_metrics_data = load_daily_metrics()

daily_metrics_list = daily_metrics_data.get("daily", [])
daily_metrics_map = {d.get("date"): d for d in daily_metrics_list}
daily_changes = daily_metrics_data.get("daily_changes", [])
hostility_counts = daily_metrics_data.get("hostility_counts", [])
vulnerability_history = daily_metrics_data.get("vulnerability_history", [])
impact_history = daily_metrics_data.get("impact_history", [])

# Relations scores
relations_data = load_relations_scores()

received_impact = relations_data.get("received_impact", {})
streak_breaks = relations_data.get("streak_breaks", [])

# Index data (strategic timeline)
index_data = {}
IDX_FILE = Path("data/derived/index_data.json")
if IDX_FILE.exists():
    with open(IDX_FILE, encoding="utf-8") as f:
        index_data = json.load(f)

strategic_timeline = index_data.get("strategic_timeline", [])

# Manual + auto events
MANUAL_EVENTS_FILE = Path("data/manual_events.json")
manual_events = {}
if MANUAL_EVENTS_FILE.exists():
    with open(MANUAL_EVENTS_FILE, encoding="utf-8") as f:
        manual_events = json.load(f)
power_events_manual = manual_events.get("power_events", [])
weekly_events = manual_events.get("weekly_events", [])

AUTO_EVENTS_FILE = Path("data/derived/auto_events.json")
auto_payload = {}
power_events_auto = []
if AUTO_EVENTS_FILE.exists():
    with open(AUTO_EVENTS_FILE, encoding="utf-8") as f:
        auto_payload = json.load(f)
    power_events_auto = auto_payload.get("events", [])
power_events = power_events_manual + power_events_auto

# Roles daily
roles_daily = load_roles_daily().get("daily", [])

# Pared√µes
paredoes_data = load_paredoes_raw()

# ‚îÄ‚îÄ Load snapshots for diff heatmap + balance charts ‚îÄ‚îÄ
snapshots, MEMBER_OF, AVATARS, daily_snapshots, late_entrants = load_snapshots_full()

n_daily = len(daily_snapshots)

leader_periods = index_data.get("leader_periods", [])
```

```{python}
#| label: date-info
#| output: asis

if n_daily >= 2:
    print(f"""
<div class="alert alert-info">
üìÖ Comparando: <strong>{daily_snapshots[-2]['label']}</strong> ‚Üí <strong>{daily_snapshots[-1]['label']}</strong>
| üìà Analisando <strong>{n_daily} dias</strong> de dados
</div>
""")
```

# Cronologia do Jogo {#cronologia}

Linha do tempo completa dos eventos da temporada ‚Äî eventos mais recentes primeiro.

```{python}
#| label: timeline-events
#| output: asis

timeline_path = Path("data/derived/game_timeline.json")
if timeline_path.exists():
    with open(timeline_path, encoding="utf-8") as f:
        timeline_events = json.load(f).get("events", [])
    print(render_cronologia_html(timeline_events))
else:
    print("<p class='text-muted'>Nenhum evento na cronologia.</p>")
```

```{python}
#| label: streak-breaks-timeline
#| output: asis

if streak_breaks:
    # Filter to active participants only (exclude eliminated/DQ)
    _active_names = {p["name"] for p in daily_snapshots[-1]["participants"]} if daily_snapshots else set()
    _active_breaks = [sb for sb in streak_breaks if sb.get("giver") in _active_names and sb.get("receiver") in _active_names]
    if _active_breaks:
        print("\n### üíî Rupturas de Alian√ßa Recentes\n")
        for sb in _active_breaks[:5]:
            emoji = REACTION_EMOJI.get(sb.get("new_emoji", ""), "‚ùì")
            severity_icon = "üî¥" if sb.get("severity") == "strong" else "üü°"
            print(f"- {severity_icon} **{sb['giver']}** ‚Üí **{sb['receiver']}**: "
                  f"{sb['previous_streak']} dias de ‚ù§Ô∏è rompidos ‚Üí {emoji} ({sb['date']})")
```

# Pulso Di√°rio {#pulso}

üìÖ **Compara√ß√£o dia-a-dia** ‚Äî O que mudou de ontem para hoje.

::: {.panel-tabset}

## Ganhadores & Perdedores

```{python}
#| label: winners-losers
#| output: asis

# Load precomputed pair changes from daily_metrics.json
_latest_dc = daily_changes[-1] if daily_changes else None
if _latest_dc and _latest_dc.get("pair_changes"):
    prev_date = daily_snapshots[-2]['date'] if n_daily >= 2 else ""
    curr_date = _latest_dc["date"]

    # Rebuild changes_list from precomputed pair_changes (used by subsequent tabs)
    changes_list = []
    common_names = set()
    for pc in _latest_dc["pair_changes"]:
        common_names.add(pc["giver"])
        common_names.add(pc["receiver"])
        changes_list.append({
            'Emissor': pc["giver"], 'Receptor': pc["receiver"],
            'Antes': REACTION_EMOJI.get(pc["prev_rxn"], '?'),
            'Depois': REACTION_EMOJI.get(pc["curr_rxn"], '?'),
            'prev_rxn': pc["prev_rxn"], 'curr_rxn': pc["curr_rxn"],
            'Tipo': pc["tipo"],
            'Delta': pc["delta"],
            'Color': '#1a9850' if pc["delta"] > 0 else ('#d73027' if pc["delta"] < 0 else '#888'),
            'emissor_grupo': MEMBER_OF.get(pc["giver"], '?'),
            'receptor_grupo': MEMBER_OF.get(pc["receiver"], '?'),
        })

    # Use precomputed receiver deltas
    receiver_delta = _latest_dc.get("receiver_deltas", {})
    receiver_data = [
        {'name': name, 'delta': delta, 'group': MEMBER_OF.get(name, '?'),
         'color': '#1a9850' if delta > 0 else '#d73027'}
        for name, delta in receiver_delta.items() if delta != 0
    ]
    receiver_data.sort(key=lambda x: x['delta'])

    if receiver_data:
        fig = make_horizontal_bar(
            names=[d['name'] for d in receiver_data],
            values=[d['delta'] for d in receiver_data],
            title="Impacto L√≠quido: Quem Ganhou/Perdeu Pontos de Sentimento",
            xaxis_title="Œî Sentimento (soma das mudan√ßas recebidas)",
            colors=[d['color'] for d in receiver_data],
            text=[f"{d['delta']:+.1f}" for d in receiver_data],
            height=max(400, len(receiver_data) * 28),
            left_margin=150,
            hovertemplate='%{y}: %{x:+.1f} pontos<extra></extra>',
        )
        fig.add_vline(x=0, line_width=2, line_color='white')
        fig.show()

        benefited = sorted([(k, v) for k, v in receiver_delta.items() if v > 0], key=lambda x: -x[1])
        suffered = sorted([(k, v) for k, v in receiver_delta.items() if v < 0], key=lambda x: x[1])
        if benefited:
            print(f"**Ganhadores do dia:** {', '.join(f'{n} (+{v:.1f})' for n, v in benefited[:3])}")
        if suffered:
            print(f"\n**Perdedores do dia:** {', '.join(f'{n} ({v:.1f})' for n, v in suffered[:3])}")
    else:
        print("*Nenhuma mudan√ßa detectada.*")
else:
    changes_list = []
    common_names = set()
    prev_date = ""
    curr_date = ""
    print("*Dados insuficientes ‚Äî s√£o necess√°rias pelo menos 2 coletas di√°rias.*")
```

## Quem Mudou de Opini√£o

```{python}
#| label: volatility-chart
#| output: asis

_giver_vol = _latest_dc.get("giver_volatility", {}) if _latest_dc else {}
if _giver_vol:
    giver_data = [
        {'name': name, 'total': v['total'], 'melhora': v['melhora'],
         'piora': v['piora'], 'lateral': v['lateral'], 'group': MEMBER_OF.get(name, '?')}
        for name, v in _giver_vol.items()
    ]
    giver_data.sort(key=lambda x: x['total'], reverse=True)

    if giver_data:
        _vol_names = [d['name'] for d in giver_data]
        fig = make_stacked_bar(
            _vol_names,
            [
                dict(values=[d['melhora'] for d in giver_data], name='Melhorou opini√£o', color='#1a9850'),
                dict(values=[d['piora'] for d in giver_data], name='Piorou opini√£o', color='#d73027'),
                dict(values=[d['lateral'] for d in giver_data], name='Mudan√ßa lateral', color='#888'),
            ],
            title="Volatilidade: Quem Mais Mudou de Opini√£o?",
            xaxis_title="N√∫mero de opini√µes alteradas",
            height=max(500, len(giver_data) * 28),
        )
        fig.update_layout(
            title=dict(text="Volatilidade: Quem Mais Mudou de Opini√£o?", y=0.98, x=0.5, xanchor='center'),
            margin=dict(l=150, t=100),
        )
        fig.show()

        top_volatile = giver_data[:3]
        vol_str = ', '.join(f"{d['name']} ({d['total']} mudan√ßas)" for d in top_volatile)
        print(f"**Mais vol√°teis:** {vol_str}")
```

## Fluxo de Rea√ß√µes (Sankey)

```{python}
#| label: sankey-reactions
#| output: asis

_trans_raw = _latest_dc.get("transition_counts", {}) if _latest_dc else {}
# Convert "A‚ÜíB" keys to (A, B) tuples
transition_counts = Counter()
for key, count in _trans_raw.items():
    parts = key.split("‚Üí")
    if len(parts) == 2:
        transition_counts[(parts[0], parts[1])] = count
if transition_counts:

    all_reactions = ['Cora√ß√£o', 'Planta', 'Mala', 'Biscoito', 'Cobra', 'Alvo', 'V√¥mito', 'Mentiroso', 'Cora√ß√£o partido']
    reaction_colors = {
        'Cora√ß√£o': '#1a9850', 'Planta': '#91cf60', 'Mala': '#d9ef8b',
        'Biscoito': '#fee08b', 'Cobra': '#fc8d59', 'Alvo': '#f46d43',
        'V√¥mito': '#d73027', 'Mentiroso': '#a50026', 'Cora√ß√£o partido': '#67001f'
    }

    before_labels = [f"{REACTION_EMOJI.get(r, r)} antes" for r in all_reactions]
    after_labels = [f"{REACTION_EMOJI.get(r, r)} depois" for r in all_reactions]
    node_labels = before_labels + after_labels
    node_colors = [reaction_colors.get(r, '#999') for r in all_reactions] * 2

    sources, targets, values, link_colors = [], [], [], []
    for (from_rxn, to_rxn), count in transition_counts.items():
        if from_rxn in all_reactions and to_rxn in all_reactions:
            from_idx = all_reactions.index(from_rxn)
            to_idx = all_reactions.index(to_rxn) + len(all_reactions)
            sources.append(from_idx)
            targets.append(to_idx)
            values.append(count)
            from_w = SENTIMENT_WEIGHTS.get(from_rxn, 0)
            to_w = SENTIMENT_WEIGHTS.get(to_rxn, 0)
            if to_w > from_w:
                link_colors.append('rgba(26, 152, 80, 0.5)')
            elif to_w < from_w:
                link_colors.append('rgba(215, 48, 39, 0.5)')
            else:
                link_colors.append('rgba(136, 136, 136, 0.5)')

    if values:
        fig = go.Figure(data=[go.Sankey(
            node=dict(pad=15, thickness=20, line=dict(color='black', width=0.5),
                      label=node_labels, color=node_colors),
            link=dict(source=sources, target=targets, value=values, color=link_colors)
        )])
        fig.update_layout(title=f"Fluxo de Rea√ß√µes: {prev_date} ‚Üí {curr_date}", font_size=10, height=500)
        fig.show()

        hearts_lost = sum(v for (f, t), v in transition_counts.items() if f == 'Cora√ß√£o' and t != 'Cora√ß√£o')
        hearts_gained = sum(v for (f, t), v in transition_counts.items() if f != 'Cora√ß√£o' and t == 'Cora√ß√£o')
        print(f"**Cora√ß√µes perdidos:** {hearts_lost} | **Cora√ß√µes ganhos:** {hearts_gained}")
```

## Mapa de Diferen√ßas

```{python}
#| label: diff-heatmap
#| output: asis

def make_difference_table_html(changes_list, common_names, prev_date, curr_date):
    if not changes_list:
        return "<p>Nenhuma mudan√ßa detectada.</p>"
    active_names_sorted = sorted(common_names)
    short_names = [n.split()[0] if len(n) > 10 else n for n in active_names_sorted]
    change_lookup = {(c['Emissor'], c['Receptor']): c for c in changes_list}

    def get_cell_style(delta):
        if delta >= 1.5: return "background: #1a9850; color: #fff;"
        elif delta >= 0.5: return "background: #91cf60; color: #000;"
        elif delta <= -1.5: return "background: #d73027; color: #fff;"
        elif delta <= -0.5: return "background: #fc8d59; color: #000;"
        return "background: #ffffbf; color: #000;"

    html = [f'''
<div style="overflow-x: auto; max-width: 100%;">
<p class="text-muted small">Mudan√ßas: {prev_date} ‚Üí {curr_date} | ‚≠ê = mudan√ßa dram√°tica</p>
<style>
.diff-table {{ border-collapse: separate; border-spacing: 0; font-size: 0.8rem; width: max-content; }}
.diff-table th, .diff-table td {{ padding: 3px 5px; text-align: center; border: 1px solid #555; min-width: 40px; white-space: nowrap; }}
.diff-table thead th {{ position: sticky; top: 0; background: #222; z-index: 2; font-weight: bold; font-size: 0.75rem; }}
.diff-table tbody th {{ position: sticky; left: 0; background: #222; z-index: 1; font-weight: bold; text-align: right; font-size: 0.75rem; }}
.diff-table thead th:first-child {{ z-index: 3; left: 0; }}
.diff-table td {{ font-size: 0.9rem; }}
.diff-table td:hover {{ outline: 2px solid #fff; }}
</style>
<table class="diff-table"><thead><tr><th style="background: #222;">‚Üì / ‚Üí</th>''']
    for short in short_names:
        html.append(f'<th>{short}</th>')
    html.append('</tr></thead><tbody>')
    for i, giver in enumerate(active_names_sorted):
        html.append(f'<tr><th>{short_names[i]}</th>')
        for j, receiver in enumerate(active_names_sorted):
            if giver == receiver:
                html.append('<td style="background: #333; color: #555;">‚Äî</td>')
            else:
                key = (giver, receiver)
                if key in change_lookup:
                    c = change_lookup[key]
                    style = get_cell_style(c['Delta'])
                    star = "‚≠ê" if abs(c['Delta']) >= 1.5 else ""
                    tooltip = f"{giver} ‚Üí {receiver}: {c['Antes']}‚Üí{c['Depois']} (Œî{c['Delta']:+.1f})"
                    html.append(f'<td style="{style}" title="{tooltip}">{c["Antes"]}‚Üí{c["Depois"]}{star}</td>')
                else:
                    html.append('<td style="background: #2a2a2a; color: #555;">¬∑</td>')
        html.append('</tr>')
    html.append('</tbody></table></div>')
    return '\n'.join(html)

if n_daily >= 2 and changes_list:
    print(make_difference_table_html(changes_list, common_names, prev_date, curr_date))
else:
    print("<p class='text-muted'>Dados insuficientes para compara√ß√£o.</p>")
```

:::

# Evolu√ß√£o do Sentimento {#sentimento}

üìà **Dado acumulado** ‚Äî Como o sentimento de cada participante evoluiu ao longo da temporada.

```{python}
#| label: sentiment-prep
#| include: false

# Build timeline data from precomputed metrics
timeline_data = []
if daily_metrics_map:
    for date_str in sorted(daily_metrics_map.keys()):
        entry = daily_metrics_map[date_str]
        rank_map = entry.get('rank', {})
        for name, score in entry.get('sentiment', {}).items():
            timeline_data.append({
                'Data': pd.to_datetime(date_str),
                'Participante': name,
                'Sentimento': score,
                'Grupo': MEMBER_OF.get(name, '?'),
                'Rank': rank_map.get(name, 0),
            })
else:
    for snap in daily_snapshots:
        for p in snap['participants']:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            timeline_data.append({
                'Data': pd.to_datetime(snap['date']),
                'Participante': p['name'],
                'Sentimento': calc_sentiment(p),
                'Grupo': p.get('characteristics', {}).get('memberOf', '?'),
                'Rank': 0,
            })

df_timeline = pd.DataFrame(timeline_data)

if not df_timeline.empty and (df_timeline['Rank'] == 0).all():
    df_timeline['Rank'] = df_timeline.groupby('Data')['Sentimento'].rank(ascending=False, method='min').astype(int)

all_participants = sorted(df_timeline['Participante'].unique()) if not df_timeline.empty else []
palette = (px.colors.qualitative.Plotly + px.colors.qualitative.D3 +
           px.colors.qualitative.Set2 + px.colors.qualitative.Bold)
participant_colors = {name: palette[i % len(palette)] for i, name in enumerate(all_participants)}

if not df_timeline.empty:
    latest_scores = df_timeline.groupby('Participante')['Sentimento'].last()
    top3 = set(latest_scores.nlargest(3).index)
    bottom3 = set(latest_scores.nsmallest(3).index)
    highlight = top3 | bottom3
else:
    highlight = set()

# ‚îÄ‚îÄ Helper: visibility selector buttons (wraps data_utils.make_visibility_buttons with MEMBER_OF) ‚îÄ‚îÄ
_make_vis_buttons_orig = make_visibility_buttons
def make_visibility_buttons(trace_names, highlight_set):
    return _make_vis_buttons_orig(trace_names, highlight_set, member_of=MEMBER_OF)
```

```{python}
#| label: fatos-rapidos-lideranca
#| output: asis

if len(daily_snapshots) >= 2:
    def get_ranking(snap):
        scores = [(p['name'], calc_sentiment(p)) for p in snap['participants']
                  if not p.get('characteristics', {}).get('eliminated')]
        return sorted(scores, key=lambda x: -x[1])

    latest_ranking = get_ranking(daily_snapshots[-1])
    current_leader = latest_ranking[0][0]
    current_leader_score = latest_ranking[0][1]

    days_leading = 0
    for snap in reversed(daily_snapshots):
        ranking = get_ranking(snap)
        if ranking and ranking[0][0] == current_leader:
            days_leading += 1
        else:
            break

    first_ranking = get_ranking(daily_snapshots[0])
    first_rank_dict = {name: i+1 for i, (name, _) in enumerate(first_ranking)}
    latest_rank_dict = {name: i+1 for i, (name, _) in enumerate(latest_ranking)}

    position_changes = [(name, first_rank_dict[name] - rank, rank)
                        for name, rank in latest_rank_dict.items() if name in first_rank_dict]
    biggest_rise = max(position_changes, key=lambda x: x[1]) if position_changes else None
    biggest_drop = min(position_changes, key=lambda x: x[1]) if position_changes else None

    facts = [f"**{current_leader}** lidera com **{current_leader_score:+.1f}** pontos"]
    if days_leading > 1:
        facts.append(f"h√° **{days_leading} dias** consecutivos")
    detail_facts = []
    if biggest_rise and biggest_rise[1] > 2:
        detail_facts.append(f"‚Ä¢ Maior subida: **{biggest_rise[0]}** (+{biggest_rise[1]} posi√ß√µes)")
    if biggest_drop and biggest_drop[1] < -2:
        detail_facts.append(f"‚Ä¢ Maior queda: **{biggest_drop[0]}** ({biggest_drop[1]} posi√ß√µes)")

    print(f"""
::: {{.callout-note title="Fatos R√°pidos" appearance="simple"}}
{' '.join(facts[:2])}

{"<br>".join(detail_facts)}
:::
""")
```

::: {.panel-tabset}

### Ranking (Bump Chart)

```{python}
#| label: bump-chart

if not df_timeline.empty:
    fig = go.Figure()
    final_ranks = df_timeline[df_timeline['Data'] == df_timeline['Data'].max()].set_index('Participante')['Rank']
    sorted_participants = final_ranks.sort_values().index.tolist()

    for name in sorted_participants:
        df_p = df_timeline[df_timeline['Participante'] == name].sort_values('Data')
        is_hl = name in highlight
        p_color = participant_colors.get(name, '#666')
        latest_rank = int(df_p['Rank'].iloc[-1])

        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Rank'], mode='lines+markers',
            name=f"{name} ({latest_rank}¬∫)",
            line=dict(width=3 if is_hl else 1.5, color=p_color),
            marker=dict(size=8 if is_hl else 5, color=p_color),
            hovertemplate=f'{name}<br>Posi√ß√£o: %{{y}}¬∫<br>Score: %{{customdata:+.1f}}<extra></extra>',
            customdata=df_p['Sentimento'],
            visible=True if is_hl else 'legendonly',
        ))

    n_participants = len(sorted_participants)
    fig.update_layout(
        title="Evolu√ß√£o do Ranking de Sentimento (Bump Chart)",
        xaxis_title="Data", yaxis_title="Posi√ß√£o no Ranking",
        yaxis=dict(autorange='reversed', tickmode='linear', tick0=1,
                   dtick=1 if n_participants <= 15 else 2,
                   range=[n_participants + 0.5, 0.5]),
        height=max(500, n_participants * 25), hovermode='x unified',
        legend=dict(font=dict(size=10), itemsizing='constant'),
        updatemenus=make_visibility_buttons(sorted_participants, highlight),
    )
    fig.show()
```

### Score (Linhas)

```{python}
#| label: sentiment-lines

if not df_timeline.empty:
    fig = go.Figure()
    for name in all_participants:
        df_p = df_timeline[df_timeline['Participante'] == name].sort_values('Data')
        is_hl = name in highlight
        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Sentimento'], mode='lines+markers',
            name=name,
            line=dict(width=3 if is_hl else 1.5, color=participant_colors[name]),
            marker=dict(size=6 if is_hl else 4),
            hovertemplate=f'{name}: ' + '%{y:+.1f}<extra></extra>',
            visible=True if is_hl else 'legendonly',
        ))

    fig.add_shape(type='line', x0=df_timeline['Data'].min(), x1=df_timeline['Data'].max(),
                  y0=0, y1=0, line=dict(color='red', dash='dash', width=1))

    for p in paredoes_data.get('paredoes', []):
        paredao_date = pd.to_datetime(p['data'])
        y_range = [df_timeline['Sentimento'].min() - 2, df_timeline['Sentimento'].max() + 2]
        fig.add_shape(type='line', x0=paredao_date, x1=paredao_date,
                      y0=y_range[0], y1=y_range[1],
                      line=dict(color='#FF6B6B', dash='dot', width=2))
        fig.add_annotation(x=paredao_date, y=y_range[1],
                           text=f"üó≥Ô∏è {p['numero']}¬∫ Pared√£o", showarrow=False,
                           font=dict(size=11, color='#FF6B6B'), yshift=10)

    n_active = len([p for p in daily_snapshots[-1]['participants']
                    if not p.get('characteristics', {}).get('eliminated')])
    fig.update_layout(
        title="Evolu√ß√£o do Sentimento ao Longo do Tempo",
        xaxis_title="Data", yaxis_title="Score de Sentimento",
        height=max(500, n_active * 32), hovermode='x unified',
        legend=dict(font=dict(size=11), itemsizing='constant'),
        margin=dict(r=180),
        updatemenus=make_visibility_buttons(all_participants, highlight),
    )
    fig.show()
```

### Score Estrat√©gico

```{python}
#| label: strategic-timeline
#| output: asis

if strategic_timeline:
    df_strat = pd.DataFrame(strategic_timeline)
    if not df_strat.empty and 'date' in df_strat.columns and 'name' in df_strat.columns and 'score' in df_strat.columns:
        fig = go.Figure()
        df_strat['date'] = pd.to_datetime(df_strat['date'])
        strat_names = sorted(df_strat['name'].unique())

        for name in strat_names:
            df_p = df_strat[df_strat['name'] == name].sort_values('date')
            is_hl = name in highlight
            fig.add_trace(go.Scatter(
                x=df_p['date'], y=df_p['score'], mode='lines',
                name=name,
                line=dict(width=3 if is_hl else 1.5, color=participant_colors.get(name, '#666')),
                hovertemplate=f'{name}: ' + '%{y:+.2f}<extra></extra>',
                visible=True if is_hl else 'legendonly',
            ))

        fig.update_layout(
            title="Score Estrat√©gico (Querid√¥metro + Eventos)",
            xaxis_title="Data", yaxis_title="Score Composto",
            height=max(500, len(strat_names) * 25),
            hovermode='x unified',
            legend=dict(font=dict(size=10), itemsizing='constant'),
            updatemenus=make_visibility_buttons(strat_names, highlight),
        )
        fig.show()
    else:
        print("*Dados estrat√©gicos indispon√≠veis.*")
else:
    print("*Dados estrat√©gicos indispon√≠veis.*")
```

:::

### Destaques {#destaques-sentimento}

```{python}
#| label: destaques-sentimento
#| output: asis

if len(daily_snapshots) >= 3:
    first_ranking = get_ranking(daily_snapshots[0])
    latest_ranking = get_ranking(daily_snapshots[-1])
    first_rank_dict = {name: i+1 for i, (name, _) in enumerate(first_ranking)}
    latest_rank_dict = {name: i+1 for i, (name, _) in enumerate(latest_ranking)}

    position_changes = [(name, abs(first_rank_dict[name] - rank), rank, first_rank_dict[name])
                        for name, rank in latest_rank_dict.items() if name in first_rank_dict]
    most_stable = min(position_changes, key=lambda x: (x[1], x[2])) if position_changes else None

    rises = [(name, first_rank_dict[name] - rank, rank) for name, rank in latest_rank_dict.items()
             if name in first_rank_dict and first_rank_dict[name] - rank > 0]
    falls = [(name, first_rank_dict[name] - rank, rank) for name, rank in latest_rank_dict.items()
             if name in first_rank_dict and first_rank_dict[name] - rank < 0]
    biggest_rise = max(rises, key=lambda x: x[1]) if rises else None
    biggest_fall = min(falls, key=lambda x: x[1]) if falls else None

    current_leader = latest_ranking[0][0]
    leader_score = latest_ranking[0][1]
    leader_first_rank = first_rank_dict.get(current_leader, "?")

    sections = []
    if leader_first_rank != 1 and leader_first_rank != "?":
        sections.append(f"**üèÜ {current_leader}** subiu da **{leader_first_rank}¬™ posi√ß√£o** para o topo. "
                        f"Com **{leader_score:+.1f}** pontos, consolidou-se como o mais querido.")
    else:
        sections.append(f"**üèÜ {current_leader}** lidera com **{leader_score:+.1f}** pontos.")

    if biggest_rise and biggest_rise[1] >= 3:
        name, change, rank = biggest_rise
        sections.append(f"**üìà Maior Ascens√£o:** **{name}** ({MEMBER_OF.get(name, '?')}) subiu **{change} posi√ß√µes** ‚Üí {rank}¬∫ lugar.")
    if biggest_fall and biggest_fall[1] <= -3:
        name, change, rank = biggest_fall
        sections.append(f"**üìâ Maior Queda:** **{name}** ({MEMBER_OF.get(name, '?')}) caiu **{abs(change)} posi√ß√µes** ‚Üí {rank}¬∫ lugar.")
    if most_stable and most_stable[1] <= 2:
        name, change, rank, first_rank = most_stable
        if change == 0:
            sections.append(f"**‚öì Mais Est√°vel:** **{name}** manteve a mesma posi√ß√£o ({rank}¬∫) desde o in√≠cio.")
        else:
            sections.append(f"**‚öì Mais Est√°vel:** **{name}** variou apenas {change} posi√ß√£o (de {first_rank}¬∫ para {rank}¬∫).")

    if sections:
        print("::: {.callout-tip title=\"Destaques\" appearance=\"simple\"}")
        print("<br>".join(sections))
        print(":::")
```

# Impacto Acumulado {#impacto}

üìà **Dado acumulado** ‚Äî Impacto de eventos de poder, votos e Sincer√£o sobre cada participante.

::: {.panel-tabset}

## Impacto Negativo Recebido

```{python}
#| label: received-impact
#| output: asis

if received_impact:
    impact_data = []
    for name, data in received_impact.items():
        if isinstance(data, dict):
            pos = data.get("positive", 0)
            neg = data.get("negative", 0)
        else:
            pos = 0
            neg = float(data) if data < 0 else 0
        impact_data.append({'name': name, 'positive': pos, 'negative': neg, 'net': pos + neg})

    impact_data.sort(key=lambda x: x['net'])

    if impact_data:
        _impact_names = [d['name'] for d in impact_data]
        fig = make_stacked_bar(
            _impact_names,
            [
                dict(values=[d['negative'] for d in impact_data], name='Negativo', color='#e74c3c'),
                dict(values=[d['positive'] for d in impact_data], name='Positivo', color='#2ecc71'),
            ],
            title="Impacto Acumulado por Participante (Eventos + Votos + Sincer√£o)",
            xaxis_title="Impacto", barmode='relative',
        )
        fig.show()
else:
    print("*Dados de impacto indispon√≠veis.*")
```

## Trajet√≥ria de Impacto

```{python}
#| label: impact-trajectory
#| output: asis

if impact_history:
    last_entry = impact_history[-1]
    names = sorted(last_entry.get("participants", {}).keys())
    dates = [pd.to_datetime(e["date"]) for e in impact_history]

    _impact_series = {}
    for name in names:
        neg_values = [e.get("participants", {}).get(name, {}).get("negative", 0) for e in impact_history]
        _impact_series[name] = (dates, neg_values)

    fig = make_line_evolution(
        _impact_series,
        title="Trajet√≥ria de Impacto Negativo Acumulado",
        yaxis_title="Impacto Negativo Acumulado",
        highlight=highlight, colors=participant_colors, member_of=MEMBER_OF,
        height=500,
    )
    fig.show()
else:
    print("*Dados de trajet√≥ria de impacto indispon√≠veis.*")
```

## Vulnerabilidade

```{python}
#| label: vulnerability-chart
#| output: asis

if vulnerability_history:
    last_entry = vulnerability_history[-1]
    names = sorted(last_entry.get("participants", {}).keys())
    dates = [pd.to_datetime(e["date"]) for e in vulnerability_history]

    _vuln_series = {}
    for name in names:
        ff_values = [e.get("participants", {}).get(name, {}).get("false_friends", 0) for e in vulnerability_history]
        _vuln_series[name] = (dates, ff_values)

    fig = make_line_evolution(
        _vuln_series,
        title="Vulnerabilidade: Falsos Amigos ao Longo do Tempo",
        yaxis_title="N¬∫ de falsos amigos (d√° ‚ù§Ô∏è a quem detesta)",
        highlight=highlight, colors=participant_colors, member_of=MEMBER_OF,
        hover_format="%{y} falsos amigos", height=500,
    )
    fig.show()
    print("Quem est√° cada vez mais exposto a votos surpresa?")
else:
    print("*Dados de vulnerabilidade indispon√≠veis.*")
```

:::

# Volatilidade Hist√≥rica {#volatilidade}

üìÖ **Compara√ß√£o dia-a-dia** ‚Äî Como a volatilidade do jogo evoluiu ao longo do tempo.

```{python}
#| label: volatility-history
#| output: asis

if daily_changes:
    dates = [pd.to_datetime(d["date"]) for d in daily_changes]
    total_changes = [d["total_changes"] for d in daily_changes]
    hearts_gained = [d["hearts_gained"] for d in daily_changes]
    hearts_lost = [d["hearts_lost"] for d in daily_changes]

    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=dates, y=total_changes, mode='lines+markers',
        name='Total de mudan√ßas', line=dict(color='#3498db', width=2),
    ))
    fig.add_trace(go.Bar(
        x=dates, y=hearts_gained, name='‚ù§Ô∏è ganhos', marker_color='#2ecc71', opacity=0.6,
    ))
    fig.add_trace(go.Bar(
        x=dates, y=[-h for h in hearts_lost], name='‚ù§Ô∏è perdidos', marker_color='#e74c3c', opacity=0.6,
    ))

    # Annotate pared√£o dates
    for p in paredoes_data.get('paredoes', []):
        pdate = pd.to_datetime(p['data'])
        fig.add_vline(x=pdate, line_width=1, line_dash='dot', line_color='#FF6B6B')
        fig.add_annotation(x=pdate, y=max(total_changes) if total_changes else 50,
                           text=f"üó≥Ô∏è {p['numero']}¬∫", showarrow=False,
                           font=dict(size=9, color='#FF6B6B'), yshift=15)

    fig.update_layout(
        title="Volatilidade Di√°ria: Mudan√ßas de Rea√ß√£o ao Longo do Tempo",
        xaxis_title="Data", yaxis_title="Quantidade",
        height=450, barmode='relative',
        legend=dict(orientation='h', y=-0.15),
    )
    fig.show()
else:
    print("*Dados hist√≥ricos de mudan√ßas indispon√≠veis.*")
```

# Saldo (Estalecas) {#saldo}

üìà **Dado acumulado** ‚Äî Evolu√ß√£o do saldo de cada participante ao longo do tempo.

```{python}
#| label: late-caption-balance
#| output: asis

if late_entrants:
    _by_d = {}
    for n, d in late_entrants.items():
        _by_d.setdefault(d, []).append(n)
    _parts = [f"{', '.join(sorted(ns))} (entraram em {d})" for d, ns in sorted(_by_d.items())]
    print(f'<p class="text-muted small">‚ö†Ô∏è Participantes que entraram depois: {"; ".join(_parts)}</p>')
```

```{python}
#| label: balance-timeline

balance_data = []
for i, snap in enumerate(snapshots):
    for p in snap['participants']:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        balance_data.append({
            'Data': pd.to_datetime(snap['date']),
            'Participante': p['name'],
            'Saldo': p.get('characteristics', {}).get('balance', 0),
            'Grupo': p.get('characteristics', {}).get('memberOf', '?')
        })

df_balance = pd.DataFrame(balance_data)

if not df_balance.empty:
    all_bal = sorted(df_balance['Participante'].unique())
    palette_bal = (px.colors.qualitative.Plotly + px.colors.qualitative.D3 +
                   px.colors.qualitative.Set2 + px.colors.qualitative.Bold)
    bal_colors = {name: palette_bal[i % len(palette_bal)] for i, name in enumerate(all_bal)}

    latest_bal = df_balance.groupby('Participante')['Saldo'].last()
    top3_bal = set(latest_bal.nlargest(3).index)
    bottom3_bal = set(latest_bal.nsmallest(3).index)
    hl_bal = top3_bal | bottom3_bal

    fig = go.Figure()
    for name in all_bal:
        df_p = df_balance[df_balance['Participante'] == name].sort_values('Data')
        is_hl = name in hl_bal
        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Saldo'], mode='lines+markers', name=name,
            line=dict(width=3 if is_hl else 1.5, color=bal_colors[name]),
            marker=dict(size=6 if is_hl else 4),
            hovertemplate=f'{name}: ' + '%{y:,} Estalecas<extra></extra>',
            visible=True if is_hl else 'legendonly',
        ))

    fig.update_layout(
        title="Evolu√ß√£o do Saldo (Estalecas)",
        xaxis_title="Data", yaxis_title="Saldo (Estalecas)",
        height=600, hovermode='x unified',
        legend=dict(font=dict(size=10), itemsizing='constant'),
    )
    fig.show()
```

### Ranking Atual

```{python}
#| label: saldo-ranking-table
#| output: asis

saldo_profiles = index_data.get("profiles", [])
active_saldo = [p for p in saldo_profiles if p.get("active", True)]
active_saldo.sort(key=lambda x: x.get("balance", 0), reverse=True)

html = []
html.append("""
<div style="overflow-x: auto; max-width: 100%;">
<style>
.saldo-table {
    border-collapse: separate;
    border-spacing: 0;
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
    font-size: 0.95rem;
}
.saldo-table th, .saldo-table td {
    padding: 8px 12px;
    border-bottom: 1px solid #444;
    vertical-align: middle;
}
.saldo-table thead th {
    background: #222;
    color: #aaa;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.8rem;
    letter-spacing: 0.5px;
    border-bottom: 2px solid #555;
}
.saldo-table tbody tr:hover {
    background: rgba(255,255,255,0.05);
}
.saldo-table .saldo-pos { color: #888; font-weight: 600; width: 30px; text-align: center; }
.saldo-table .saldo-name { font-weight: 500; }
.saldo-table .saldo-val { text-align: right; font-weight: 700; font-variant-numeric: tabular-nums; font-size: 1.05rem; }
</style>
<table class="saldo-table">
<thead><tr>
<th style="text-align:center;">#</th>
<th>Participante</th>
<th style="text-align:right;">Estalecas</th>
</tr></thead>
<tbody>
""")

for i, p in enumerate(active_saldo, 1):
    name = p["name"]
    balance = p.get("balance", 0)
    grupo = p.get("group", "")
    cor = GROUP_COLORS.get(grupo, "#999")
    avatar_url = AVATARS.get(name, "")

    if balance > 1000:
        val_color = "#1a9850"
    elif balance > 0:
        val_color = "#66bd63"
    elif balance == 0:
        val_color = "#888"
    else:
        val_color = "#d73027"

    avatar = avatar_img(name, AVATARS, size=36, border_color=cor) if avatar_url else ""

    html.append(f"""<tr>
<td class="saldo-pos">{i}</td>
<td class="saldo-name" style="display:flex;align-items:center;gap:10px;">{avatar} <span>{name}</span></td>
<td class="saldo-val" style="color:{val_color};">{balance:,}</td>
</tr>""")

html.append("</tbody></table></div>")
print("\n".join(html))
```

# VIP & Xepa {#vip-xepa}

üìÖ **Compara√ß√£o por l√≠der** ‚Äî Quem cada L√≠der escolheu para o VIP e quantas vezes cada participante foi selecionado.

::: {.panel-tabset}

## üìä Composi√ß√£o por L√≠der

```{python}
#| label: vip-heatmap
#| fig-cap: "VIP/Xepa por per√≠odo de lideran√ßa"

if not leader_periods:
    print("*Nenhum per√≠odo de lideran√ßa registrado.*")
else:
    # Build participant list: active participants sorted by VIP count (desc)
    all_names_set = set()
    for lp in leader_periods:
        all_names_set.update(lp["vip"])
        all_names_set.update(lp["xepa"])

    # Count VIP selections per participant
    vip_count = Counter()
    for lp in leader_periods:
        for n in lp["vip"]:
            vip_count[n] += 1

    # Sort: most VIP first, then alphabetical
    sorted_names = sorted(all_names_set, key=lambda n: (-vip_count.get(n, 0), n))

    # Build matrix: rows=participants, cols=leader periods
    # Values: 1=VIP, -1=Xepa, 0=not in house
    z_vals = []
    text_vals = []
    for name in sorted_names:
        row = []
        text_row = []
        for lp in leader_periods:
            if name in lp["vip"]:
                row.append(1)
                text_row.append("VIP")
            elif name in lp["xepa"]:
                row.append(-1)
                text_row.append("Xepa")
            else:
                row.append(0)
                text_row.append("Fora")
        z_vals.append(row)
        text_vals.append(text_row)

    col_labels = [f"üëë {lp['leader'].split()[0]}<br><sub>{lp['start'][5:]}</sub>" for lp in leader_periods]

    # Custom colorscale: Xepa=gray, absent=dark, VIP=gold
    colorscale = [
        [0.0, "#555555"],    # Xepa (gray)
        [0.5, "#1a1a2e"],    # Not in house (dark)
        [1.0, "#f1c40f"],    # VIP (gold)
    ]

    fig = go.Figure(data=go.Heatmap(
        z=z_vals, x=col_labels, y=sorted_names,
        text=text_vals, texttemplate="%{text}",
        colorscale=colorscale, zmin=-1, zmax=1,
        showscale=False,
        hovertemplate="%{y} ‚Äî %{text} (L√≠der: %{x})<extra></extra>",
    ))

    fig.update_layout(
        title="Composi√ß√£o VIP/Xepa por L√≠der",
        height=max(400, len(sorted_names) * 28),
        yaxis=dict(autorange="reversed", dtick=1),
        xaxis=dict(side="top"),
        margin=dict(l=140),
    )
    fig.show()
```

## üèÜ Quem Ficou Mais no VIP

```{python}
#| label: vip-bar
#| fig-cap: "Contagem de vezes VIP vs Xepa por participante"

if not leader_periods:
    print("*Nenhum per√≠odo de lideran√ßa registrado.*")
else:
    vip_count = Counter()
    xepa_count = Counter()
    all_names_set = set()
    for lp in leader_periods:
        for n in lp["vip"]:
            vip_count[n] += 1
            all_names_set.add(n)
        for n in lp["xepa"]:
            xepa_count[n] += 1
            all_names_set.add(n)

    # Sort by VIP count descending
    sorted_names = sorted(all_names_set, key=lambda n: (-vip_count.get(n, 0), xepa_count.get(n, 0), n))

    vip_vals = [vip_count.get(n, 0) for n in sorted_names]
    xepa_vals = [-xepa_count.get(n, 0) for n in sorted_names]  # negative for left side

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=sorted_names, x=vip_vals, orientation='h', name='VIP',
        marker_color='#f1c40f',
        text=[f"{v}√ó" if v > 0 else "" for v in vip_vals],
        textposition='outside',
        hovertemplate="%{y}: VIP %{x}√ó<extra></extra>",
    ))
    fig.add_trace(go.Bar(
        y=sorted_names, x=xepa_vals, orientation='h', name='Xepa',
        marker_color='#7f8c8d',
        text=[f"{abs(v)}√ó" if v < 0 else "" for v in xepa_vals],
        textposition='outside',
        hovertemplate="%{y}: Xepa %{customdata}√ó<extra></extra>",
        customdata=[xepa_count.get(n, 0) for n in sorted_names],
    ))

    n_periods = len(leader_periods)
    fig.update_layout(
        title=f"VIP vs Xepa ({n_periods} per√≠odos de lideran√ßa)",
        barmode='overlay',
        height=max(400, len(sorted_names) * 28),
        yaxis=dict(autorange="reversed"),
        xaxis=dict(
            title="‚Üê Xepa | VIP ‚Üí",
            zeroline=True, zerolinecolor='white', zerolinewidth=1,
            range=[-(n_periods + 0.5), n_periods + 0.5],
        ),
        legend=dict(orientation='h', yanchor='bottom', y=1.02),
    )
    fig.show()
```

## üìã Detalhes dos Per√≠odos

```{python}
#| label: vip-detail
#| output: asis

if not leader_periods:
    print("*Nenhum per√≠odo de lideran√ßa registrado.*")
else:
    for i, lp in enumerate(leader_periods):
        leader = lp["leader"]
        avatar = AVATARS.get(leader, "")
        start = lp["start"][5:]  # MM-DD
        end = lp["end"][5:]

        leader_av = avatar_img(leader, AVATARS, size=32) if avatar else ""

        print(f"""
<div style="background:#1a1a2e; border:1px solid #f1c40f33; border-radius:8px; padding:12px; margin-bottom:12px">
<h4 style="margin:0 0 8px">{leader_av}üëë {leader} <span style="color:#888;font-size:0.85em">({start} ‚Üí {end})</span></h4>

**VIP ({len(lp['vip'])}):** {', '.join(lp['vip'])}

**Xepa ({len(lp['xepa'])}):** {', '.join(lp['xepa'])}
</div>
""")
```

:::

# Poderes & Consequ√™ncias {#poderes}

üìà **Dado acumulado** ‚Äî Eventos de din√¢micas da casa: poderes, castigos e consequ√™ncias.

::: {.panel-tabset}

## üìÖ Linha do Tempo

```{python}
#| label: power-timeline
#| output: asis

if not power_events:
    print("*Nenhum poder registrado ainda.*")
else:
    df_power = pd.DataFrame(power_events).copy()
    df_power['Data'] = pd.to_datetime(df_power['date'])

    tipo_labels = {
        'lider': 'L√≠der', 'anjo': 'Anjo', 'monstro': 'Monstro',
        'imunidade': 'Imunidade', 'indicacao': 'Indica√ß√£o',
        'contragolpe': 'Contragolpe', 'voto_duplo': 'Voto duplo',
        'voto_anulado': 'Voto anulado', 'perdeu_voto': 'Perdeu voto',
        'bate_volta': 'Bate-Volta', 'veto_ganha_ganha': 'Veto (Ganha-Ganha)',
        'ganha_ganha_escolha': 'Escolha (Ganha-Ganha)',
        'barrado_baile': 'Barrado no Baile',
    }
    df_power['Tipo'] = df_power['type'].map(tipo_labels).fillna(df_power['type'])

    big_fone_targets = {}
    for w in weekly_events:
        raw_bf = w.get("big_fone") if isinstance(w, dict) else None
        bf_list = raw_bf if isinstance(raw_bf, list) else ([raw_bf] if isinstance(raw_bf, dict) else [])
        for bf in bf_list:
            if not isinstance(bf, dict):
                continue
            atendeu = bf.get("atendeu")
            date = bf.get("date")
            if atendeu and date:
                big_fone_targets[atendeu] = pd.to_datetime(date)

    def is_big_fone_imunidade(row):
        if row.get("type") != "imunidade":
            return False
        target = row.get("target")
        if not target or target not in big_fone_targets:
            return False
        row_date = row.get("Data") or pd.to_datetime(row.get("date"))
        bf_date = big_fone_targets.get(target)
        if row_date is None or bf_date is None:
            return False
        return abs((row_date - bf_date).days) <= 1

    if big_fone_targets:
        mask = df_power.apply(is_big_fone_imunidade, axis=1)
        df_power.loc[mask, "source"] = "Big Fone"
        df_power.loc[mask, "detail"] = "Atendeu o Big Fone e ficou imune"

    def resolve_context(row):
        source = row.get('source') or ''
        if source and isinstance(source, str) and source not in {"api_roles", "api"}:
            return source
        actor = (row.get('actor') or '').lower()
        if 'big fone' in actor: return 'Big Fone'
        if 'caixas' in actor: return 'Caixas-Surpresa'
        if 'prova do l√≠der' in actor: return 'Prova do L√≠der'
        if 'prova do anjo' in actor: return 'Prova do Anjo'
        if row.get('type') == 'monstro': return 'Castigo do Monstro'
        if 'bate e volta' in actor: return 'Prova Bate e Volta'
        if 'din√¢mica da casa' in actor: return 'Din√¢mica da casa'
        return '‚Äî'

    df_power['Din√¢mica'] = df_power.apply(resolve_context, axis=1)
    df_show = df_power.sort_values('Data')[['date', 'Din√¢mica', 'Tipo', 'actor', 'target', 'detail', 'impacto']]

    _DYNAMIC_ICON_MAP = {
        'big fone': 'üìû', 'caixas-surpresa': 'üéÅ', 'prova do l√≠der': 'üëë',
        'prova do anjo': 'üòá', 'prova bate e volta': 'üõü', 'ganha-ganha': 'üéÅ',
        'barrado no baile': 'üö´',
    }

    def render_person_cell(value, border):
        # Handle lists or " + "-separated actor strings (consensus events)
        items = None
        if isinstance(value, list):
            items = [v for v in value if v]
        elif isinstance(value, str) and " + " in value:
            items = [v.strip() for v in value.split(" + ") if v.strip()]
        if items:
            avatar_htmls = []
            for name in items:
                if name in AVATARS and AVATARS[name]:
                    avatar_htmls.append(
                        f'<img src="{AVATARS[name]}" style="width: 24px; height: 24px; border-radius: 50%; '
                        f'border: 2px solid {border}; object-fit: cover; margin-right: -6px;">')
            return f'<div style="display: flex; align-items: center; gap: 0.4rem;">{"".join(avatar_htmls)}<span>{" + ".join(items)}</span></div>'
        label = value or '‚Äî'
        if label in AVATARS and AVATARS[label]:
            return (f'<div style="display: flex; align-items: center;">'
                    f'<img src="{AVATARS[label]}" style="width: 28px; height: 28px; border-radius: 50%; '
                    f'border: 2px solid {border}; object-fit: cover; margin-right: 0.4rem;">{label}</div>')
        icon = next((v for k, v in _DYNAMIC_ICON_MAP.items() if k in label.lower()), 'üé¨')
        return f'<div style="display: flex; align-items: center; gap: 0.4rem;"><span>{icon}</span>{label}</div>'

    def render_context_cell(value):
        if not value or value == '‚Äî': return '‚Äî'
        icon = next((v for k, v in _DYNAMIC_ICON_MAP.items() if k in value.lower()), 'üé¨')
        return f'<div style="display:flex; align-items:center; gap:0.4rem;"><span>{icon}</span>{value}</div>'

    print('<div style="overflow-x:auto; margin: 0.5rem 0 1rem 0;">')
    print('<table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">')
    print('<thead><tr style="text-align: left; border-bottom: 1px solid #444;">'
          '<th style="padding: 0.5rem;">Data</th><th style="padding: 0.5rem;">Din√¢mica</th>'
          '<th style="padding: 0.5rem;">Tipo</th><th style="padding: 0.5rem;">Quem deu</th>'
          '<th style="padding: 0.5rem;">Quem recebeu</th><th style="padding: 0.5rem;">Consequ√™ncia</th>'
          '<th style="padding: 0.5rem;">Impacto</th></tr></thead><tbody>')

    for _, row in df_show.iterrows():
        impacto = row.get('impacto', 'neutro')
        if impacto == 'positivo':
            border, bg, label = '#2ecc71', 'rgba(46, 204, 113, 0.12)', 'Benef√≠cio'
        elif impacto == 'negativo':
            border, bg, label = '#e74c3c', 'rgba(231, 76, 60, 0.12)', 'Preju√≠zo'
        else:
            border, bg, label = '#95a5a6', 'rgba(149, 165, 166, 0.08)', 'Neutro'
        actor_html = render_person_cell(row["actor"], border)
        target_html = render_person_cell(row["target"], border)
        context_html = render_context_cell(row.get("Din√¢mica"))
        badge = (f'<span style="display:inline-block; padding: 0.15rem 0.5rem; border-radius: 999px; '
                 f'background: {bg}; color: {border}; border: 1px solid {border}; font-size: 0.75rem;">{label}</span>')
        print(f'<tr style="border-left: 4px solid {border}; background: {bg};">'
              f'<td style="padding: 0.45rem 0.5rem;">{row["date"]}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{context_html}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{row["Tipo"]}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{actor_html}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{target_html}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{row["detail"]}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{badge}</td></tr>')
    print('</tbody></table></div>')
```

## üìä Impacto por Participante

```{python}
#| label: power-impact
#| output: asis

power_summary = auto_payload.get("power_summary", {})
ps_by_part = power_summary.get("by_participant", {})
ps_sorted = power_summary.get("sorted_by_saldo", [])

if not ps_by_part:
    print("*Nenhum poder registrado ainda.*")
else:
    impact = pd.DataFrame([
        {"name": name, "positivo": ps_by_part[name]["positivo"],
         "negativo": ps_by_part[name]["negativo"], "saldo": ps_by_part[name]["saldo"]}
        for name in ps_sorted
    ]).set_index("name")

    fig = make_stacked_bar(
        list(impact.index),
        [
            dict(values=[-v for v in impact['negativo']], name='Preju√≠zo', color='#e74c3c'),
            dict(values=list(impact['positivo']), name='Benef√≠cio', color='#2ecc71'),
        ],
        title='Saldo de poderes por participante',
        xaxis_title='Eventos', barmode='relative',
        height=360 + 18 * len(impact),
    )
    fig.show()
```

:::

---

<div class="alert alert-secondary mt-5">
<h5>üìç Navega√ß√£o</h5>
<p class="mb-0">
<a href="index.html"><strong>üìä Painel</strong></a> ‚Äî Estado atual |
<a href="relacoes.html"><strong>ü§ù Rela√ß√µes</strong></a> ‚Äî Mapa social |
<a href="paredao.html"><strong>üó≥Ô∏è Pared√£o</strong></a> ‚Äî Pared√£o atual |
<a href="paredoes.html"><strong>üìö Arquivo</strong></a> ‚Äî Hist√≥rico
</p>
</div>
