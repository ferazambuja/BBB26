---
title: "BBB 26 ‚Äî Trajet√≥ria"
subtitle: "Evolu√ß√£o do jogo ao longo da temporada: alian√ßas, rivalidades e tend√™ncias"
lang: pt-BR
format:
  html:
    code-tools: false
execute:
  echo: false
  warning: false
---

```{python}
#| label: setup
#| include: false

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

import sys
sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    load_snapshot, get_all_snapshots, parse_roles, build_reaction_matrix,
    require_clean_manual_events, calc_sentiment, setup_bbb_dark_theme,
    REACTION_EMOJI, REACTION_SLUG_TO_LABEL, SENTIMENT_WEIGHTS,
    POSITIVE, MILD_NEGATIVE, STRONG_NEGATIVE, GROUP_COLORS,
)

require_clean_manual_events()
setup_bbb_dark_theme()

# Configura√ß√µes visuais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11
sns.set_theme(style="whitegrid", palette="husl")

# Diret√≥rios
DATA_DIR = Path("data/snapshots")
LATEST_FILE = Path("data/latest.json")

MEMBER_OF = {}  # preenchido ao carregar dados
```

```{python}
#| label: load-data

# Carregar todos os snapshots
all_snapshot_files = get_all_snapshots()
snapshots = []
for fp, date_str in all_snapshot_files:
    participants, metadata = load_snapshot(fp)
    snapshots.append({
        'filepath': fp,
        'date': date_str,
        'timestamp': fp.stem,
        'participants': participants,
        'metadata': metadata
    })

# Construir matrizes de rea√ß√£o para todos os snapshots
all_matrices = [build_reaction_matrix(s['participants']) for s in snapshots]

# Preencher MEMBER_OF e AVATARS
AVATARS = {}  # name -> avatar URL
for snap in snapshots:
    for p in snap['participants']:
        name = p['name']
        if name not in MEMBER_OF:
            MEMBER_OF[name] = p.get('characteristics', {}).get('memberOf', '?')
        if name not in AVATARS and p.get('avatar'):
            AVATARS[name] = p['avatar']

# Enriquecer cada snapshot com label leg√≠vel e flag de sint√©tico
for snap in snapshots:
    meta = snap.get('metadata') or {}
    is_synthetic = meta.get('synthetic', False)
    label = snap['date']
    if is_synthetic:
        label += ' (sint√©tico)'
    snap['label'] = label
    snap['synthetic'] = is_synthetic

# Detectar participantes que entraram ap√≥s o primeiro snapshot
first_snap_names = set(p['name'] for p in snapshots[0]['participants'])
late_entrants = {}
_seen_names = set(first_snap_names)
for snap in snapshots[1:]:
    current_names = set(p['name'] for p in snap['participants'])
    new_names = current_names - _seen_names
    for name in new_names:
        if name not in late_entrants:
            late_entrants[name] = snap['date']
    _seen_names |= current_names

# Build late caption for timeline charts
if late_entrants:
    _by_date = {}
    for n, d in late_entrants.items():
        _by_date.setdefault(d, []).append(n)

    _parts = []
    for d, names in sorted(_by_date.items()):
        names_str = ', '.join(sorted(names))
        _parts.append(f"{names_str} (entraram em {d})")
    _late_str = '; '.join(_parts)

    late_caption = (
        f"‚ö†Ô∏è Participantes que entraram ap√≥s o in√≠cio do confinamento ({_late_str}) "
        f"t√™m menos dias de dados comparados aos demais participantes que estavam presentes "
        f"desde o in√≠cio da temporada, e isso pode afetar compara√ß√µes temporais."
    )
else:
    late_caption = ""

n_snapshots = len(snapshots)
latest = snapshots[-1]
latest_matrix = all_matrices[-1]

# Uma coleta por dia (√∫ltima do dia) ‚Äî usada para an√°lises de rea√ß√µes
_by_date = {}
for i, snap in enumerate(snapshots):
    _by_date[snap['date']] = i  # last one wins (sorted chronologically)
_daily_indices = sorted(_by_date.values())
daily_snapshots = [snapshots[i] for i in _daily_indices]
daily_matrices = [all_matrices[i] for i in _daily_indices]
n_daily = len(daily_snapshots)

# Derived daily metrics (optional)
daily_metrics = {}
daily_metrics_map = {}
DAILY_METRICS_FILE = Path("data/derived/daily_metrics.json")
if DAILY_METRICS_FILE.exists():
    with open(DAILY_METRICS_FILE, encoding="utf-8") as f:
        daily_metrics = json.load(f)
    daily_metrics_map = {d.get('date'): d for d in daily_metrics.get('daily', [])}

# Manual events (powers & consequences)
MANUAL_EVENTS_FILE = Path("data/manual_events.json")
if MANUAL_EVENTS_FILE.exists():
    with open(MANUAL_EVENTS_FILE, encoding="utf-8") as f:
        manual_events = json.load(f)
else:
    manual_events = {"power_events": []}
power_events_manual = manual_events.get("power_events", [])
weekly_events = manual_events.get("weekly_events", [])

# Auto power events from API (L√≠der / Anjo / Monstro / Imune) ‚Äî prefer derived file
power_events_auto = []
AUTO_EVENTS_FILE = Path("data/derived/auto_events.json")
if AUTO_EVENTS_FILE.exists():
    with open(AUTO_EVENTS_FILE, encoding="utf-8") as f:
        auto_payload = json.load(f)
    power_events_auto = auto_payload.get("events", [])
else:
    prev_lider = None
    prev_anjo = None
    prev_monstro = set()
    prev_imune = set()
    for snap in daily_snapshots:
        date = snap["date"]
        current_lider = None
        current_anjo = None
        current_monstro = set()
        current_imune = set()
        for p in snap["participants"]:
            name = p.get("name", "").strip()
            roles = parse_roles(p.get("characteristics", {}).get("roles", []))
            if "L√≠der" in roles:
                current_lider = name
            if "Anjo" in roles:
                current_anjo = name
            if "Monstro" in roles:
                current_monstro.add(name)
            if "Imune" in roles:
                current_imune.add(name)

        if current_lider and current_lider != prev_lider:
            power_events_auto.append({
                "date": date,
                "type": "lider",
                "actor": "Prova do L√≠der",
                "target": current_lider,
                "detail": "Ganhou a lideran√ßa",
                "impacto": "positivo",
                "origem": "api",
            })
            prev_lider = current_lider
        if current_anjo and current_anjo != prev_anjo:
            power_events_auto.append({
                "date": date,
                "type": "anjo",
                "actor": "Prova do Anjo",
                "target": current_anjo,
                "detail": "Ganhou o anjo",
                "impacto": "positivo",
                "origem": "api",
            })
            prev_anjo = current_anjo

        for name in sorted(current_monstro - prev_monstro):
            power_events_auto.append({
                "date": date,
                "type": "monstro",
                "actor": "Castigo do Monstro",
                "target": name,
                "detail": "Recebeu o monstro",
                "impacto": "negativo",
                "origem": "api",
            })
        prev_monstro = current_monstro

        for name in sorted(current_imune - prev_imune):
            power_events_auto.append({
                "date": date,
                "type": "imunidade",
                "actor": "Din√¢mica da casa",
                "target": name,
                "detail": "Recebeu imunidade",
                "impacto": "positivo",
                "origem": "api",
            })
        prev_imune = current_imune

power_events = power_events_manual + power_events_auto

# Sincer√£o derived data
sincerao_data = {}
SINCERAO_FILE = Path("data/derived/sincerao_edges.json")
if SINCERAO_FILE.exists():
    with open(SINCERAO_FILE, encoding="utf-8") as f:
        sincerao_data = json.load(f)
```

# Vis√£o Geral {#visao-geral}

Esta p√°gina mostra a **evolu√ß√£o do jogo** ao longo da temporada do Big Brother Brasil 26. Aqui voc√™ encontra an√°lises acumuladas: alian√ßas que persistem, rivalidades que crescem, e tend√™ncias de longo prazo.

```{python}
#| label: stats-overview
#| output: asis

print(f"""
<div class="alert alert-info">
üìà Analisando <strong>{n_daily} dias</strong> de dados ({daily_snapshots[0]['label']} ‚Üí {daily_snapshots[-1]['label']})
</div>
""")
```

```{python}
#| label: late-entrants-note
#| output: asis

late_names = ', '.join(sorted(late_entrants.keys())) if late_entrants else 'nenhum'
print(
    '<div class="alert alert-warning small" role="alert">'
    f'<strong>Nota:</strong> Participantes que entraram ap√≥s o in√≠cio ({late_names}) '
    't√™m menos dias de dados.'
    '</div>'
)
```

# Cronologia do Jogo {#cronologia}

Linha do tempo dos principais eventos da temporada: entradas, sa√≠das e mudan√ßas de roles.

```{python}
#| label: timeline-events

events_data = []
all_names_seen = set()

for i, snap in enumerate(snapshots):
    current_names = set(p['name'] for p in snap['participants'])
    active_names = set(p['name'] for p in snap['participants']
                       if not p.get('characteristics', {}).get('eliminated'))

    if i > 0:
        prev_names = set(p['name'] for p in snapshots[i-1]['participants'])
        appeared = current_names - prev_names
        disappeared = prev_names - current_names

        if appeared:
            events_data.append({
                'Data': snap['date'],
                'Evento': f"‚úÖ Entraram: {', '.join(sorted(appeared))}",
                'Participantes': len(active_names)
            })
        if disappeared:
            for name in disappeared:
                events_data.append({
                    'Data': snap['date'],
                    'Evento': f"‚ùå Saiu: {name}",
                    'Participantes': len(active_names)
                })

    # Detectar roles especiais
    for p in snap['participants']:
        roles = parse_roles(p.get('characteristics', {}).get('roles', []))
        for role in roles:
            if role in ('L√≠der', 'Pared√£o') and i > 0:
                prev_snap_p = {pp['name']: pp for pp in snapshots[i-1]['participants']}
                if p['name'] in prev_snap_p:
                    prev_roles = parse_roles(prev_snap_p[p['name']].get('characteristics', {}).get('roles', []))
                    if role not in prev_roles:
                        events_data.append({
                            'Data': snap['date'],
                            'Evento': f"üèÜ {p['name']} ‚Üí {role}",
                            'Participantes': len(active_names)
                        })

    all_names_seen |= current_names

if events_data:
    df_events = pd.DataFrame(events_data).drop_duplicates()
    # Mostrar apenas eventos importantes (entradas/sa√≠das/roles)
    key_events = df_events[df_events['Evento'].str.contains('Entraram|Saiu|L√≠der')]
    if not key_events.empty:
        display(key_events.style.hide(axis='index'))
```

# Poderes & Consequ√™ncias {#poderes}

Eventos de **din√¢micas da casa** que concedem poderes ou imp√µem consequ√™ncias.  
Esses registros v√™m de **dois lugares**: `power_events` manuais e eventos **auto‚Äëdetectados da API** (L√≠der/Anjo). **N√£o t√™m rela√ß√£o com Cartola**.

::: {.panel-tabset}

## üìÖ Linha do Tempo

```{python}
#| label: power-events-timeline
#| output: asis

if not power_events:
    print("*Nenhum poder registrado ainda.*")
else:
    df_power = pd.DataFrame(power_events).copy()
    df_power['Data'] = pd.to_datetime(df_power['date'])

    tipo_labels = {
        'lider': 'L√≠der',
        'anjo': 'Anjo',
        'monstro': 'Monstro',
        'imunidade': 'Imunidade',
        'indicacao': 'Indica√ß√£o',
        'contragolpe': 'Contragolpe',
        'voto_duplo': 'Voto duplo',
        'voto_anulado': 'Voto anulado',
        'perdeu_voto': 'Perdeu voto',
        'bate_volta': 'Bate-Volta',
        'veto_ganha_ganha': 'Veto (Ganha-Ganha)',
        'ganha_ganha_escolha': 'Escolha (Ganha-Ganha)',
        'barrado_baile': 'Barrado no Baile',
    }

    df_power['Tipo'] = df_power['type'].map(tipo_labels).fillna(df_power['type'])
    df_power['Impacto'] = df_power.get('impacto', 'neutro').map({
        'positivo': 'Benef√≠cio',
        'negativo': 'Preju√≠zo'
    }).fillna('Neutro')

    big_fone_targets = {}
    for w in weekly_events:
        raw_bf = w.get("big_fone") if isinstance(w, dict) else None
        bf_list = raw_bf if isinstance(raw_bf, list) else ([raw_bf] if isinstance(raw_bf, dict) else [])
        for bf in bf_list:
            if not isinstance(bf, dict):
                continue
            atendeu = bf.get("atendeu")
            date = bf.get("date")
            if atendeu and date:
                big_fone_targets[atendeu] = pd.to_datetime(date)

    def is_big_fone_imunidade(row):
        if row.get("type") != "imunidade":
            return False
        target = row.get("target")
        if not target or target not in big_fone_targets:
            return False
        row_date = row.get("Data") or pd.to_datetime(row.get("date"))
        bf_date = big_fone_targets.get(target)
        if row_date is None or bf_date is None:
            return False
        return abs((row_date - bf_date).days) <= 1

    # Override context/details for Big Fone immunidade
    if big_fone_targets:
        mask = df_power.apply(is_big_fone_imunidade, axis=1)
        df_power.loc[mask, "source"] = "Big Fone"
        df_power.loc[mask, "detail"] = "Atendeu o Big Fone e ficou imune"

    def resolve_context(row):
        source = row.get('source') or ''
        if source and isinstance(source, str) and source not in {"api_roles", "api"}:
            return source
        actor = (row.get('actor') or '').lower()
        if 'big fone' in actor:
            return 'Big Fone'
        if 'caixas' in actor:
            return 'Caixas-Surpresa'
        if 'prova do l√≠der' in actor:
            return 'Prova do L√≠der'
        if 'prova do anjo' in actor:
            return 'Prova do Anjo'
        if row.get('type') == 'monstro':
            return 'Castigo do Monstro'
        if 'bate e volta' in actor:
            return 'Prova Bate e Volta'
        if 'din√¢mica da casa' in actor:
            return 'Din√¢mica da casa'
        return '‚Äî'

    df_power['Din√¢mica'] = df_power.apply(resolve_context, axis=1)
    df_show = df_power.sort_values('Data')[['date', 'Din√¢mica', 'Tipo', 'actor', 'target', 'detail', 'impacto']]

    print('<div style="overflow-x:auto; margin: 0.5rem 0 1rem 0;">')
    print('<table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">')
    print('<thead><tr style="text-align: left; border-bottom: 1px solid #444;">'
          '<th style="padding: 0.5rem;">Data</th>'
          '<th style="padding: 0.5rem;">Din√¢mica</th>'
          '<th style="padding: 0.5rem;">Tipo</th>'
          '<th style="padding: 0.5rem;">Quem deu</th>'
          '<th style="padding: 0.5rem;">Quem recebeu</th>'
          '<th style="padding: 0.5rem;">Consequ√™ncia</th>'
          '<th style="padding: 0.5rem;">Impacto</th>'
          '</tr></thead><tbody>')

    def render_person_cell(value, border):
        if isinstance(value, list):
            items = [v for v in value if v]
            if not items:
                return '‚Äî'
            avatar_htmls = []
            for name in items:
                if name in AVATARS and AVATARS[name]:
                    avatar = AVATARS[name]
                    avatar_htmls.append(
                        f'<img src="{avatar}" style="width: 24px; height: 24px; border-radius: 50%; '
                        f'border: 2px solid {border}; object-fit: cover; margin-right: -6px;">'
                    )
            names_html = ' + '.join(items)
            stack = ''.join(avatar_htmls)
            return f'<div style="display: flex; align-items: center; gap: 0.4rem;">{stack}<span>{names_html}</span></div>'

        label = value or '‚Äî'
        if label in AVATARS and AVATARS[label]:
            avatar = AVATARS[label]
            avatar_html = (
                f'<img src="{avatar}" style="width: 28px; height: 28px; border-radius: 50%; '
                f'border: 2px solid {border}; object-fit: cover; margin-right: 0.4rem;">'
            )
            return f'<div style="display: flex; align-items: center;">{avatar_html}{label}</div>'

        icon_map = {
            'big fone': 'üìû',
            'caixas-surpresa': 'üéÅ',
            'prova do l√≠der': 'üëë',
            'prova do anjo': 'üòá',
            'prova bate e volta': 'üõü',
            'ganha-ganha': 'üéÅ',
            'barrado no baile': 'üö´',
        }
        lower = label.lower()
        icon = next((icon_map[k] for k in icon_map if k in lower), 'üé¨')
        return f'<div style="display: flex; align-items: center; gap: 0.4rem;"><span>{icon}</span>{label}</div>'

    def render_context_cell(value):
        if not value or value == '‚Äî':
            return '‚Äî'
        lower = value.lower()
        icon_map = {
            'big fone': 'üìû',
            'caixas-surpresa': 'üéÅ',
            'prova do l√≠der': 'üëë',
            'prova do anjo': 'üòá',
            'prova bate e volta': 'üõü',
            'ganha-ganha': 'üéÅ',
            'barrado no baile': 'üö´',
        }
        icon = next((icon_map[k] for k in icon_map if k in lower), 'üé¨')
        return f'<div style="display:flex; align-items:center; gap:0.4rem;"><span>{icon}</span>{value}</div>'

    for _, row in df_show.iterrows():
        impacto = row.get('impacto', 'neutro')
        if impacto == 'positivo':
            border = '#2ecc71'
            bg = 'rgba(46, 204, 113, 0.12)'
            label = 'Benef√≠cio'
        elif impacto == 'negativo':
            border = '#e74c3c'
            bg = 'rgba(231, 76, 60, 0.12)'
            label = 'Preju√≠zo'
        else:
            border = '#95a5a6'
            bg = 'rgba(149, 165, 166, 0.08)'
            label = 'Neutro'

        actor_html = render_person_cell(row["actor"], border)
        target_html = render_person_cell(row["target"], border)
        context_html = render_context_cell(row.get("Din√¢mica"))
        impact_badge = (
            f'<span style="display:inline-block; padding: 0.15rem 0.5rem; border-radius: 999px; '
            f'background: {bg}; color: {border}; border: 1px solid {border}; font-size: 0.75rem;">{label}</span>'
        )

        print(f'<tr style="border-left: 4px solid {border}; background: {bg};">'
              f'<td style="padding: 0.45rem 0.5rem;">{row["date"]}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{context_html}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{row["Tipo"]}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{actor_html}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{target_html}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{row["detail"]}</td>'
              f'<td style="padding: 0.45rem 0.5rem;">{impact_badge}</td>'
              f'</tr>')

    print('</tbody></table></div>')
```

## üìä Impacto por Participante

```{python}
#| label: power-events-impact
#| output: asis

if not power_events:
    print("*Nenhum poder registrado ainda.*")
else:
    df_power = pd.DataFrame(power_events).copy()
    df_power['impacto'] = df_power.get('impacto', 'neutro')

    counts = df_power.pivot_table(
        index='target', columns='impacto', values='type',
        aggfunc='count', fill_value=0
    )
    pos = counts.get('positivo', pd.Series(dtype=int))
    neg = counts.get('negativo', pd.Series(dtype=int))

    impact = pd.DataFrame({
        'positivo': pos,
        'negativo': neg
    }).fillna(0)
    impact['saldo'] = impact['positivo'] - impact['negativo']
    impact = impact.sort_values('saldo')

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=impact.index,
        x=[-v for v in impact['negativo']],
        orientation='h',
        name='Preju√≠zo',
        marker_color='#e74c3c'
    ))
    fig.add_trace(go.Bar(
        y=impact.index,
        x=impact['positivo'],
        orientation='h',
        name='Benef√≠cio',
        marker_color='#2ecc71'
    ))
    fig.update_layout(
        title='Saldo de poderes por participante',
        barmode='relative',
        xaxis_title='Eventos',
        yaxis_title='',
        height=360 + 18 * len(impact)
    )
    fig.show()

    top_pos = impact['positivo'].idxmax() if len(impact) else None
    top_neg = impact['negativo'].idxmax() if len(impact) else None
    if top_pos and top_neg:
        print(f"**Mais beneficiado:** {top_pos} (+{int(impact.loc[top_pos, 'positivo'])})<br>"
              f"**Mais prejudicado:** {top_neg} (-{int(impact.loc[top_neg, 'negativo'])})")
```

::::

::: {.panel-tabset}

## üìä Quem Lidera?

```{python}
#| label: fatos-rapidos-lideranca
#| output: asis

# Compute leadership stats directly from daily_snapshots
if len(daily_snapshots) >= 2:
    # Helper: get sentiment ranking for a snapshot
    def get_ranking(snap):
        scores = []
        for p in snap['participants']:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            scores.append((p['name'], calc_sentiment(p)))
        return sorted(scores, key=lambda x: -x[1])

    # Current leader (latest daily snapshot)
    latest_ranking = get_ranking(daily_snapshots[-1])
    current_leader = latest_ranking[0][0]
    current_leader_score = latest_ranking[0][1]

    # Days leading (consecutive days at #1, counting backwards)
    days_leading = 0
    for snap in reversed(daily_snapshots):
        ranking = get_ranking(snap)
        if ranking and ranking[0][0] == current_leader:
            days_leading += 1
        else:
            break

    # Biggest position change (first day vs last day)
    first_ranking = get_ranking(daily_snapshots[0])
    first_rank_dict = {name: i+1 for i, (name, _) in enumerate(first_ranking)}
    latest_rank_dict = {name: i+1 for i, (name, _) in enumerate(latest_ranking)}

    position_changes = []
    for name, rank in latest_rank_dict.items():
        if name in first_rank_dict:
            change = first_rank_dict[name] - rank  # positive = improved
            position_changes.append((name, change, rank))

    biggest_rise = max(position_changes, key=lambda x: x[1]) if position_changes else None
    biggest_drop = min(position_changes, key=lambda x: x[1]) if position_changes else None

    # Top 5 newcomers (not in first snapshot's top 5)
    first_top5 = set([name for name, _ in first_ranking[:5]]) if len(first_ranking) >= 5 else set()
    current_top5 = set([name for name, _ in latest_ranking[:5]]) if len(latest_ranking) >= 5 else set()
    new_in_top5 = current_top5 - first_top5

    # Build the callout
    facts = []
    facts.append(f"**{current_leader}** lidera com **{current_leader_score:+.1f}** pontos")
    if days_leading > 1:
        facts.append(f"h√° **{days_leading} dias** consecutivos")

    detail_facts = []
    if biggest_rise and biggest_rise[1] > 2:
        detail_facts.append(f"‚Ä¢ Maior subida: **{biggest_rise[0]}** (+{biggest_rise[1]} posi√ß√µes)")
    if biggest_drop and biggest_drop[1] < -2:
        detail_facts.append(f"‚Ä¢ Maior queda: **{biggest_drop[0]}** ({biggest_drop[1]} posi√ß√µes)")
    if new_in_top5:
        names = ', '.join(sorted(new_in_top5))
        detail_facts.append(f"‚Ä¢ Novos no Top 5: **{names}**")

    details_str = "<br>".join(detail_facts) if detail_facts else ""

    print(f"""
::: {{.callout-note title="Fatos R√°pidos" appearance="simple"}}
{' '.join(facts[:2])}

{details_str}
:::
""")
else:
    print("")  # Not enough data
```

### Evolu√ß√£o do Sentimento {#evolucao}

Como o sentimento de cada participante mudou ao longo do tempo.

```{python}
#| label: late-entrants-caption
#| output: asis

if late_entrants:
    _by_date = {}
    for n, d in late_entrants.items():
        _by_date.setdefault(d, []).append(n)
    _parts = []
    for d, names in sorted(_by_date.items()):
        names_str = ', '.join(sorted(names))
        _parts.append(f"{names_str} (entraram em {d})")
    _late_str = '; '.join(_parts)
    print(f'<p class="text-muted small">‚ö†Ô∏è Participantes que entraram ap√≥s o in√≠cio do confinamento ({_late_str}) t√™m menos dias de dados.</p>')
```

```{python}
#| label: sentiment-timeline-prep
#| include: false

# Calcular sentimento para cada participante em cada dia (1 por dia)
timeline_data = []
if daily_metrics_map:
    for date_str in sorted(daily_metrics_map.keys()):
        entry = daily_metrics_map[date_str]
        for name, score in entry.get('sentiment', {}).items():
            timeline_data.append({
                'Data': pd.to_datetime(date_str),
                'Participante': name,
                'Sentimento': score,
                'Grupo': MEMBER_OF.get(name, '?')
            })
else:
    for snap in daily_snapshots:
        for p in snap['participants']:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            name = p['name']
            score = calc_sentiment(p)
            timeline_data.append({
                'Data': pd.to_datetime(snap['date']),
                'Participante': name,
                'Sentimento': score,
                'Grupo': p.get('characteristics', {}).get('memberOf', '?')
            })

df_timeline = pd.DataFrame(timeline_data)

# Pre-calculate ranking per day for bump chart
if not df_timeline.empty:
    df_timeline['Rank'] = df_timeline.groupby('Data')['Sentimento'].rank(ascending=False, method='min').astype(int)

# Build participant colors once
all_participants = sorted(df_timeline['Participante'].unique()) if not df_timeline.empty else []
palette = (
    px.colors.qualitative.Plotly + px.colors.qualitative.D3 +
    px.colors.qualitative.Set2 + px.colors.qualitative.Bold
)
participant_colors = {name: palette[i % len(palette)] for i, name in enumerate(all_participants)}

# Highlight top 3 and bottom 3 by latest score
if not df_timeline.empty:
    latest_scores = df_timeline.groupby('Participante')['Sentimento'].last()
    top3 = set(latest_scores.nlargest(3).index)
    bottom3 = set(latest_scores.nsmallest(3).index)
    highlight = top3 | bottom3
else:
    highlight = set()
```

::: {.panel-tabset}

#### Bump Chart (Ranking)

O **bump chart** mostra a **posi√ß√£o** de cada participante no ranking de sentimento. Mais f√°cil de acompanhar movimenta√ß√µes do que o gr√°fico de linhas.

```{python}
#| label: bump-chart

if not df_timeline.empty:
    fig = go.Figure()

    # Sort participants by their final rank for consistent legend order
    final_ranks = df_timeline[df_timeline['Data'] == df_timeline['Data'].max()].set_index('Participante')['Rank']
    sorted_participants = final_ranks.sort_values().index.tolist()

    for name in sorted_participants:
        df_p = df_timeline[df_timeline['Participante'] == name].sort_values('Data')
        is_hl = name in highlight
        p_color = participant_colors.get(name, '#666')

        # Latest rank and score for hover
        latest_rank = int(df_p['Rank'].iloc[-1])

        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Rank'],
            mode='lines+markers',
            name=f"{name} ({latest_rank}¬∫)",
            line=dict(width=3 if is_hl else 1.5, color=p_color),
            marker=dict(size=8 if is_hl else 5, color=p_color),
            hovertemplate=f'{name}<br>Posi√ß√£o: %{{y}}¬∫<br>Score: %{{customdata:+.1f}}<extra></extra>',
            customdata=df_p['Sentimento'],
            visible=True if is_hl else 'legendonly',
        ))

    n_participants = len(sorted_participants)

    fig.update_layout(
        title="Evolu√ß√£o do Ranking de Sentimento (Bump Chart)",
        xaxis_title="Data",
        yaxis_title="Posi√ß√£o no Ranking",
        yaxis=dict(
            autorange='reversed',  # 1st place at top
            tickmode='linear',
            tick0=1,
            dtick=1 if n_participants <= 15 else 2,
            range=[n_participants + 0.5, 0.5]
        ),
        height=max(500, n_participants * 25),
        hovermode='x unified',
        legend=dict(font=dict(size=10), itemsizing='constant'),
    )

    fig.show()
else:
    print("*Dados insuficientes para gerar o bump chart.*")
```

#### Linhas (Score)

Gr√°fico de linhas mostrando o **score absoluto** de sentimento. Top 3 e bottom 3 s√£o destacados por padr√£o.

```{python}
#| label: sentiment-timeline-lines

if not df_timeline.empty:
    fig = go.Figure()

    for name in all_participants:
        df_p = df_timeline[df_timeline['Participante'] == name].sort_values('Data')
        is_hl = name in highlight

        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Sentimento'],
            mode='lines+markers',
            name=name,
            line=dict(width=3 if is_hl else 1.5, color=participant_colors[name]),
            marker=dict(size=6 if is_hl else 4),
            hovertemplate=f'{name}: ' + '%{y:+.1f}<extra></extra>',
            visible=True if is_hl else 'legendonly',
        ))

    # Zero line
    fig.add_shape(type='line', x0=df_timeline['Data'].min(), x1=df_timeline['Data'].max(),
                  y0=0, y1=0, line=dict(color='red', dash='dash', width=1))

    # Pared√£o date lines (load from paredoes.json)
    paredoes_file = Path("data/paredoes.json")
    if paredoes_file.exists():
        with open(paredoes_file, encoding="utf-8") as f:
            paredoes_data = json.load(f)
        for p in paredoes_data.get('paredoes', []):
            paredao_date = pd.to_datetime(p['data'])
            y_range = [df_timeline['Sentimento'].min() - 2, df_timeline['Sentimento'].max() + 2]
            fig.add_shape(
                type='line', x0=paredao_date, x1=paredao_date,
                y0=y_range[0], y1=y_range[1],
                line=dict(color='#FF6B6B', dash='dot', width=2),
            )
            # Add annotation
            fig.add_annotation(
                x=paredao_date, y=y_range[1],
                text=f"üó≥Ô∏è {p['numero']}¬∫ Pared√£o",
                showarrow=False,
                font=dict(size=11, color='#FF6B6B'),
                yshift=10,
            )

    # Calculate height to match ranking chart (same formula)
    n_active = len([p for p in daily_snapshots[-1]['participants']
                    if not p.get('characteristics', {}).get('eliminated')])
    chart_height = max(500, n_active * 32)

    fig.update_layout(
        title="Evolu√ß√£o do Sentimento ao Longo do Tempo",
        xaxis_title="Data",
        yaxis_title="Score de Sentimento",
        height=chart_height,
        hovermode='x unified',
        legend=dict(font=dict(size=11), itemsizing='constant'),
        margin=dict(r=180),  # More room for legend
    )

    fig.show()
else:
    print("*Dados insuficientes para gerar o gr√°fico de evolu√ß√£o.*")
```

:::

### Destaques {#destaques-lideranca}

```{python}
#| label: destaques-lideranca
#| output: asis

if len(daily_snapshots) >= 3:
    # Reuse ranking computation from Fatos R√°pidos
    def _get_ranking(snap):
        scores = []
        for p in snap['participants']:
            if p.get('characteristics', {}).get('eliminated'):
                continue
            scores.append((p['name'], calc_sentiment(p)))
        return sorted(scores, key=lambda x: -x[1])

    first_ranking = _get_ranking(daily_snapshots[0])
    latest_ranking = _get_ranking(daily_snapshots[-1])

    first_rank_dict = {name: i+1 for i, (name, _) in enumerate(first_ranking)}
    latest_rank_dict = {name: i+1 for i, (name, _) in enumerate(latest_ranking)}

    # Most stable (smallest absolute position change)
    position_changes = []
    for name, rank in latest_rank_dict.items():
        if name in first_rank_dict:
            change = abs(first_rank_dict[name] - rank)
            position_changes.append((name, change, rank, first_rank_dict[name]))

    most_stable = min(position_changes, key=lambda x: (x[1], x[2])) if position_changes else None

    # Biggest rise and fall
    rises = [(name, first_rank_dict[name] - rank, rank) for name, rank in latest_rank_dict.items()
             if name in first_rank_dict and first_rank_dict[name] - rank > 0]
    falls = [(name, first_rank_dict[name] - rank, rank) for name, rank in latest_rank_dict.items()
             if name in first_rank_dict and first_rank_dict[name] - rank < 0]

    biggest_rise = max(rises, key=lambda x: x[1]) if rises else None
    biggest_fall = min(falls, key=lambda x: x[1]) if falls else None

    # Current leader stats
    current_leader = latest_ranking[0][0]
    leader_score = latest_ranking[0][1]
    leader_first_rank = first_rank_dict.get(current_leader, "?")

    # Build narrative
    sections = []

    # Leader story
    if leader_first_rank != 1 and leader_first_rank != "?":
        sections.append(f"**üèÜ {current_leader}** subiu da **{leader_first_rank}¬™ posi√ß√£o** para o topo do ranking. "
                       f"Com **{leader_score:+.1f}** pontos de sentimento, consolidou-se como o participante mais querido.")
    else:
        sections.append(f"**üèÜ {current_leader}** lidera com **{leader_score:+.1f}** pontos de sentimento.")

    # Rise story
    if biggest_rise and biggest_rise[1] >= 3:
        name, change, current_rank = biggest_rise
        grupo = MEMBER_OF.get(name, '?')
        sections.append(f"**üìà Maior Ascens√£o:** **{name}** ({grupo}) subiu **{change} posi√ß√µes** e agora est√° em {current_rank}¬∫ lugar. "
                       f"Uma trajet√≥ria de recupera√ß√£o que vale acompanhar.")

    # Fall story
    if biggest_fall and biggest_fall[1] <= -3:
        name, change, current_rank = biggest_fall
        grupo = MEMBER_OF.get(name, '?')
        sections.append(f"**üìâ Maior Queda:** **{name}** ({grupo}) caiu **{abs(change)} posi√ß√µes** para o {current_rank}¬∫ lugar. "
                       f"Pode estar em risco se houver pared√£o.")

    # Stability story
    if most_stable and most_stable[1] <= 2:
        name, change, rank, first_rank = most_stable
        grupo = MEMBER_OF.get(name, '?')
        if change == 0:
            sections.append(f"**‚öì Mais Est√°vel:** **{name}** ({grupo}) manteve a mesma posi√ß√£o ({rank}¬∫) desde o in√≠cio. "
                           f"Consist√™ncia pode indicar uma base s√≥lida de apoio.")
        else:
            sections.append(f"**‚öì Mais Est√°vel:** **{name}** ({grupo}) variou apenas {change} posi√ß√£o (de {first_rank}¬∫ para {rank}¬∫).")

    if sections:
        print("::: {.callout-tip title=\"Destaques\" appearance=\"simple\"}")
        print("<br>".join(sections))
        print(":::")
else:
    print("")
```

## ‚ù§Ô∏è Aliados

```{python}
#| label: fatos-rapidos-aliados
#| output: asis

# Compute alliance stats from daily_matrices
if len(daily_snapshots) >= 2:
    # Count mutual hearts per pair across all days
    _mutual_heart_days = defaultdict(int)
    _participant_allies = defaultdict(set)  # name -> set of allies

    for idx, matrix in enumerate(daily_matrices):
        snap = daily_snapshots[idx]
        active_set = set(p['name'] for p in snap['participants']
                         if not p.get('characteristics', {}).get('eliminated'))
        checked = set()

        for (giver, receiver), label in matrix.items():
            if giver not in active_set or receiver not in active_set:
                continue
            pair = tuple(sorted([giver, receiver]))
            if pair in checked:
                continue

            if label == 'Cora√ß√£o':
                reverse = matrix.get((receiver, giver))
                if reverse == 'Cora√ß√£o':
                    _mutual_heart_days[pair] += 1
                    checked.add(pair)

    # Stable alliances (>70% of days)
    threshold = n_daily * 0.7
    stable_alliances = [(pair, days) for pair, days in _mutual_heart_days.items() if days >= threshold]
    n_stable = len(stable_alliances)

    # Build alliance network for most connected
    for pair, days in _mutual_heart_days.items():
        if days >= threshold:
            a, b = pair
            _participant_allies[a].add(b)
            _participant_allies[b].add(a)

    # Most connected (most stable alliances)
    most_connected = None
    max_allies = 0
    for name, allies in _participant_allies.items():
        if len(allies) > max_allies:
            max_allies = len(allies)
            most_connected = name

    # Isolated participants (no stable alliances)
    active_latest = set(p['name'] for p in daily_snapshots[-1]['participants']
                        if not p.get('characteristics', {}).get('eliminated'))
    isolated = [name for name in active_latest if name not in _participant_allies or len(_participant_allies[name]) == 0]
    n_isolated = len(isolated)

    # Build callout
    facts = [f"**{n_stable}** alian√ßas est√°veis (‚ù§Ô∏è m√∫tuo em >70% dos dias)"]

    if most_connected and max_allies > 0:
        facts.append(f"‚Ä¢ Mais conectado: **{most_connected}** ({max_allies} aliados)")

    if n_isolated > 0:
        isolated_names = ', '.join(sorted(isolated)[:3])
        if n_isolated > 3:
            isolated_names += f" e +{n_isolated-3}"
        facts.append(f"‚Ä¢ Sem alian√ßas est√°veis: **{isolated_names}**")

    print(f"""
::: {{.callout-note title="Fatos R√°pidos" appearance="simple"}}
{facts[0]}

{"<br>".join(facts[1:])}
:::
""")
else:
    print("")
```

### Alian√ßas {#aliancas}

Quem s√£o os aliados? An√°lise das rela√ß√µes positivas mais duradouras da temporada.

#### Alian√ßas Mais Consistentes

Pares que trocaram ‚ù§Ô∏è m√∫tuo na maior quantidade de dias.

```{python}
#| label: alliances

# Calcular alian√ßas m√∫tuas ao longo do tempo (1 por dia)
mutual_heart_history = defaultdict(int)
mutual_neg_history = defaultdict(int)
total_coexist = defaultdict(int)

for idx, matrix in enumerate(daily_matrices):
    snap = daily_snapshots[idx]
    active_set = set(p['name'] for p in snap['participants']
                     if not p.get('characteristics', {}).get('eliminated'))

    checked_heart = set()
    checked_neg = set()

    for (giver, receiver), label in matrix.items():
        if giver not in active_set or receiver not in active_set:
            continue
        pair = tuple(sorted([giver, receiver]))
        total_coexist[pair] += 1  # conta dobrada mas consistente

        if pair not in checked_heart and label == 'Cora√ß√£o':
            reverse = matrix.get((receiver, giver))
            if reverse == 'Cora√ß√£o':
                mutual_heart_history[pair] += 1
                checked_heart.add(pair)

        if pair not in checked_neg and label not in POSITIVE:
            reverse = matrix.get((receiver, giver))
            if reverse is not None and reverse not in POSITIVE:
                mutual_neg_history[pair] += 1
                checked_neg.add(pair)

# Top alian√ßas
top_alliances = sorted(mutual_heart_history.items(), key=lambda x: -x[1])[:15]

alliance_data = []
for (a, b), count in top_alliances:
    alliance_data.append({
        'Par': f"{a} ‚Üî {b}",
        'Dias com ‚ù§Ô∏è m√∫tuo': count,
        'Total de dias': n_daily,
        'Consist√™ncia': f"{count/n_daily*100:.0f}%"
    })

df_alliances = pd.DataFrame(alliance_data)

fig = go.Figure(go.Bar(
    x=[a['Dias com ‚ù§Ô∏è m√∫tuo'] for a in alliance_data],
    y=[a['Par'] for a in alliance_data],
    orientation='h',
    marker_color='#1a9850',
    text=[a['Consist√™ncia'] for a in alliance_data],
    textposition='outside',
    hovertemplate='%{y}: ‚ù§Ô∏è m√∫tuo em %{x}/' + str(n_daily) + ' dias<extra></extra>'
))

fig.update_layout(
    title="Top 15 Alian√ßas Mais Consistentes (‚ù§Ô∏è M√∫tuo)",
    xaxis_title=f"Dias com ‚ù§Ô∏è m√∫tuo (de {n_daily})",
    yaxis_title="",
    height=500,
    margin=dict(l=250),
    xaxis_range=[0, n_daily + 1]
)

fig.show()
```

#### Rivalidades Mais Persistentes

Pares que trocaram rea√ß√µes negativas m√∫tuas na maior quantidade de dias.

```{python}
#| label: rivalries

top_rivalries = sorted(mutual_neg_history.items(), key=lambda x: -x[1])[:15]

rivalry_data = []
for (a, b), count in top_rivalries:
    rivalry_data.append({
        'Par': f"{a} vs {b}",
        'Dias com rivalidade': count,
        'Total': n_daily,
        'Persist√™ncia': f"{count/n_daily*100:.0f}%"
    })

if rivalry_data:
    fig = go.Figure(go.Bar(
        x=[r['Dias com rivalidade'] for r in rivalry_data],
        y=[r['Par'] for r in rivalry_data],
        orientation='h',
        marker_color='#d73027',
        text=[r['Persist√™ncia'] for r in rivalry_data],
        textposition='outside',
        hovertemplate='%{y}: rivalidade em %{x}/' + str(n_daily) + ' dias<extra></extra>'
    ))

    fig.update_layout(
        title="Top 15 Rivalidades Mais Persistentes (Negativa M√∫tua)",
        xaxis_title=f"Dias com rivalidade (de {n_daily})",
        yaxis_title="",
        height=500,
        margin=dict(l=300),
        xaxis_range=[0, n_daily + 1]
    )

    fig.show()
```

### Din√¢mica Vip vs Xepa {#grupos}

Os membros do mesmo grupo (Vip/Xepa) favorecem uns aos outros com mais ‚ù§Ô∏è?

```{python}
#| label: group-favoritism
#| output: asis

fav_data = []
for i, snap in enumerate(daily_snapshots):
    matrix = daily_matrices[i]
    name_to_group = {}
    for p in snap['participants']:
        if not p.get('characteristics', {}).get('eliminated'):
            name_to_group[p['name']] = p.get('characteristics', {}).get('group', '?')

    unique_groups = set(name_to_group.values())
    if len(unique_groups) <= 1:
        continue

    in_hearts, in_total = 0, 0
    out_hearts, out_total = 0, 0

    for (giver, receiver), label in matrix.items():
        if giver not in name_to_group or receiver not in name_to_group:
            continue
        same = name_to_group[giver] == name_to_group[receiver]
        is_heart = label == 'Cora√ß√£o'
        if same:
            in_total += 1
            if is_heart: in_hearts += 1
        else:
            out_total += 1
            if is_heart: out_hearts += 1

    in_pct = (in_hearts / in_total * 100) if in_total > 0 else 0
    out_pct = (out_hearts / out_total * 100) if out_total > 0 else 0

    fav_data.append({
        'Data': pd.to_datetime(snap['date']),
        'Intragrupo (%)': round(in_pct, 1),
        'Intergrupo (%)': round(out_pct, 1),
        'Vi√©s': round(in_pct - out_pct, 1)
    })

df_fav = pd.DataFrame(fav_data)

if not df_fav.empty:
    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=df_fav['Data'], y=df_fav['Intragrupo (%)'],
        mode='lines+markers', name='Mesmo grupo',
        line=dict(color='#2196F3', width=2)
    ))
    fig.add_trace(go.Scatter(
        x=df_fav['Data'], y=df_fav['Intergrupo (%)'],
        mode='lines+markers', name='Grupo diferente',
        line=dict(color='#FF9800', width=2)
    ))

    fig.update_layout(
        title="Favoritismo: ‚ù§Ô∏è Dentro do Grupo vs Entre Grupos",
        xaxis_title="Data",
        yaxis_title="% de rea√ß√µes que s√£o ‚ù§Ô∏è",
        height=400,
        yaxis_range=[50, 100]
    )

    fig.show()

    avg_bias = df_fav['Vi√©s'].mean()
    if avg_bias > 2:
        print(f"Vi√©s m√©dio: **{avg_bias:+.1f} pontos percentuais** a favor do pr√≥prio grupo.")
    elif avg_bias < -2:
        print(f"Vi√©s m√©dio: **{avg_bias:+.1f} pp** ‚Äî surpreendentemente, h√° *mais* cora√ß√µes para o grupo oposto!")
    else:
        print(f"Vi√©s m√©dio: **{avg_bias:+.1f} pp** ‚Äî praticamente nenhum favoritismo de grupo.")
```

### Destaques {#destaques-aliados}

```{python}
#| label: destaques-aliados
#| output: asis

if len(daily_snapshots) >= 3:
    # Compute alliance stats (similar to Fatos R√°pidos but with more detail)
    _alliance_days = defaultdict(int)
    _ally_network = defaultdict(set)

    for idx, matrix in enumerate(daily_matrices):
        snap = daily_snapshots[idx]
        active_set = set(p['name'] for p in snap['participants']
                         if not p.get('characteristics', {}).get('eliminated'))
        checked = set()

        for (giver, receiver), label in matrix.items():
            if giver not in active_set or receiver not in active_set:
                continue
            pair = tuple(sorted([giver, receiver]))
            if pair in checked:
                continue

            if label == 'Cora√ß√£o':
                reverse = matrix.get((receiver, giver))
                if reverse == 'Cora√ß√£o':
                    _alliance_days[pair] += 1
                    checked.add(pair)

    # Build network of stable alliances (>50% of days)
    threshold = n_daily * 0.5
    for pair, days in _alliance_days.items():
        if days >= threshold:
            a, b = pair
            _ally_network[a].add(b)
            _ally_network[b].add(a)

    # Strongest alliance
    strongest = max(_alliance_days.items(), key=lambda x: x[1]) if _alliance_days else None

    # Most connected
    most_connected = max(_ally_network.items(), key=lambda x: len(x[1])) if _ally_network else None

    # Isolated participants
    active_latest = set(p['name'] for p in daily_snapshots[-1]['participants']
                        if not p.get('characteristics', {}).get('eliminated'))
    isolated = [name for name in active_latest if name not in _ally_network or len(_ally_network[name]) == 0]

    # Build narrative
    sections = []

    # Strongest alliance story
    if strongest:
        a, b = sorted(strongest[0])
        days = strongest[1]
        pct = days / n_daily * 100
        grupo_a = MEMBER_OF.get(a, '?')
        grupo_b = MEMBER_OF.get(b, '?')
        same_group = grupo_a == grupo_b

        if same_group:
            sections.append(f"**‚ù§Ô∏è Alian√ßa Mais Forte:** **{a}** e **{b}** (ambos {grupo_a}) trocaram cora√ß√µes m√∫tuos em "
                           f"**{days} de {n_daily} dias** ({pct:.0f}%). Uma alian√ßa s√≥lida dentro do mesmo grupo.")
        else:
            sections.append(f"**‚ù§Ô∏è Alian√ßa Mais Forte:** **{a}** ({grupo_a}) e **{b}** ({grupo_b}) mant√™m cora√ß√µes m√∫tuos h√° "
                           f"**{days} dias** ({pct:.0f}%). Uma ponte entre grupos que pode ser estrat√©gica.")

    # Most connected story
    if most_connected and len(most_connected[1]) >= 3:
        name, allies = most_connected
        grupo = MEMBER_OF.get(name, '?')
        ally_list = ', '.join(sorted(list(allies)[:4]))
        if len(allies) > 4:
            ally_list += f" e +{len(allies)-4}"
        sections.append(f"**üåü Mais Conectado:** **{name}** ({grupo}) tem **{len(allies)} aliados est√°veis**: {ally_list}. "
                       f"Uma posi√ß√£o social forte que pode proteger em vota√ß√µes.")

    # Isolated story
    if isolated:
        isolated_info = []
        for name in sorted(isolated)[:3]:
            grupo = MEMBER_OF.get(name, '?')
            isolated_info.append(f"{name} ({grupo})")
        isolated_str = ', '.join(isolated_info)
        if len(isolated) > 3:
            isolated_str += f" e +{len(isolated)-3}"
        sections.append(f"**‚ö†Ô∏è Sem Aliados Est√°veis:** {isolated_str}. "
                       f"Participantes isolados s√£o mais vulner√°veis em pared√µes ‚Äî sem aliados para defend√™-los na vota√ß√£o.")

    if sections:
        print("::: {.callout-tip title=\"Destaques\" appearance=\"simple\"}")
        print("<br>".join(sections))
        print(":::")
else:
    print("")
```

## üìà Tend√™ncias

```{python}
#| label: fatos-rapidos-tendencias
#| output: asis

# Compute volatility stats from daily_matrices
if len(daily_snapshots) >= 2:
    # Changes yesterday (last two daily snapshots)
    prev_m = daily_matrices[-2]
    curr_m = daily_matrices[-1]
    common_pairs = set(prev_m.keys()) & set(curr_m.keys())

    changes_yesterday = []
    for pair in common_pairs:
        if prev_m[pair] != curr_m[pair]:
            giver, receiver = pair
            from_rxn = prev_m[pair]
            to_rxn = curr_m[pair]
            changes_yesterday.append((giver, receiver, from_rxn, to_rxn))

    n_changes = len(changes_yesterday)

    # Most dramatic change (from positive to strong negative or vice versa)
    dramatic_changes = []
    for giver, receiver, from_rxn, to_rxn in changes_yesterday:
        # Score: positive to strong negative = 2, positive to mild = 1, etc.
        from_positive = from_rxn in POSITIVE
        to_positive = to_rxn in POSITIVE
        from_strong_neg = from_rxn in STRONG_NEGATIVE
        to_strong_neg = to_rxn in STRONG_NEGATIVE

        drama_score = 0
        if from_positive and to_strong_neg:
            drama_score = 2  # ‚ù§Ô∏è ‚Üí üêç/ü§Æ/etc
        elif from_strong_neg and to_positive:
            drama_score = 2  # üêç ‚Üí ‚ù§Ô∏è
        elif from_positive and not to_positive:
            drama_score = 1  # ‚ù§Ô∏è ‚Üí mild negative
        elif not from_positive and to_positive:
            drama_score = 1  # negative ‚Üí ‚ù§Ô∏è

        if drama_score > 0:
            emoji_from = REACTION_EMOJI.get(from_rxn, from_rxn)
            emoji_to = REACTION_EMOJI.get(to_rxn, to_rxn)
            dramatic_changes.append((giver, receiver, emoji_from, emoji_to, drama_score))

    biggest_flip = max(dramatic_changes, key=lambda x: x[4]) if dramatic_changes else None

    # Volatility level based on percentage of reactions that changed
    total_reactions = len(common_pairs)
    if total_reactions > 0:
        change_pct = n_changes / total_reactions * 100
        if change_pct > 15:
            volatility_level = "alta"
        elif change_pct > 5:
            volatility_level = "m√©dia"
        else:
            volatility_level = "baixa"
    else:
        volatility_level = "?"
        change_pct = 0

    # Top vira-casaca (most total changes across all days)
    total_changes_per_giver = Counter()
    for i in range(1, len(daily_snapshots)):
        pm = daily_matrices[i-1]
        cm = daily_matrices[i]
        cp = set(pm.keys()) & set(cm.keys())
        for p in cp:
            if pm[p] != cm[p]:
                total_changes_per_giver[p[0]] += 1

    top_viracasaca = total_changes_per_giver.most_common(1)[0] if total_changes_per_giver else None

    # Build callout
    facts = [f"**{n_changes}** rea√ß√µes mudaram ontem ({change_pct:.0f}% do total)"]
    facts.append(f"Volatilidade: **{volatility_level}**")

    detail_facts = []
    if biggest_flip:
        detail_facts.append(f"‚Ä¢ Maior virada: **{biggest_flip[0]}** ‚Üí {biggest_flip[1]} ({biggest_flip[2]} ‚Üí {biggest_flip[3]})")
    if top_viracasaca:
        detail_facts.append(f"‚Ä¢ Mais inst√°vel: **{top_viracasaca[0]}** ({top_viracasaca[1]} mudan√ßas totais)")

    print(f"""
::: {{.callout-note title="Fatos R√°pidos" appearance="simple"}}
{' | '.join(facts)}

{"<br>".join(detail_facts)}
:::
""")
else:
    print("")
```

### O Que Est√° Mudando? {#tendencias}

Quem muda de opini√£o? Quais relacionamentos est√£o se transformando?

#### Quem Muda Mais de Opini√£o? ("Vira-Casacas")

Participantes que mais mudaram suas rea√ß√µes ao longo do tempo.

```{python}
#| label: flip-floppers

giver_change_count = Counter()
for i in range(1, len(daily_snapshots)):
    prev_m = daily_matrices[i-1]
    curr_m = daily_matrices[i]
    common_pairs = set(prev_m.keys()) & set(curr_m.keys())
    for pair in common_pairs:
        if prev_m[pair] != curr_m[pair]:
            giver_change_count[pair[0]] += 1

# Normalizar pelo n√∫mero de transi√ß√µes di√°rias em que estiveram ativos
giver_transitions = Counter()
for i in range(1, len(daily_snapshots)):
    prev_active = set(p['name'] for p in daily_snapshots[i-1]['participants']
                      if not p.get('characteristics', {}).get('eliminated'))
    curr_active = set(p['name'] for p in daily_snapshots[i]['participants']
                      if not p.get('characteristics', {}).get('eliminated'))
    for name in prev_active & curr_active:
        giver_transitions[name] += 1

flipflop_data = []
for name, changes in giver_change_count.most_common():
    trans = giver_transitions.get(name, 1)
    if trans >= 3:  # m√≠nimo de 3 transi√ß√µes
        flipflop_data.append({
            'Participante': name,
            'Mudan√ßas': changes,
            'Transi√ß√µes': trans,
            'Taxa': round(changes / trans, 1)
        })

df_flip = pd.DataFrame(flipflop_data).sort_values('Mudan√ßas', ascending=True)

if not df_flip.empty:
    fig = go.Figure(go.Bar(
        y=df_flip['Participante'],
        x=df_flip['Mudan√ßas'],
        orientation='h',
        marker_color=[GROUP_COLORS.get(MEMBER_OF.get(n, '?'), '#999')
                      for n in df_flip['Participante']],
        text=[f"{m} ({t:.1f}/dia)" for m, t in zip(df_flip['Mudan√ßas'], df_flip['Taxa'])],
        textposition='outside',
        hovertemplate='%{y}: %{x} mudan√ßas totais<extra></extra>'
    ))

    fig.update_layout(
        title="Vira-Casacas: Quem Muda Mais de Opini√£o?",
        xaxis_title="Total de mudan√ßas de rea√ß√£o",
        yaxis_title="",
        height=max(400, len(df_flip) * 25),
        margin=dict(l=150)
    )

    fig.show()
```

### Destaques {#destaques-tendencias}

```{python}
#| label: destaques-tendencias
#| output: asis

if len(daily_snapshots) >= 3:
    # Compute change stats
    _changes_per_day = []
    _dramatic_flips = []  # (giver, receiver, from, to, date)

    for i in range(1, len(daily_snapshots)):
        prev_m = daily_matrices[i-1]
        curr_m = daily_matrices[i]
        snap = daily_snapshots[i]
        common = set(prev_m.keys()) & set(curr_m.keys())

        day_changes = 0
        for pair in common:
            if prev_m[pair] != curr_m[pair]:
                day_changes += 1
                from_rxn = prev_m[pair]
                to_rxn = curr_m[pair]
                # Check if dramatic (positive ‚Üî strong negative)
                from_pos = from_rxn in POSITIVE
                to_pos = to_rxn in POSITIVE
                from_strong = from_rxn in STRONG_NEGATIVE
                to_strong = to_rxn in STRONG_NEGATIVE

                if (from_pos and to_strong) or (from_strong and to_pos):
                    giver, receiver = pair
                    _dramatic_flips.append((giver, receiver, from_rxn, to_rxn, snap['date']))

        _changes_per_day.append(day_changes)

    # Most volatile day
    if _changes_per_day:
        max_changes = max(_changes_per_day)
        max_day_idx = _changes_per_day.index(max_changes) + 1  # +1 because we start from index 1
        most_volatile_date = daily_snapshots[max_day_idx]['date']

    # Total vira-casacas
    _giver_changes = Counter()
    for i in range(1, len(daily_snapshots)):
        prev_m = daily_matrices[i-1]
        curr_m = daily_matrices[i]
        common = set(prev_m.keys()) & set(curr_m.keys())
        for pair in common:
            if prev_m[pair] != curr_m[pair]:
                _giver_changes[pair[0]] += 1

    top_viracasaca = _giver_changes.most_common(1)[0] if _giver_changes else None
    most_stable_giver = min(_giver_changes.items(), key=lambda x: x[1]) if _giver_changes else None

    # Build narrative
    sections = []

    # Top vira-casaca story
    if top_viracasaca:
        name, changes = top_viracasaca
        grupo = MEMBER_OF.get(name, '?')
        avg_per_day = changes / (len(daily_snapshots) - 1)
        sections.append(f"**üîÑ Mais Inst√°vel:** **{name}** ({grupo}) mudou de opini√£o **{changes} vezes** "
                       f"(m√©dia de {avg_per_day:.1f} mudan√ßas/dia). Opini√µes vol√°teis podem indicar indecis√£o ou estrat√©gia.")

    # Most dramatic flip
    if _dramatic_flips:
        # Most recent dramatic flip
        latest_flip = _dramatic_flips[-1]
        giver, receiver, from_rxn, to_rxn, date = latest_flip
        from_emoji = REACTION_EMOJI.get(from_rxn, from_rxn)
        to_emoji = REACTION_EMOJI.get(to_rxn, to_rxn)
        if from_rxn in POSITIVE:
            sections.append(f"**üíî Virada Dram√°tica:** **{giver}** mudou de {from_emoji} para {to_emoji} com **{receiver}** "
                           f"em {date}. Uma amizade que virou hostilidade.")
        else:
            sections.append(f"**üíö Reconcilia√ß√£o:** **{giver}** mudou de {from_emoji} para {to_emoji} com **{receiver}** "
                           f"em {date}. Uma hostilidade que virou amizade.")

    # Volatility trend
    if len(_changes_per_day) >= 3:
        recent_avg = sum(_changes_per_day[-3:]) / 3
        earlier_avg = sum(_changes_per_day[:3]) / 3 if len(_changes_per_day) >= 6 else recent_avg
        if recent_avg > earlier_avg * 1.5:
            sections.append(f"**üìà Tend√™ncia:** O jogo est√° **mais vol√°til** recentemente. "
                           f"M√©dia de {recent_avg:.0f} mudan√ßas/dia nos √∫ltimos 3 dias vs {earlier_avg:.0f} no in√≠cio.")
        elif recent_avg < earlier_avg * 0.7:
            sections.append(f"**üìâ Tend√™ncia:** O jogo est√° **mais est√°vel** recentemente. "
                           f"As opini√µes parecem estar se consolidando.")

    if sections:
        print("::: {.callout-tip title=\"Destaques\" appearance=\"simple\"}")
        print("<br>".join(sections))
        print(":::")
else:
    print("")
```

## üìú Hist√≥rico

### Hostilidades Persistentes {#hostilidades}

As hostilidades mais duradouras da temporada ‚Äî quem se detesta h√° mais tempo e quem mant√©m m√°goa unilateral.

#### Rivalidades Mais Longas

Pares que se detestam mutuamente h√° mais tempo.

```{python}
#| label: hostility-persistent-two
#| output: asis

# Track hostility persistence across all daily snapshots
persistent_two_sided = defaultdict(int)  # frozenset -> days
persistent_one_sided = defaultdict(int)  # (hostile, friendly) -> days

for idx, matrix in enumerate(daily_matrices):
    snap = daily_snapshots[idx]
    active_set = set(p['name'] for p in snap['participants']
                     if not p.get('characteristics', {}).get('eliminated'))

    checked = set()
    for (a, b), rxn_a_to_b in matrix.items():
        if a not in active_set or b not in active_set:
            continue

        rxn_b_to_a = matrix.get((b, a), '')
        a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
        b_dislikes_a = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''
        b_likes_a = rxn_b_to_a in POSITIVE

        pair = frozenset([a, b])

        if a_dislikes_b and b_dislikes_a:
            if pair not in checked:
                persistent_two_sided[pair] += 1
                checked.add(pair)
        elif a_dislikes_b and b_likes_a:
            persistent_one_sided[(a, b)] += 1

# ‚îÄ‚îÄ Most persistent two-sided ‚îÄ‚îÄ
top_persistent_two = sorted(persistent_two_sided.items(), key=lambda x: -x[1])[:10]
if top_persistent_two:
    persistent_two_data = []
    for pair, days in top_persistent_two:
        a, b = sorted(pair)
        pct = days / n_daily * 100
        persistent_two_data.append({
            'Par': f"{a} vs {b}",
            'Dias': days,
            'Persist√™ncia': f"{pct:.0f}%"
        })

    fig = go.Figure(go.Bar(
        y=[d['Par'] for d in persistent_two_data],
        x=[d['Dias'] for d in persistent_two_data],
        orientation='h',
        marker_color='#d73027',
        text=[d['Persist√™ncia'] for d in persistent_two_data],
        textposition='outside',
        hovertemplate='%{y}: %{x}/' + str(n_daily) + ' dias<extra></extra>',
    ))

    fig.update_layout(
        title="Top 10 Rivalidades Mais Persistentes (Hostilidade M√∫tua)",
        xaxis_title=f"Dias de hostilidade m√∫tua (de {n_daily})",
        yaxis_title="",
        height=max(350, len(persistent_two_data) * 35),
        margin=dict(l=250),
        xaxis_range=[0, n_daily + 1],
    )

    fig.show()

    # Highlight the longest
    if top_persistent_two:
        longest = top_persistent_two[0]
        a, b = sorted(longest[0])
        if longest[1] >= n_daily * 0.8:
            print(f"\n> üî• **Rivalidade central:** {a} vs {b} se detestam h√° **{longest[1]} dias** "
                  f"({longest[1]/n_daily*100:.0f}% da temporada). Este √© um conflito estrutural do jogo.")
else:
    print("*Nenhuma rivalidade persistente.*")
```

#### Hostilidades Unilaterais Mais Longas

Quem mais tempo detesta algu√©m que lhe d√° ‚ù§Ô∏è.

```{python}
#| label: hostility-persistent-one
#| output: asis

top_persistent_one = sorted(persistent_one_sided.items(), key=lambda x: -x[1])[:10]
if top_persistent_one:
    persistent_one_data = []
    for (hostile, friendly), days in top_persistent_one:
        pct = days / n_daily * 100
        persistent_one_data.append({
            'Rela√ß√£o': f"{hostile} üò†‚Üí {friendly} ‚ù§Ô∏è",
            'Dias': days,
            'Persist√™ncia': f"{pct:.0f}%"
        })

    fig = go.Figure(go.Bar(
        y=[d['Rela√ß√£o'] for d in persistent_one_data],
        x=[d['Dias'] for d in persistent_one_data],
        orientation='h',
        marker_color='#f39c12',
        text=[d['Persist√™ncia'] for d in persistent_one_data],
        textposition='outside',
        hovertemplate='%{y}: %{x}/' + str(n_daily) + ' dias<extra></extra>',
    ))

    fig.update_layout(
        title="Top 10 Hostilidades Unilaterais Mais Persistentes",
        xaxis_title=f"Dias de hostilidade unilateral (de {n_daily})",
        yaxis_title="",
        height=max(350, len(persistent_one_data) * 35),
        margin=dict(l=300),
        xaxis_range=[0, n_daily + 1],
    )

    fig.show()

    # Insight about game dynamics
    if top_persistent_one:
        longest = top_persistent_one[0]
        hostile, friendly = longest[0]
        if longest[1] >= n_daily * 0.5:
            print(f"\n> ‚ö†Ô∏è **Ponto cego persistente:** {friendly} d√° ‚ù§Ô∏è para {hostile} "
                  f"h√° **{longest[1]} dias**, mas {hostile} continua hostil. "
                  f"Se {hostile} precisar votar, {friendly} pode ser surpreendido(a).")
else:
    print("*Nenhuma hostilidade unilateral persistente.*")
```

### Saldo e Economia {#saldo}

O saldo (Estalecas) de cada participante ao longo do tempo.

```{python}
#| label: balance-timeline-caption
#| output: asis

if late_caption:
    print(f'<p class="text-muted small">{late_caption}</p>')
```

```{python}
#| label: balance-timeline

balance_data = []
for i, snap in enumerate(snapshots):
    for p in snap['participants']:
        if p.get('characteristics', {}).get('eliminated'):
            continue
        balance_data.append({
            'Data': pd.to_datetime(snap['date']),
            'Participante': p['name'],
            'Saldo': p.get('characteristics', {}).get('balance', 0),
            'Grupo': p.get('characteristics', {}).get('memberOf', '?')
        })

df_balance = pd.DataFrame(balance_data)

if not df_balance.empty:
    # Paleta com cores distintas para cada participante
    all_bal_participants = sorted(df_balance['Participante'].unique())
    palette_bal = (
        px.colors.qualitative.Plotly + px.colors.qualitative.D3 +
        px.colors.qualitative.Set2 + px.colors.qualitative.Bold
    )
    bal_colors = {name: palette_bal[i % len(palette_bal)] for i, name in enumerate(all_bal_participants)}

    # Top 3 e bottom 3 pelo √∫ltimo saldo ‚Äî vis√≠veis por padr√£o
    latest_bal = df_balance.groupby('Participante')['Saldo'].last()
    top3_bal = set(latest_bal.nlargest(3).index)
    bottom3_bal = set(latest_bal.nsmallest(3).index)
    highlight_bal = top3_bal | bottom3_bal

    fig = go.Figure()

    for name in all_bal_participants:
        df_p = df_balance[df_balance['Participante'] == name].sort_values('Data')
        is_hl = name in highlight_bal

        fig.add_trace(go.Scatter(
            x=df_p['Data'], y=df_p['Saldo'],
            mode='lines+markers',
            name=name,
            line=dict(width=3 if is_hl else 1.5, color=bal_colors[name]),
            marker=dict(size=6 if is_hl else 4),
            hovertemplate=f'{name}: ' + '%{y:,} Estalecas<extra></extra>',
            visible=True if is_hl else 'legendonly',
        ))

    fig.update_layout(
        title="Evolu√ß√£o do Saldo (Estalecas)",
        xaxis_title="Data",
        yaxis_title="Saldo (Estalecas)",
        height=600,
        hovermode='x unified',
        legend=dict(font=dict(size=10), itemsizing='constant'),
    )

    fig.show()
```

## ‚öîÔ∏è Conflitos

```{python}
#| label: fatos-rapidos-conflitos
#| output: asis

# Compute conflict stats from latest snapshot and history
if len(daily_snapshots) >= 1:
    # Current hostilities from latest snapshot
    latest_active = set(p['name'] for p in latest['participants']
                        if not p.get('characteristics', {}).get('eliminated'))

    two_sided_today = []
    one_sided_today = []
    checked = set()

    for (a, b), rxn_a_to_b in latest_matrix.items():
        if a not in latest_active or b not in latest_active:
            continue
        pair = frozenset([a, b])
        if pair in checked:
            continue

        rxn_b_to_a = latest_matrix.get((b, a), '')
        a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
        b_dislikes_a = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''
        b_likes_a = rxn_b_to_a in POSITIVE

        if a_dislikes_b and b_dislikes_a:
            two_sided_today.append((a, b))
            checked.add(pair)
        elif a_dislikes_b and b_likes_a:
            one_sided_today.append((a, b))

    n_mutual = len(two_sided_today)
    n_one_sided = len(one_sided_today)

    # Longest rivalry from historical data (persistent_two_sided computed earlier? No, need to compute)
    _persistent_two_sided = defaultdict(int)
    for idx, matrix in enumerate(daily_matrices):
        snap = daily_snapshots[idx]
        active_set = set(p['name'] for p in snap['participants']
                         if not p.get('characteristics', {}).get('eliminated'))
        checked_hist = set()

        for (a, b), rxn_a_to_b in matrix.items():
            if a not in active_set or b not in active_set:
                continue
            rxn_b_to_a = matrix.get((b, a), '')
            a_dislikes = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
            b_dislikes = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''

            pair = frozenset([a, b])
            if a_dislikes and b_dislikes and pair not in checked_hist:
                _persistent_two_sided[pair] += 1
                checked_hist.add(pair)

    longest_rivalry = max(_persistent_two_sided.items(), key=lambda x: x[1]) if _persistent_two_sided else None

    # Most polarizing (most mutual enemies today)
    enemy_count = Counter()
    for a, b in two_sided_today:
        enemy_count[a] += 1
        enemy_count[b] += 1
    most_polarizing = enemy_count.most_common(1)[0] if enemy_count else None

    # Build callout
    facts = [
        f"**{n_mutual}** rivalidades m√∫tuas",
        f"**{n_one_sided}** pontos cegos (hostilidade unilateral)"
    ]

    detail_facts = []
    if longest_rivalry:
        pair_names = sorted(longest_rivalry[0])
        detail_facts.append(f"‚Ä¢ Rivalidade mais longa: **{pair_names[0]} vs {pair_names[1]}** ({longest_rivalry[1]} dias)")
    if most_polarizing:
        detail_facts.append(f"‚Ä¢ Mais polarizante: **{most_polarizing[0]}** ({most_polarizing[1]} inimigos m√∫tuos)")

    print(f"""
::: {{.callout-note title="Fatos R√°pidos" appearance="simple"}}
{' | '.join(facts)}

{"<br>".join(detail_facts)}
:::
""")
else:
    print("")
```

### Grafo de Rela√ß√µes {#grafo}

<p class="text-muted small">üì∏ <strong>Dado do dia</strong> ‚Äî mostra apenas a coleta mais recente.</p>

Rede mostrando alian√ßas (‚ù§Ô∏è m√∫tuo = verde) e rivalidades (negativa m√∫tua = vermelho) na √∫ltima coleta.

```{python}
#| label: network-graph

import networkx as nx

G = nx.Graph()

active_names_net = [p['name'] for p in latest['participants']
                     if not p.get('characteristics', {}).get('eliminated')]

for name in active_names_net:
    member_of = MEMBER_OF.get(name, '?')
    G.add_node(name, group=member_of)

# Adicionar arestas de alian√ßa e rivalidade
checked = set()
for (giver, receiver), label in latest_matrix.items():
    pair = tuple(sorted([giver, receiver]))
    if pair in checked:
        continue
    checked.add(pair)

    reverse = latest_matrix.get((receiver, giver))
    if label == 'Cora√ß√£o' and reverse == 'Cora√ß√£o':
        G.add_edge(giver, receiver, weight=1, color='green', relation='alliance')
    elif label not in POSITIVE and reverse is not None and reverse not in POSITIVE:
        G.add_edge(giver, receiver, weight=1, color='red', relation='rivalry')

pos = nx.spring_layout(G, k=2.5, iterations=80, seed=42)

# Separar arestas por tipo
edge_traces = []
for edge_type, color, dash in [('alliance', '#2ca02c', 'solid'), ('rivalry', '#d62728', 'dash')]:
    edge_x, edge_y = [], []
    for u, v, data in G.edges(data=True):
        if data.get('relation') != edge_type:
            continue
        x0, y0 = pos[u]
        x1, y1 = pos[v]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])

    edge_traces.append(go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=1.5, color=color, dash=dash),
        hoverinfo='none',
        mode='lines',
        name='Alian√ßa (‚ù§Ô∏è m√∫tuo)' if edge_type == 'alliance' else 'Rivalidade (neg. m√∫tua)',
        showlegend=True
    ))

# N√≥s
node_x = [pos[n][0] for n in G.nodes()]
node_y = [pos[n][1] for n in G.nodes()]
node_colors = [GROUP_COLORS.get(G.nodes[n].get('group', '?'), '#999') for n in G.nodes()]
node_text = list(G.nodes())

# Score de sentimento para tamanho
sent_scores = {}
for p in latest['participants']:
    if not p.get('characteristics', {}).get('eliminated'):
        sent_scores[p['name']] = calc_sentiment(p)

node_sizes = [max(10, min(35, 15 + sent_scores.get(n, 0))) for n in G.nodes()]

node_trace = go.Scatter(
    x=node_x, y=node_y,
    mode='markers+text',
    text=[n.split()[0] for n in node_text],
    textposition='top center',
    textfont=dict(size=9),
    marker=dict(size=node_sizes, color=node_colors, line=dict(width=1, color='white')),
    hovertemplate='%{hovertext}<extra></extra>',
    hovertext=[f"{n}<br>Grupo: {G.nodes[n].get('group','?')}<br>Sentimento: {sent_scores.get(n,0):+.1f}" for n in G.nodes()],
    showlegend=False
)

fig = go.Figure(data=edge_traces + [node_trace])

fig.update_layout(
    title=f"Grafo de Rela√ß√µes ‚Äî {latest['label']}",
        height=650,
    showlegend=True,
    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    annotations=[
        dict(text="Tamanho do n√≥ = sentimento | Cor = grupo (üî¥ Camarote, üü¢ Veterano, üîµ Pipoca)",
             xref="paper", yref="paper", x=0.5, y=-0.05, showarrow=False, font=dict(size=11))
    ]
)

fig.show()
```

### Hostilidades do Dia {#hostilidades-dia}

<p class="text-muted small">üì∏ <strong>Dado do dia</strong> ‚Äî mostra apenas a coleta mais recente.</p>

An√°lise de hostilidades **unilaterais** (A detesta B, mas B d√° ‚ù§Ô∏è para A) e **m√∫tuas** (ambos se detestam).
Esses padr√µes revelam din√¢micas importantes do jogo: hostilidades unilaterais criam **pontos cegos** ‚Äî
quem d√° cora√ß√µes a inimigos pode ser surpreendido na vota√ß√£o.

```{python}
#| label: hostility-analysis-today
#| output: asis

def analyze_hostility_patterns(matrix, active_names):
    """Analyze one-sided and two-sided hostility patterns."""
    one_sided = []   # (hostile, friendly, hostile_rxn)
    two_sided = []   # (a, b, rxn_ab, rxn_ba)
    hostile_giver = Counter()   # Who gives hostility while receiving love
    loving_victim = Counter()   # Who gives love while receiving hostility
    two_sided_count = Counter() # Who is in mutual hostility

    checked_pairs = set()

    for (a, b), rxn_a_to_b in matrix.items():
        if a not in active_names or b not in active_names:
            continue

        rxn_b_to_a = matrix.get((b, a), '')
        a_dislikes_b = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
        b_dislikes_a = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''
        a_likes_b = rxn_a_to_b in POSITIVE
        b_likes_a = rxn_b_to_a in POSITIVE

        pair = frozenset([a, b])

        if a_dislikes_b and b_dislikes_a:
            if pair not in checked_pairs:
                two_sided.append((a, b, rxn_a_to_b, rxn_b_to_a))
                two_sided_count[a] += 1
                two_sided_count[b] += 1
                checked_pairs.add(pair)
        elif a_dislikes_b and b_likes_a:
            one_sided.append((a, b, rxn_a_to_b))
            hostile_giver[a] += 1
            loving_victim[b] += 1

    return {
        'one_sided': one_sided,
        'two_sided': two_sided,
        'hostile_giver': hostile_giver,
        'loving_victim': loving_victim,
        'two_sided_count': two_sided_count,
    }

# Analyze latest snapshot
active_for_hostility = set(p['name'] for p in latest['participants']
                           if not p.get('characteristics', {}).get('eliminated'))
hostility = analyze_hostility_patterns(latest_matrix, active_for_hostility)

n_one = len(hostility['one_sided'])
n_two = len(hostility['two_sided'])

summary_lines = [
    f"**üìä Resumo das Hostilidades ‚Äî {latest['label']}**",
    "",
    f"**{n_two}** hostilidades m√∫tuas (ambos se detestam) | **{n_one}** hostilidades unilaterais (A detesta B, mas B d√° ‚ù§Ô∏è)",
    "",
    "**Por que isso importa?**",
    "- **Hostilidade m√∫tua** = inimigos declarados. Votos previs√≠veis, sem surpresas.",
    "- **Hostilidade unilateral** = *ponto cego*. Quem d√° ‚ù§Ô∏è a um inimigo pode ser tra√≠do na vota√ß√£o.",
]

print("\n".join(summary_lines))
```

#### Quem Mais Ataca Quem Lhe D√° Cora√ß√£o

```{python}
#| label: hostility-daily-attackers
#| output: asis

print("Participantes que d√£o mais rea√ß√µes negativas para pessoas que lhes d√£o cora√ß√µes.\n")

if hostility['hostile_giver']:
    top_hostile = hostility['hostile_giver'].most_common(10)
    hostile_data = []
    for name, count in top_hostile:
        grupo = MEMBER_OF.get(name, '?')
        hostile_data.append({'Participante': name, 'Grupo': grupo, 'Ataques a Amigos': count})

    df_hostile = pd.DataFrame(hostile_data)

    fig = go.Figure(go.Bar(
        y=[d['Participante'] for d in hostile_data],
        x=[d['Ataques a Amigos'] for d in hostile_data],
        orientation='h',
        marker_color=[GROUP_COLORS.get(d['Grupo'], '#666') for d in hostile_data],
        text=[d['Ataques a Amigos'] for d in hostile_data],
        textposition='outside',
        hovertemplate='%{y}: %{x} ataques a quem lhe deu ‚ù§Ô∏è<extra></extra>',
    ))

    fig.update_layout(
        title="Quem Mais Ataca Quem Lhe D√° ‚ù§Ô∏è (Hostilidade Unilateral)",
        xaxis_title="N¬∫ de pessoas que d√£o ‚ù§Ô∏è mas recebem negativa",
        yaxis_title="",
        height=max(350, len(hostile_data) * 35),
        margin=dict(l=150),
    )

    fig.show()
else:
    print("*Nenhuma hostilidade unilateral detectada.*")
```

#### Quem Mais D√° Cora√ß√£o a Inimigos

```{python}
#| label: hostility-victims-today
#| output: asis

print("Participantes que d√£o cora√ß√µes para pessoas que os detestam ‚Äî *pontos cegos* no jogo.\n")

if hostility['loving_victim']:
    top_victims = hostility['loving_victim'].most_common(10)
    victim_data = []
    for name, count in top_victims:
        grupo = MEMBER_OF.get(name, '?')
        # Calculate vulnerability ratio
        given_hostility = hostility['hostile_giver'].get(name, 0)
        ratio = count / (given_hostility + 1)
        victim_data.append({
            'Participante': name, 'Grupo': grupo,
            '‚ù§Ô∏è a Inimigos': count, 'Ataca Amigos': given_hostility,
            'Vulnerabilidade': ratio
        })

    df_victims = pd.DataFrame(victim_data)

    fig = go.Figure(go.Bar(
        y=[d['Participante'] for d in victim_data],
        x=[d['‚ù§Ô∏è a Inimigos'] for d in victim_data],
        orientation='h',
        marker_color=[GROUP_COLORS.get(d['Grupo'], '#666') for d in victim_data],
        text=[f"{d['‚ù§Ô∏è a Inimigos']} (vuln: {d['Vulnerabilidade']:.1f})" for d in victim_data],
        textposition='outside',
        hovertemplate='%{y}: d√° ‚ù§Ô∏è para %{x} pessoas que o detestam<extra></extra>',
    ))

    fig.update_layout(
        title="Quem Mais D√° ‚ù§Ô∏è a Quem O Detesta (Pontos Cegos)",
        xaxis_title="N¬∫ de pessoas que recebem ‚ù§Ô∏è mas d√£o negativa",
        yaxis_title="",
        height=max(350, len(victim_data) * 35),
        margin=dict(l=150),
    )

    fig.show()

    # Highlight most vulnerable
    if victim_data:
        most_vulnerable = max(victim_data, key=lambda x: x['Vulnerabilidade'])
        if most_vulnerable['Vulnerabilidade'] > 2:
            print(f"\n> ‚ö†Ô∏è **Alerta de vulnerabilidade:** {most_vulnerable['Participante']} tem "
                  f"√≠ndice de vulnerabilidade {most_vulnerable['Vulnerabilidade']:.1f} ‚Äî "
                  f"d√° muitos ‚ù§Ô∏è a inimigos e pode ser surpreendido(a) em vota√ß√µes.")
else:
    print("*Nenhum participante com pontos cegos detectado.*")
```

#### Quem Tem Mais Inimigos Declarados

```{python}
#| label: hostility-mutual-enemies-today
#| output: asis

print("Participantes com mais hostilidades m√∫tuas (ambos se detestam).\n")

if hostility['two_sided_count']:
    top_enemies = hostility['two_sided_count'].most_common(10)
    enemy_data = []
    for name, count in top_enemies:
        grupo = MEMBER_OF.get(name, '?')
        enemy_data.append({'Participante': name, 'Grupo': grupo, 'Inimigos M√∫tuos': count})

    df_enemies = pd.DataFrame(enemy_data)

    fig = go.Figure(go.Bar(
        y=[d['Participante'] for d in enemy_data],
        x=[d['Inimigos M√∫tuos'] for d in enemy_data],
        orientation='h',
        marker_color=[GROUP_COLORS.get(d['Grupo'], '#666') for d in enemy_data],
        text=[d['Inimigos M√∫tuos'] for d in enemy_data],
        textposition='outside',
        hovertemplate='%{y}: %{x} inimigos declarados<extra></extra>',
    ))

    fig.update_layout(
        title="Quem Tem Mais Inimigos Declarados (Hostilidade M√∫tua)",
        xaxis_title="N¬∫ de inimigos m√∫tuos",
        yaxis_title="",
        height=max(350, len(enemy_data) * 35),
        margin=dict(l=150),
    )

    fig.show()
else:
    print("*Nenhuma hostilidade m√∫tua detectada.*")
```

#### Insights do Jogo

```{python}
#| label: hostility-insights-today
#| output: asis

# Find the most vulnerable participants
if hostility['loving_victim']:
    most_vulnerable = sorted(
        [(name, hostility['loving_victim'][name],
          hostility['hostile_giver'].get(name, 0))
         for name in hostility['loving_victim']],
        key=lambda x: x[1] / (x[2] + 1),
        reverse=True
    )[:3]

    print("**Pontos Cegos** ‚Äî Participantes que d√£o muitos ‚ù§Ô∏è a quem os detesta (maior risco de serem tra√≠dos em vota√ß√µes):\n")
    for name, received, given in most_vulnerable:
        ratio = received / (given + 1)
        print(f"- **{name}**: d√° ‚ù§Ô∏è para {received} inimigos, ataca {given} amigos ‚Üí vulnerabilidade {ratio:.1f}")
    print()

# Find most polarizing participants
if hostility['two_sided_count']:
    most_enemies = hostility['two_sided_count'].most_common(3)
    print("**Participantes Mais Polarizantes** ‚Äî Quem tem mais inimigos declarados (hostilidade m√∫tua):\n")
    for name, count in most_enemies:
        print(f"- **{name}**: {count} inimigos m√∫tuos")
    print()

# Connection to voting
print("""
**Relev√¢ncia para Vota√ß√µes:**

- **Hostilidade m√∫tua** ‚Üí votos previs√≠veis entre inimigos declarados
- **Hostilidade unilateral** ‚Üí votos surpresa (quem d√° ‚ù§Ô∏è pode ser tra√≠do)
- Participantes com alta vulnerabilidade t√™m **pontos cegos** ‚Äî confiam em quem n√£o deviam
- No 1¬∫ Pared√£o, Paulo Augusto foi votado por 11 pessoas, **6 das quais lhe davam ‚ù§Ô∏è** ‚Äî exemplo cl√°ssico de ponto cego
""")
```

::: {.callout-tip}
## An√°lise de Clusters

A an√°lise de clusters (agrupamento por afinidade) foi movida para uma [p√°gina experimental dedicada](clusters.html).

**O que voc√™ encontra l√°:**

- Avalia√ß√£o autom√°tica do n√∫mero ideal de clusters (silhouette score)
- Grupos identificados e sua composi√ß√£o
- Din√¢mica entre clusters (tens√µes e afinidades)
- Mapa de afinidade (heatmap ordenado por cluster)

[üß™ Ver an√°lise de clusters ‚Üí](clusters.html)
:::

### Quem D√° Mais Negatividade? {#emissores}

<p class="text-muted small">üì∏ <strong>Dado do dia</strong> ‚Äî mostra apenas a coleta mais recente.</p>

Ranking de quem distribui mais rea√ß√µes negativas.

```{python}
#| label: negative-givers

def make_negative_givers_chart(participants, matrix, title_suffix=""):
    """Retorna go.Figure com perfil de emiss√£o de rea√ß√µes (‚ù§Ô∏è vs negativos)."""
    active_ns = sorted([p['name'] for p in participants
                        if not p.get('characteristics', {}).get('eliminated')])

    giver_data = []
    for name in active_ns:
        pos_given = 0
        neg_given = 0
        for receiver in active_ns:
            if name == receiver:
                continue
            rxn = matrix.get((name, receiver), '')
            if rxn in POSITIVE:
                pos_given += 1
            elif rxn:
                neg_given += 1

        total = pos_given + neg_given
        neg_pct = (neg_given / total * 100) if total > 0 else 0

        giver_data.append({
            'Participante': name,
            '‚ù§Ô∏è dados': pos_given,
            'Negativos dados': neg_given,
            '% Negativo': round(neg_pct, 1),
            'Grupo': MEMBER_OF.get(name, '?')
        })

    df_givers = pd.DataFrame(giver_data).sort_values('% Negativo', ascending=True)

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=df_givers['Participante'],
        x=df_givers['‚ù§Ô∏è dados'],
        name='‚ù§Ô∏è dados',
        orientation='h',
        marker_color='#1a9850'
    ))
    fig.add_trace(go.Bar(
        y=df_givers['Participante'],
        x=df_givers['Negativos dados'],
        name='Negativos dados',
        orientation='h',
        marker_color='#d73027'
    ))

    title = "Perfil de Emiss√£o: Quem D√° Mais ‚ù§Ô∏è vs Negatividade?"
    if title_suffix:
        title += f" ‚Äî {title_suffix}"

    fig.update_layout(
        title=title,
        xaxis_title="Quantidade de rea√ß√µes dadas",
        yaxis_title="",
        barmode='stack',
        height=max(500, len(df_givers) * 25),
        margin=dict(l=150)
    )

    return fig

fig = make_negative_givers_chart(latest['participants'], latest_matrix)
fig.show()
```

### Destaques {#destaques-conflitos}

```{python}
#| label: destaques-conflitos
#| output: asis

if len(daily_snapshots) >= 2:
    # Get current hostility data
    _active = set(p['name'] for p in latest['participants']
                  if not p.get('characteristics', {}).get('eliminated'))

    _two_sided = []
    _one_sided = []
    _blind_spots = []  # (victim, attacker) - victim gives ‚ù§Ô∏è to attacker who hates them
    checked = set()

    for (a, b), rxn_a_to_b in latest_matrix.items():
        if a not in _active or b not in _active:
            continue

        rxn_b_to_a = latest_matrix.get((b, a), '')
        a_dislikes = rxn_a_to_b not in POSITIVE and rxn_a_to_b != ''
        b_dislikes = rxn_b_to_a not in POSITIVE and rxn_b_to_a != ''
        b_likes = rxn_b_to_a in POSITIVE

        pair = frozenset([a, b])
        if a_dislikes and b_dislikes and pair not in checked:
            _two_sided.append((a, b))
            checked.add(pair)
        elif a_dislikes and b_likes:
            _one_sided.append((a, b, rxn_a_to_b))
            _blind_spots.append((b, a))  # b is the victim (gives ‚ù§Ô∏è, receives hate)

    # Count blind spots per victim
    _victim_count = Counter(v for v, _ in _blind_spots)
    most_blind = _victim_count.most_common(1)[0] if _victim_count else None

    # Get historical persistence for rivalries
    _rivalry_days = defaultdict(int)
    for idx, matrix in enumerate(daily_matrices):
        snap = daily_snapshots[idx]
        active_set = set(p['name'] for p in snap['participants']
                         if not p.get('characteristics', {}).get('eliminated'))
        checked_hist = set()

        for (a, b), rxn in matrix.items():
            if a not in active_set or b not in active_set:
                continue
            rxn_rev = matrix.get((b, a), '')
            a_neg = rxn not in POSITIVE and rxn != ''
            b_neg = rxn_rev not in POSITIVE and rxn_rev != ''

            pair = frozenset([a, b])
            if a_neg and b_neg and pair not in checked_hist:
                _rivalry_days[pair] += 1
                checked_hist.add(pair)

    longest_rivalry = max(_rivalry_days.items(), key=lambda x: x[1]) if _rivalry_days else None

    # Build narrative
    sections = []

    # Critical blind spot story
    if most_blind and most_blind[1] >= 2:
        victim = most_blind[0]
        count = most_blind[1]
        grupo = MEMBER_OF.get(victim, '?')
        # Find who attacks them
        attackers = [a for v, a in _blind_spots if v == victim]
        attacker_list = ', '.join(attackers[:3])
        sections.append(f"**‚ö†Ô∏è Maior Ponto Cego:** **{victim}** ({grupo}) d√° ‚ù§Ô∏è para **{count} pessoas** que o(a) detestam "
                       f"({attacker_list}). Em uma vota√ß√£o, pode receber votos surpresa de quem considera aliado.")

    # Longest rivalry
    if longest_rivalry:
        a, b = sorted(longest_rivalry[0])
        days = longest_rivalry[1]
        pct = days / n_daily * 100
        if pct >= 80:
            sections.append(f"**üî• Rivalidade Estrutural:** **{a}** vs **{b}** se detestam h√° **{days} dias** ({pct:.0f}% do jogo). "
                           f"Este conflito parece ser central na din√¢mica da casa.")
        elif pct >= 50:
            sections.append(f"**‚öîÔ∏è Rivalidade Persistente:** **{a}** vs **{b}** mant√™m hostilidade m√∫tua h√° **{days} dias**. "
                           f"Uma tens√£o que pode explodir em vota√ß√£o.")

    # Voting prediction insight
    if _one_sided and len(_one_sided) >= 3:
        n_blind = len(_one_sided)
        sections.append(f"**üó≥Ô∏è Previs√£o:** Com **{n_blind} pontos cegos** ativos, h√° risco de votos surpresa. "
                       f"Participantes que confiam em quem os detesta s√£o os mais vulner√°veis.")

    if sections:
        print("::: {.callout-tip title=\"Destaques\" appearance=\"simple\"}")
        print("<br>".join(sections))
        print(":::")
else:
    print("")
```

:::

---

<div class="alert alert-secondary">
<strong>Navega√ß√£o</strong>
<ul class="mb-0">
  <li><a href="index.html">üìä Painel</a> ‚Äî Estado atual das rea√ß√µes</li>
  <li><a href="mudancas.html">üìÖ O Que Mudou</a> ‚Äî Mudan√ßas do dia anterior</li>
  <li><a href="paredao.html">üó≥Ô∏è Pared√£o</a> ‚Äî Pared√£o atual</li>
  <li><a href="paredoes.html">üìö Arquivo</a> ‚Äî Hist√≥rico de pared√µes</li>
</ul>
</div>
