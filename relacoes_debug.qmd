---
title: "üß≠ Rela√ß√µes ‚Äî Debug"
subtitle: "Tally completo do score A‚ÜíB (querid√¥metro + eventos)"
---

```{python}
#| label: setup
#| message: false
#| warning: false

import json
from pathlib import Path
from collections import defaultdict
import pandas as pd
import sys

sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    require_clean_manual_events, get_all_snapshots, load_snapshot,
    build_reaction_matrix, REACTION_EMOJI, SENTIMENT_WEIGHTS, get_week_number,
    parse_roles, POSITIVE
)

require_clean_manual_events()

RELATIONS_FILE = Path("data/derived/relations_scores.json")

relations = json.loads(RELATIONS_FILE.read_text(encoding="utf-8")) if RELATIONS_FILE.exists() else {}
relations_pairs_daily = relations.get("pairs_daily", {}) or relations.get("pairs", {})
relations_pairs_all = relations.get("pairs_all", {})
contradictions = relations.get("contradictions", {})
received_impact = relations.get("received_impact", {})
voting_blocs = relations.get("voting_blocs", [])
streak_breaks = relations.get("streak_breaks", [])
edges = relations.get("edges", []) or relations.get("edges_daily", []) or relations.get("edges_paredao", [])
meta = relations.get("_metadata", {})
DISPLAY_WEEK_DAILY = meta.get("effective_week_daily") or meta.get("week") or 2
DISPLAY_WEEK_PAREDAO = meta.get("effective_week_paredao") or meta.get("week") or 2
reference_date_daily = meta.get("reference_date_daily") or meta.get("date")
reference_date_paredao = meta.get("reference_date_paredao") or meta.get("date")

snapshots = get_all_snapshots()
latest = snapshots[-1] if snapshots else None
participants = []
latest_date = None
matrix_daily = {}
matrix_paredao = {}
week_snapshot_daily = None
week_snapshot_paredao = None
week_date_daily = None
week_date_paredao = None
if snapshots:
    if reference_date_daily:
        for fp, date in snapshots:
            if date <= reference_date_daily:
                week_snapshot_daily = (fp, date)
    if not week_snapshot_daily:
        for fp, date in snapshots:
            if get_week_number(date) == DISPLAY_WEEK_DAILY:
                week_snapshot_daily = (fp, date)
    if not week_snapshot_daily:
        week_snapshot_daily = latest
    if reference_date_paredao:
        for fp, date in snapshots:
            if date <= reference_date_paredao:
                week_snapshot_paredao = (fp, date)
    if not week_snapshot_paredao:
        for fp, date in snapshots:
            if get_week_number(date) == DISPLAY_WEEK_PAREDAO:
                week_snapshot_paredao = (fp, date)
    if not week_snapshot_paredao:
        week_snapshot_paredao = latest
if week_snapshot_daily:
    week_fp, week_date_daily = week_snapshot_daily
    participants, _ = load_snapshot(week_fp)
    matrix_daily = build_reaction_matrix(participants)
if week_snapshot_paredao:
    week_fp, week_date_paredao = week_snapshot_paredao
    participants, _ = load_snapshot(week_fp)
    matrix_paredao = build_reaction_matrix(participants)


def reaction_label(actor, target, matrix):
    label = matrix.get((actor, target), "")
    emoji = REACTION_EMOJI.get(label, "") if label else ""
    return label, emoji


def classify_relation(score):
    if score >= 0.5:
        return "Amig√°vel", "rel-friend"
    if score <= -0.5:
        return "Hostil", "rel-hostile"
    return "Neutro", "rel-neutral"


def fmt_score(value):
    if value is None:
        return ""
    cls = "val-zero"
    if value > 0:
        cls = "val-pos"
    elif value < 0:
        cls = "val-neg"
    return f"<span class='{cls}'>{value:.2f}</span>"


def flatten_pairs(pairs, matrix):
    rows = []
    for actor, targets in pairs.items():
        for target, rec in targets.items():
            label, emoji = reaction_label(actor, target, matrix)
            comps = rec.get("components", rec.get("components_roll", {}))
            q_score = comps.get("queridometro", 0.0)
            score = rec.get("score", rec.get("roll", 0.0))
            rel_label, rel_class = classify_relation(score)
            s_len = rec.get("streak_len", 0)
            has_break = rec.get("break", False)
            rows.append({
                "Ator": actor,
                "Alvo": target,
                "Rela√ß√£o": f"<span class='rel-pill {rel_class}'>{rel_label}</span>",
                "Emoji (dia)": f"{emoji} {label}".strip(),
                "Q (3d)": fmt_score(q_score),
                "Streak": f"{'üíî ' if has_break else ''}{s_len}d",
                "Power": fmt_score(comps.get("power_event", 0.0)),
                "Sincer√£o": fmt_score(comps.get("sincerao", 0.0)),
                "VIP": fmt_score(comps.get("vip", 0.0)),
                "Voto": fmt_score(comps.get("vote", 0.0)),
                "Score": fmt_score(score),
            })
    return pd.DataFrame(rows)

pairs_daily_df = flatten_pairs(relations_pairs_daily, matrix_daily) if relations_pairs_daily else pd.DataFrame()

edge_rows = []
for ev in edges:
    weight = ev.get("weight", ev.get("weight_roll"))
    edge_rows.append({
        "Data": ev.get("date", ""),
        "Semana": ev.get("week", ""),
        "Tipo": ev.get("type", ""),
        "Evento": ev.get("event_type") or ev.get("sinc_type") or "",
        "Tema": ev.get("tema") or "",
        "Slot": ev.get("slot") or "",
        "Ator": ev.get("actor", ""),
        "Alvo": ev.get("target", ""),
        "Visibilidade": ev.get("visibility") or "",
        "Backlash": "sim" if ev.get("backlash") else "",
        "Voto (tipo)": ev.get("vote_kind") or "",
        "Revelado": "sim" if ev.get("revealed") else "n√£o",
        "Peso": fmt_score(weight) if weight is not None else "",
    })

edges_df = pd.DataFrame(edge_rows)

event_rows = []
for ev in edges:
    if ev.get("week") != DISPLAY_WEEK_PAREDAO:
        continue
    if ev.get("type") == "power_event" and ev.get("event_type") not in {"indicacao", "contragolpe"}:
        continue
    if ev.get("type") != "power_event" and ev.get("type") != "vote":
        continue
    actor = ev.get("actor")
    target = ev.get("target")
    label, emoji = reaction_label(actor, target, matrix_paredao)
    event_rows.append({
        "Data": ev.get("date"),
        "Tipo": ev.get("type"),
        "Evento": ev.get("event_type"),
        "Ator": actor,
        "Alvo": target,
        "Querid√¥metro": f"{emoji} {label}".strip(),
        "Peso evento": fmt_score(ev.get("weight_raw") or 0),
        "Backlash": "sim" if ev.get("backlash") else "",
        "Voto (tipo)": ev.get("vote_kind"),
    })

events_vs_df = pd.DataFrame(event_rows)
```

## Pesos ativos

<style>
.rel-pill {
  display: inline-block;
  padding: 0.1rem 0.45rem;
  border-radius: 999px;
  font-size: 0.75rem;
  font-weight: 600;
  border: 1px solid rgba(255,255,255,0.2);
}
.rel-friend { background: rgba(40,167,69,0.18); color: #a8f0b3; border-color: rgba(40,167,69,0.5); }
.rel-neutral { background: rgba(108,117,125,0.18); color: #d0d0d0; border-color: rgba(108,117,125,0.5); }
.rel-hostile { background: rgba(220,53,69,0.18); color: #ffb3bb; border-color: rgba(220,53,69,0.55); }
.val-pos { color: #8ee4a4; font-weight: 600; }
.val-neg { color: #ff9aa2; font-weight: 600; }
.val-zero { color: #d0d0d0; }
</style>

```{python}
#| label: weights
#| echo: false
#| output: asis

if meta:
    print(f"<div><strong>Data (√∫ltimo sync):</strong> {meta.get('date')}</div>")
    if reference_date_daily:
        print(f"<div><strong>Querid√¥metro base (di√°rio):</strong> {reference_date_daily} (rolling 3d)</div>")
    if reference_date_paredao:
        print(f"<div><strong>Querid√¥metro base (pared√£o):</strong> {reference_date_paredao} (rolling 3d)</div>")
    print(f"<div><strong>Acumula√ß√£o:</strong> sem decay ‚Äî todos os eventos acumulam com peso integral</div>")
    print("<div style='margin-top:0.6rem;'><strong>Pesos (resumo)</strong></div>")
    print(f"<div>Querid√¥metro: {meta.get('weights', {}).get('queridometro')}</div>")
    print(f"<div>Power events: {meta.get('weights', {}).get('power_events')}</div>")
    print(f"<div>Sincer√£o: {meta.get('weights', {}).get('sincerao')}</div>")
    print(f"<div>VIP: {meta.get('weights', {}).get('vip')}</div>")
    print(f"<div>Votos: {meta.get('weights', {}).get('votes')}</div>")
    print(f"<div>Visibilidade: {meta.get('weights', {}).get('visibility_factor')}</div>")
else:
    print("<div>Sem metadados dispon√≠veis.</div>")
```

## Pares (A ‚Üí B) ‚Äî vis√£o di√°ria

<p class="text-muted">Tabela di√°ria ‚Äî querid√¥metro usa 70% janela reativa (3d) + 30% mem√≥ria de sequ√™ncia + penalidade de ruptura. Eventos acumulam sem decay (peso integral). üíî = alian√ßa rompida.</p>

```{python}
#| label: pairs-table
#| echo: false
#| output: asis

if pairs_daily_df.empty:
    print("Nenhum par encontrado.")
else:
    pairs_daily_df = pairs_daily_df.sort_values(["Ator", "Score"], ascending=[True, False])
    print(pairs_daily_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="pairsTable"))
```

## Detalhes por participante

```{python}
#| label: pairs-by-actor
#| echo: false
#| output: asis

if pairs_daily_df.empty:
    print("Nenhum par encontrado.")
else:
    for actor in sorted(pairs_daily_df["Ator"].unique()):
        sub = pairs_daily_df[pairs_daily_df["Ator"] == actor].copy()
        sub = sub.sort_values("Score", ascending=False)
        print(f"<details style='margin: 0.4rem 0;'><summary><strong>{actor}</strong></summary>")
        print(sub.to_html(index=False, classes="table table-sm table-dark", escape=False))
        print("</details>")
```

## Edges individuais (eventos e votos)

```{python}
#| label: edges-table
#| echo: false
#| output: asis

if edges_df.empty:
    print("Nenhum edge registrado.")
else:
    edges_df = edges_df.sort_values(["Semana", "Tipo", "Ator"], ascending=[False, True, True])
    print(edges_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="edgesTable"))
```

<script>
(function() {
  function sortTable(table, colIndex, asc) {
    const tbody = table.tBodies[0];
    if (!tbody) return;
    const rows = Array.from(tbody.rows);
    rows.sort((a, b) => {
      const textA = (a.cells[colIndex] || {}).innerText || '';
      const textB = (b.cells[colIndex] || {}).innerText || '';
      const numA = parseFloat(textA.replace(',', '.').replace('%', '').trim());
      const numB = parseFloat(textB.replace(',', '.').replace('%', '').trim());
      const bothNumeric = !isNaN(numA) && !isNaN(numB) && textA.trim() !== '' && textB.trim() !== '';
      if (bothNumeric) {
        return asc ? (numA - numB) : (numB - numA);
      }
      const cmp = textA.localeCompare(textB, 'pt-BR', {sensitivity: 'base'});
      return asc ? cmp : -cmp;
    });
    rows.forEach(r => tbody.appendChild(r));
  }

  function initSortableHeaders() {
    document.querySelectorAll('table.table-dark').forEach(table => {
      const headers = table.querySelectorAll('thead th');
      headers.forEach((th, idx) => {
        th.style.cursor = 'pointer';
        th.style.userSelect = 'none';
        th.title = 'Clique para ordenar';
        th.dataset.sortDir = 'none';
        th.addEventListener('click', () => {
          // Toggle direction: none ‚Üí desc ‚Üí asc ‚Üí desc ‚Ä¶
          const dir = th.dataset.sortDir === 'desc' ? 'asc' : 'desc';
          // Reset all headers in this table
          headers.forEach(h => {
            h.dataset.sortDir = 'none';
            h.textContent = h.textContent.replace(/ [‚Üë‚Üì]$/, '');
          });
          th.dataset.sortDir = dir;
          th.textContent = th.textContent + (dir === 'asc' ? ' ‚Üë' : ' ‚Üì');
          sortTable(table, idx, dir === 'asc');
        });
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSortableHeaders);
  } else {
    initSortableHeaders();
  }
})();
</script>

## Votos / Indica√ß√µes vs Querid√¥metro (semana exibida)

```{python}
#| label: events-vs-querido
#| echo: false
#| output: asis

if events_vs_df.empty:
    print("Nenhum evento/voto cr√≠tico registrado na semana.")
else:
    events_vs_df = events_vs_df.sort_values(["Tipo", "Ator"], ascending=[True, True])
    print(events_vs_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="eventsTable"))
```
## Pares eliminados (pairs_all)

<p class="text-muted">Pares envolvendo participantes eliminados/desistentes. Q_base usa √∫ltimo snapshot antes da sa√≠da.</p>

```{python}
#| label: pairs-eliminated
#| echo: false
#| output: asis

if relations_pairs_all:
    elim_rows = []
    for actor, targets in relations_pairs_all.items():
        for target, rec in targets.items():
            if rec.get("active_pair", True):
                continue
            comps = rec.get("components", {})
            q_score = comps.get("queridometro", 0.0)
            score = rec.get("score", 0.0)
            rel_label, rel_class = classify_relation(score)
            elim_rows.append({
                "Ator": actor,
                "Alvo": target,
                "Rela√ß√£o": f"<span class='rel-pill {rel_class}'>{rel_label}</span>",
                "Q (3d)": fmt_score(q_score),
                "Power": fmt_score(comps.get("power_event", 0.0)),
                "Sincer√£o": fmt_score(comps.get("sincerao", 0.0)),
                "VIP": fmt_score(comps.get("vip", 0.0)),
                "Voto": fmt_score(comps.get("vote", 0.0)),
                "Score": fmt_score(score),
            })
    if elim_rows:
        elim_df = pd.DataFrame(elim_rows).sort_values(["Score"], ascending=[True])
        print(f"<div class='text-muted'>{len(elim_rows)} pares com pelo menos 1 participante eliminado/desistente</div>")
        print(elim_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="elimPairsTable"))
    else:
        print("<p class='text-muted'>Nenhum par com participantes eliminados encontrado.</p>")
else:
    print("<p class='text-muted'>pairs_all n√£o dispon√≠vel.</p>")
```

## Contradi√ß√µes (voto vs querid√¥metro)

<p class="text-muted">Casos em que A deu rea√ß√£o positiva (Q > 0) a B, mas votou para elimin√°-lo. Taxa de contradi√ß√£o reflete a dissocia√ß√£o entre emoji secreto e voto real.</p>

```{python}
#| label: contradictions
#| echo: false
#| output: asis

if contradictions:
    total = contradictions.get("total", 0)
    total_votes = contradictions.get("total_vote_edges", 0)
    rate = contradictions.get("rate", 0)
    print(f"<div><strong>Contradi√ß√µes:</strong> {total} de {total_votes} votos ({rate:.0%})</div>")

    ctx = contradictions.get("context_notes", {})
    if ctx.get("week_1"):
        print(f"<div class='text-muted' style='margin-top:0.3rem;font-size:0.85rem;'>‚ö†Ô∏è Semana 1: {ctx['week_1']}</div>")

    entries = contradictions.get("vote_vs_queridometro", [])
    if entries:
        rows = []
        for e in entries:
            rows.append({
                "Semana": e.get("week"),
                "Ator": e.get("actor"),
                "Alvo": e.get("target"),
                "Q (base)": fmt_score(e.get("queridometro", 0)),
                "Peso voto": fmt_score(e.get("vote_weight", 0)),
                "Tipo voto": e.get("vote_kind", ""),
            })
        cdf = pd.DataFrame(rows).sort_values(["Semana", "Ator"])
        print(cdf.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="contradictionsTable"))
else:
    print("<p class='text-muted'>Sem dados de contradi√ß√£o.</p>")
```

## Impacto recebido (por participante)

<p class="text-muted">Total de peso de edges recebidas (incoming) por cada participante, incluindo eliminados.</p>

```{python}
#| label: received-impact
#| echo: false
#| output: asis

if received_impact:
    ri_rows = []
    for name, rec in sorted(received_impact.items(), key=lambda x: x[1].get("total", 0)):
        ri_rows.append({
            "Participante": name,
            "Positivo": fmt_score(rec.get("positive", 0)),
            "Negativo": fmt_score(rec.get("negative", 0)),
            "Total": fmt_score(rec.get("total", 0)),
            "Edges": rec.get("count", 0),
        })
    ri_df = pd.DataFrame(ri_rows)
    print(ri_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="receivedImpactTable"))
else:
    print("<p class='text-muted'>Sem dados de impacto recebido.</p>")
```

## Blocos de vota√ß√£o

<p class="text-muted">Semanas com 4+ participantes votando no mesmo alvo ‚Äî sinal de vota√ß√£o em bloco.</p>

```{python}
#| label: voting-blocs
#| echo: false
#| output: asis

if voting_blocs:
    for bloc in voting_blocs:
        voters = ", ".join(bloc.get("voters", []))
        print(f"<div style='margin:0.4rem 0;'><strong>Semana {bloc.get('week')}</strong> ‚Äî "
              f"<span class='val-neg'>{bloc.get('count')} votos</span> em <strong>{bloc.get('target')}</strong>"
              f"<br><span class='text-muted'>{voters}</span></div>")
else:
    print("<p class='text-muted'>Nenhum bloco de vota√ß√£o detectado (m√≠n. 4 votos no mesmo alvo).</p>")
```

## Rupturas de Alian√ßa (Streak Breaks)

<p class="text-muted">Sequ√™ncias de 5+ dias de ‚ù§Ô∏è que viraram negativo ‚Äî sinal de "confian√ßa quebrada".</p>

```{python}
#| label: streak-breaks
#| echo: false
#| output: asis

if streak_breaks:
    for b in streak_breaks:
        sev_icon = "üî¥" if b.get("severity") == "strong" else "üü°"
        emoji_label = b.get("new_emoji", "")
        print(
            f"<div style='margin:0.4rem 0;'>{sev_icon} <strong>{b['giver']}</strong> ‚Üí "
            f"<strong>{b['receiver']}</strong>: {b['previous_streak']}d ‚ù§Ô∏è ‚Üí {emoji_label} "
            f"<span class='text-muted'>({b.get('date', '')})</span></div>"
        )
else:
    print("<p class='text-muted'>Nenhuma ruptura de alian√ßa detectada (m√≠n. 5 dias de ‚ù§Ô∏è seguidos).</p>")
```

## Badge vs Realidade (Pared√µes)

```{python}
#| label: badge-vs-reality
#| echo: false
#| output: asis

import pandas as pd

def snapshot_on_or_before(date_str):
    chosen = None
    for fp, date in snapshots:
        if date <= date_str:
            chosen = (fp, date)
    return chosen

paredoes_data = json.loads(Path("data/paredoes.json").read_text(encoding="utf-8")) if Path("data/paredoes.json").exists() else {}

def compute_badges_for_snapshot(fp, date_str, vote_week, paredao_data):
    participants, _ = load_snapshot(fp)
    active = [p for p in participants if not p.get("characteristics", {}).get("eliminated")]
    active_names = [p["name"] for p in active]
    matrix = build_reaction_matrix(active)

    # roles current
    roles_current = {r: [] for r in ["L√≠der", "Anjo", "Monstro", "Imune", "Pared√£o"]}
    for p in active:
        name = p["name"]
        roles = parse_roles(p.get("characteristics", {}).get("roles", []))
        for r in roles:
            if r in roles_current:
                roles_current[r].append(name)

    # load power events
    manual = json.loads(Path("data/manual_events.json").read_text(encoding="utf-8"))
    auto = json.loads(Path("data/derived/auto_events.json").read_text(encoding="utf-8")).get("events", [])
    power_events = manual.get("power_events", []) + auto

    # votes received
    votes_received_by_week = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))
    for par in paredoes_data.get("paredoes", []) if paredoes_data else []:
        votos = par.get("votos_casa", {}) or {}
        if not votos:
            continue
        week = par.get("semana")
        for voter, target in votos.items():
            votes_received_by_week[week][target][voter] += 1

    # Impacto Negativo ‚Äî use received_impact from relations_scores.json
    relations_data = json.loads(Path("data/derived/relations_scores.json").read_text(encoding="utf-8")) if Path("data/derived/relations_scores.json").exists() else {}
    received_impact = relations_data.get("received_impact", {})

    def normalize_actors(ev):
        actors = ev.get("actors")
        if isinstance(actors, list) and actors:
            return [a for a in actors if a]
        actor = ev.get("actor")
        if not actor:
            return []
        if " + " in actor:
            return [a.strip() for a in actor.split(" + ") if a.strip()]
        return [actor]

    # Indica√ß√µes p√∫blicas (alvos j√° no pared√£o)
    ineligible = set()
    indicacoes = defaultdict(int)
    if paredao_data:
        form = paredao_data.get('formacao', {}) if isinstance(paredao_data.get('formacao'), dict) else {}
        indicado_lider = form.get('indicado_lider')
        if indicado_lider:
            ineligible.add(indicado_lider)
            indicacoes[indicado_lider] += 1
        bf = form.get('big_fone') or {}
        if isinstance(bf, dict) and bf.get('indicou'):
            ineligible.add(bf.get('indicou'))
            indicacoes[bf.get('indicou')] += 1
        cg = form.get('contragolpe') or {}
        if isinstance(cg, dict) and cg.get('para'):
            ineligible.add(cg.get('para'))
            indicacoes[cg.get('para')] += 1
        din = form.get('dinamica') or {}
        alvo = din.get('indicado')
        if alvo:
            ineligible.add(alvo)
            indicacoes[alvo] += 1
        im = form.get('imunizado') or {}
        if isinstance(im, dict) and im.get('quem'):
            ineligible.add(im.get('quem'))

    rows = []
    for p in active:
        name = p["name"]
        roles = parse_roles(p.get("characteristics", {}).get("roles", []))
        # Vulnerabilidade (false friends)
        ff = 0
        for b in active_names:
            if b == name:
                continue
            my = matrix.get((name, b))
            their = matrix.get((b, name))
            if my in POSITIVE and their and their not in POSITIVE:
                ff += 1
        if ff >= 5:
            vuln = "üî¥ MUITO VULNER√ÅVEL"
        elif ff >= 3:
            vuln = "üü† VULNER√ÅVEL"
        elif ff >= 1:
            vuln = "üü° ATEN√á√ÉO"
        else:
            vuln = "üü¢ PROTEGIDO"

        # External score (votes + events)
        votes_count = sum(votes_received_by_week.get(vote_week, {}).get(name, {}).values())
        indic_count = indicacoes.get(name, 0)

        # Impacto Negativo from relations_scores.json
        impact = received_impact.get(name, {})
        external_score = impact.get("negative", 0)

        if external_score <= -10:
            external_level = "üî¥ ALTO"
        elif external_score <= -5:
            external_level = "üü† M√âDIO"
        elif external_score < 0:
            external_level = "üü° BAIXO"
        else:
            external_level = "üü¢ NENHUM"

        rows.append({
            "Participante": name,
            "Votos (casa)": votes_count,
            "Indica√ß√µes": indic_count,
            "Eleg√≠vel voto": "sim" if name not in ineligible else "n√£o",
            "Vulnerabilidade": vuln,
            "Impacto Negativo": external_level,
            "Impact score": round(external_score, 2),
            "Falsos amigos": ff,
        })

    return pd.DataFrame(rows)

rows_all = []
for par in paredoes_data.get("paredoes", []) if paredoes_data else []:
    data_form = par.get("data_formacao") or par.get("data")
    week = par.get("semana")
    if not data_form or not week:
        continue
    snap = snapshot_on_or_before(data_form)
    if not snap:
        continue
    fp, date_str = snap
    df = compute_badges_for_snapshot(fp, date_str, week, par)
    df.insert(0, "Pared√£o", f"{par.get('numero')}¬∫ ({data_form})")
    rows_all.append(df)

if not rows_all:
    print("Sem dados de pared√£o para comparar.")
else:
    all_df = pd.concat(rows_all, ignore_index=True)
    print(all_df.to_html(index=False, classes="table table-sm table-dark", escape=False))

    # Contradi√ß√µes
    print("\n### Contradi√ß√µes (badge vs realidade)\n")
    vuln_no_votes = all_df[(all_df["Votos (casa)"] == 0) & (all_df["Indica√ß√µes"] == 0) & (all_df["Eleg√≠vel voto"] == "sim")]
    vuln_no_votes = vuln_no_votes[vuln_no_votes["Vulnerabilidade"].isin(["üü† VULNER√ÅVEL", "üî¥ MUITO VULNER√ÅVEL"])]
    if vuln_no_votes.empty:
        print("<p class='text-muted'>Nenhum vulner√°vel sem votos nesta forma√ß√£o.</p>")
    else:
        print("<p class='text-muted'>Vulner√°veis sem votos (surpresa n√£o se confirmou):</p>")
        print(vuln_no_votes[["Pared√£o", "Participante", "Vulnerabilidade", "Votos (casa)"]]
              .to_html(index=False, classes="table table-sm table-dark", escape=False))

    prot_with_votes = all_df[(all_df["Votos (casa)"] >= 3) & (all_df["Eleg√≠vel voto"] == "sim")]
    prot_with_votes = prot_with_votes[prot_with_votes["Vulnerabilidade"].isin(["üü¢ PROTEGIDO", "üü° ATEN√á√ÉO"])]
    if prot_with_votes.empty:
        print("<p class='text-muted'>Nenhum protegido/aten√ß√£o com muitos votos.</p>")
    else:
        print("<p class='text-muted'>Protegidos/aten√ß√£o com muitos votos (voto coletivo/bloco):</p>")
        print(prot_with_votes[["Pared√£o", "Participante", "Vulnerabilidade", "Votos (casa)"]]
              .to_html(index=False, classes="table table-sm table-dark", escape=False))
```
