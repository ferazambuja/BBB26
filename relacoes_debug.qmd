---
title: "üß≠ Rela√ß√µes ‚Äî Debug"
subtitle: "Tally completo do score A‚ÜíB (querid√¥metro + eventos)"
---

```{python}
#| label: setup
#| message: false
#| warning: false

import json
from pathlib import Path
from collections import defaultdict
import pandas as pd
import sys

sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    require_clean_manual_events, get_all_snapshots, load_snapshot,
    build_reaction_matrix, REACTION_EMOJI, SENTIMENT_WEIGHTS, get_week_number,
    parse_roles, POSITIVE, MILD_NEGATIVE, STRONG_NEGATIVE, POWER_EVENT_EMOJI
)

require_clean_manual_events()

RELATIONS_FILE = Path("data/derived/relations_scores.json")

relations = json.loads(RELATIONS_FILE.read_text(encoding="utf-8")) if RELATIONS_FILE.exists() else {}
relations_pairs_daily = relations.get("pairs_daily", {}) or relations.get("pairs", {})
relations_pairs_all = relations.get("pairs_all", {})
contradictions = relations.get("contradictions", {})
received_impact = relations.get("received_impact", {})
voting_blocs = relations.get("voting_blocs", [])
streak_breaks = relations.get("streak_breaks", [])
edges = relations.get("edges", []) or relations.get("edges_daily", []) or relations.get("edges_paredao", [])
meta = relations.get("_metadata", {})
DISPLAY_WEEK_DAILY = meta.get("effective_week_daily") or meta.get("week") or 2
DISPLAY_WEEK_PAREDAO = meta.get("effective_week_paredao") or meta.get("week") or 2
reference_date_daily = meta.get("reference_date_daily") or meta.get("date")
reference_date_paredao = meta.get("reference_date_paredao") or meta.get("date")

snapshots = get_all_snapshots()
latest = snapshots[-1] if snapshots else None
participants = []
latest_date = None
matrix_daily = {}
matrix_paredao = {}
week_snapshot_daily = None
week_snapshot_paredao = None
week_date_daily = None
week_date_paredao = None
if snapshots:
    if reference_date_daily:
        for fp, date in snapshots:
            if date <= reference_date_daily:
                week_snapshot_daily = (fp, date)
    if not week_snapshot_daily:
        for fp, date in snapshots:
            if get_week_number(date) == DISPLAY_WEEK_DAILY:
                week_snapshot_daily = (fp, date)
    if not week_snapshot_daily:
        week_snapshot_daily = latest
    if reference_date_paredao:
        for fp, date in snapshots:
            if date <= reference_date_paredao:
                week_snapshot_paredao = (fp, date)
    if not week_snapshot_paredao:
        for fp, date in snapshots:
            if get_week_number(date) == DISPLAY_WEEK_PAREDAO:
                week_snapshot_paredao = (fp, date)
    if not week_snapshot_paredao:
        week_snapshot_paredao = latest
if week_snapshot_daily:
    week_fp, week_date_daily = week_snapshot_daily
    participants, _ = load_snapshot(week_fp)
    matrix_daily = build_reaction_matrix(participants)
if week_snapshot_paredao:
    week_fp, week_date_paredao = week_snapshot_paredao
    participants, _ = load_snapshot(week_fp)
    matrix_paredao = build_reaction_matrix(participants)


def reaction_label(actor, target, matrix):
    label = matrix.get((actor, target), "")
    emoji = REACTION_EMOJI.get(label, "") if label else ""
    return label, emoji


def classify_relation(score):
    if score >= 0.5:
        return "Amig√°vel", "rel-friend"
    if score <= -0.5:
        return "Hostil", "rel-hostile"
    return "Neutro", "rel-neutral"


def fmt_score(value):
    if value is None:
        return ""
    cls = "val-zero"
    if value > 0:
        cls = "val-pos"
    elif value < 0:
        cls = "val-neg"
    return f"<span class='{cls}'>{value:.2f}</span>"


def flatten_pairs(pairs, matrix):
    rows = []
    for actor, targets in pairs.items():
        for target, rec in targets.items():
            label, emoji = reaction_label(actor, target, matrix)
            comps = rec.get("components", rec.get("components_roll", {}))
            q_score = comps.get("queridometro", 0.0)
            score = rec.get("score", rec.get("roll", 0.0))
            rel_label, rel_class = classify_relation(score)
            s_len = rec.get("streak_len", 0)
            has_break = rec.get("break", False)
            rows.append({
                "Ator": actor,
                "Alvo": target,
                "Rela√ß√£o": f"<span class='rel-pill {rel_class}'>{rel_label}</span>",
                "Emoji (dia)": f"{emoji} {label}".strip(),
                "Q (3d)": fmt_score(q_score),
                "Streak": f"{'üíî ' if has_break else ''}{s_len}d",
                "Power": fmt_score(comps.get("power_event", 0.0)),
                "Sincer√£o": fmt_score(comps.get("sincerao", 0.0)),
                "VIP": fmt_score(comps.get("vip", 0.0)),
                "Voto": fmt_score(comps.get("vote", 0.0)),
                "Score": fmt_score(score),
            })
    return pd.DataFrame(rows)

pairs_daily_df = flatten_pairs(relations_pairs_daily, matrix_daily) if relations_pairs_daily else pd.DataFrame()

edge_rows = []
for ev in edges:
    weight = ev.get("weight", ev.get("weight_roll"))
    edge_rows.append({
        "Data": ev.get("date", ""),
        "Semana": ev.get("week", ""),
        "Tipo": ev.get("type", ""),
        "Evento": ev.get("event_type") or ev.get("sinc_type") or "",
        "Tema": ev.get("tema") or "",
        "Slot": ev.get("slot") or "",
        "Ator": ev.get("actor", ""),
        "Alvo": ev.get("target", ""),
        "Visibilidade": ev.get("visibility") or "",
        "Backlash": "sim" if ev.get("backlash") else "",
        "Voto (tipo)": ev.get("vote_kind") or "",
        "Revelado": "sim" if ev.get("revealed") else "n√£o",
        "Peso": fmt_score(weight) if weight is not None else "",
    })

edges_df = pd.DataFrame(edge_rows)

event_rows = []
for ev in edges:
    if ev.get("week") != DISPLAY_WEEK_PAREDAO:
        continue
    if ev.get("type") == "power_event" and ev.get("event_type") not in {"indicacao", "contragolpe"}:
        continue
    if ev.get("type") != "power_event" and ev.get("type") != "vote":
        continue
    actor = ev.get("actor")
    target = ev.get("target")
    label, emoji = reaction_label(actor, target, matrix_paredao)
    event_rows.append({
        "Data": ev.get("date"),
        "Tipo": ev.get("type"),
        "Evento": ev.get("event_type"),
        "Ator": actor,
        "Alvo": target,
        "Querid√¥metro": f"{emoji} {label}".strip(),
        "Peso evento": fmt_score(ev.get("weight_raw") or 0),
        "Backlash": "sim" if ev.get("backlash") else "",
        "Voto (tipo)": ev.get("vote_kind"),
    })

events_vs_df = pd.DataFrame(event_rows)
```

## Pesos ativos

<style>
.rel-pill {
  display: inline-block;
  padding: 0.1rem 0.45rem;
  border-radius: 999px;
  font-size: 0.75rem;
  font-weight: 600;
  border: 1px solid rgba(255,255,255,0.2);
}
.rel-friend { background: rgba(40,167,69,0.18); color: #a8f0b3; border-color: rgba(40,167,69,0.5); }
.rel-neutral { background: rgba(108,117,125,0.18); color: #d0d0d0; border-color: rgba(108,117,125,0.5); }
.rel-hostile { background: rgba(220,53,69,0.18); color: #ffb3bb; border-color: rgba(220,53,69,0.55); }
.val-pos { color: #8ee4a4; font-weight: 600; }
.val-neg { color: #ff9aa2; font-weight: 600; }
.val-zero { color: #d0d0d0; }
</style>

```{python}
#| label: weights
#| echo: false
#| output: asis

if meta:
    print(f"<div><strong>Data (√∫ltimo sync):</strong> {meta.get('date')}</div>")
    if reference_date_daily:
        print(f"<div><strong>Querid√¥metro base (di√°rio):</strong> {reference_date_daily} (rolling 3d)</div>")
    if reference_date_paredao:
        print(f"<div><strong>Querid√¥metro base (pared√£o):</strong> {reference_date_paredao} (rolling 3d)</div>")
    print(f"<div><strong>Acumula√ß√£o:</strong> sem decay ‚Äî todos os eventos acumulam com peso integral</div>")
    print("<div style='margin-top:0.6rem;'><strong>Pesos (resumo)</strong></div>")
    print(f"<div>Querid√¥metro: {meta.get('weights', {}).get('queridometro')}</div>")
    print(f"<div>Power events: {meta.get('weights', {}).get('power_events')}</div>")
    print(f"<div>Sincer√£o: {meta.get('weights', {}).get('sincerao')}</div>")
    print(f"<div>VIP: {meta.get('weights', {}).get('vip')}</div>")
    print(f"<div>Votos: {meta.get('weights', {}).get('votes')}</div>")
    print(f"<div>Visibilidade: {meta.get('weights', {}).get('visibility_factor')}</div>")
else:
    print("<div>Sem metadados dispon√≠veis.</div>")
```

## Pares (A ‚Üí B) ‚Äî vis√£o di√°ria

<p class="text-muted">Tabela di√°ria ‚Äî querid√¥metro usa 70% janela reativa (3d) + 30% mem√≥ria de sequ√™ncia + penalidade de ruptura. Eventos acumulam sem decay (peso integral). üíî = alian√ßa rompida.</p>

```{python}
#| label: pairs-table
#| echo: false
#| output: asis

if pairs_daily_df.empty:
    print("Nenhum par encontrado.")
else:
    pairs_daily_df = pairs_daily_df.sort_values(["Ator", "Score"], ascending=[True, False])
    print(pairs_daily_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="pairsTable"))
```

## Detalhes por participante

```{python}
#| label: pairs-by-actor
#| echo: false
#| output: asis

if pairs_daily_df.empty:
    print("Nenhum par encontrado.")
else:
    for actor in sorted(pairs_daily_df["Ator"].unique()):
        sub = pairs_daily_df[pairs_daily_df["Ator"] == actor].copy()
        sub = sub.sort_values("Score", ascending=False)
        print(f"<details style='margin: 0.4rem 0;'><summary><strong>{actor}</strong></summary>")
        print(sub.to_html(index=False, classes="table table-sm table-dark", escape=False))
        print("</details>")
```

## Edges individuais (eventos e votos)

```{python}
#| label: edges-table
#| echo: false
#| output: asis

if edges_df.empty:
    print("Nenhum edge registrado.")
else:
    edges_df = edges_df.sort_values(["Semana", "Tipo", "Ator"], ascending=[False, True, True])
    print(edges_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="edgesTable"))
```

<script>
(function() {
  function sortTable(table, colIndex, asc) {
    const tbody = table.tBodies[0];
    if (!tbody) return;
    const rows = Array.from(tbody.rows);
    rows.sort((a, b) => {
      const textA = (a.cells[colIndex] || {}).innerText || '';
      const textB = (b.cells[colIndex] || {}).innerText || '';
      const numA = parseFloat(textA.replace(',', '.').replace('%', '').trim());
      const numB = parseFloat(textB.replace(',', '.').replace('%', '').trim());
      const bothNumeric = !isNaN(numA) && !isNaN(numB) && textA.trim() !== '' && textB.trim() !== '';
      if (bothNumeric) {
        return asc ? (numA - numB) : (numB - numA);
      }
      const cmp = textA.localeCompare(textB, 'pt-BR', {sensitivity: 'base'});
      return asc ? cmp : -cmp;
    });
    rows.forEach(r => tbody.appendChild(r));
  }

  function initSortableHeaders() {
    document.querySelectorAll('table.table-dark').forEach(table => {
      const headers = table.querySelectorAll('thead th');
      headers.forEach((th, idx) => {
        th.style.cursor = 'pointer';
        th.style.userSelect = 'none';
        th.title = 'Clique para ordenar';
        th.dataset.sortDir = 'none';
        th.addEventListener('click', () => {
          // Toggle direction: none ‚Üí desc ‚Üí asc ‚Üí desc ‚Ä¶
          const dir = th.dataset.sortDir === 'desc' ? 'asc' : 'desc';
          // Reset all headers in this table
          headers.forEach(h => {
            h.dataset.sortDir = 'none';
            h.textContent = h.textContent.replace(/ [‚Üë‚Üì]$/, '');
          });
          th.dataset.sortDir = dir;
          th.textContent = th.textContent + (dir === 'asc' ? ' ‚Üë' : ' ‚Üì');
          sortTable(table, idx, dir === 'asc');
        });
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSortableHeaders);
  } else {
    initSortableHeaders();
  }
})();
</script>

## Votos / Indica√ß√µes vs Querid√¥metro (semana exibida)

```{python}
#| label: events-vs-querido
#| echo: false
#| output: asis

if events_vs_df.empty:
    print("Nenhum evento/voto cr√≠tico registrado na semana.")
else:
    events_vs_df = events_vs_df.sort_values(["Tipo", "Ator"], ascending=[True, True])
    print(events_vs_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="eventsTable"))
```
## Pares eliminados (pairs_all)

<p class="text-muted">Pares envolvendo participantes eliminados/desistentes. Q_base usa √∫ltimo snapshot antes da sa√≠da.</p>

```{python}
#| label: pairs-eliminated
#| echo: false
#| output: asis

if relations_pairs_all:
    elim_rows = []
    for actor, targets in relations_pairs_all.items():
        for target, rec in targets.items():
            if rec.get("active_pair", True):
                continue
            comps = rec.get("components", {})
            q_score = comps.get("queridometro", 0.0)
            score = rec.get("score", 0.0)
            rel_label, rel_class = classify_relation(score)
            elim_rows.append({
                "Ator": actor,
                "Alvo": target,
                "Rela√ß√£o": f"<span class='rel-pill {rel_class}'>{rel_label}</span>",
                "Q (3d)": fmt_score(q_score),
                "Power": fmt_score(comps.get("power_event", 0.0)),
                "Sincer√£o": fmt_score(comps.get("sincerao", 0.0)),
                "VIP": fmt_score(comps.get("vip", 0.0)),
                "Voto": fmt_score(comps.get("vote", 0.0)),
                "Score": fmt_score(score),
            })
    if elim_rows:
        elim_df = pd.DataFrame(elim_rows).sort_values(["Score"], ascending=[True])
        print(f"<div class='text-muted'>{len(elim_rows)} pares com pelo menos 1 participante eliminado/desistente</div>")
        print(elim_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="elimPairsTable"))
    else:
        print("<p class='text-muted'>Nenhum par com participantes eliminados encontrado.</p>")
else:
    print("<p class='text-muted'>pairs_all n√£o dispon√≠vel.</p>")
```

## Contradi√ß√µes (voto vs querid√¥metro)

<p class="text-muted">Casos em que A deu rea√ß√£o positiva (Q > 0) a B, mas votou para elimin√°-lo. Taxa de contradi√ß√£o reflete a dissocia√ß√£o entre emoji secreto e voto real.</p>

```{python}
#| label: contradictions
#| echo: false
#| output: asis

if contradictions:
    total = contradictions.get("total", 0)
    total_votes = contradictions.get("total_vote_edges", 0)
    rate = contradictions.get("rate", 0)
    print(f"<div><strong>Contradi√ß√µes:</strong> {total} de {total_votes} votos ({rate:.0%})</div>")

    ctx = contradictions.get("context_notes", {})
    if ctx.get("week_1"):
        print(f"<div class='text-muted' style='margin-top:0.3rem;font-size:0.85rem;'>‚ö†Ô∏è Semana 1: {ctx['week_1']}</div>")

    entries = contradictions.get("vote_vs_queridometro", [])
    if entries:
        rows = []
        for e in entries:
            rows.append({
                "Semana": e.get("week"),
                "Ator": e.get("actor"),
                "Alvo": e.get("target"),
                "Q (base)": fmt_score(e.get("queridometro", 0)),
                "Peso voto": fmt_score(e.get("vote_weight", 0)),
                "Tipo voto": e.get("vote_kind", ""),
            })
        cdf = pd.DataFrame(rows).sort_values(["Semana", "Ator"])
        print(cdf.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="contradictionsTable"))
else:
    print("<p class='text-muted'>Sem dados de contradi√ß√£o.</p>")
```

## Impacto recebido (por participante)

<p class="text-muted">Total de peso de edges recebidas (incoming) por cada participante, incluindo eliminados.</p>

```{python}
#| label: received-impact
#| echo: false
#| output: asis

if received_impact:
    ri_rows = []
    for name, rec in sorted(received_impact.items(), key=lambda x: x[1].get("total", 0)):
        ri_rows.append({
            "Participante": name,
            "Positivo": fmt_score(rec.get("positive", 0)),
            "Negativo": fmt_score(rec.get("negative", 0)),
            "Total": fmt_score(rec.get("total", 0)),
            "Edges": rec.get("count", 0),
        })
    ri_df = pd.DataFrame(ri_rows)
    print(ri_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="receivedImpactTable"))
else:
    print("<p class='text-muted'>Sem dados de impacto recebido.</p>")
```

## Blocos de vota√ß√£o

<p class="text-muted">Semanas com 4+ participantes votando no mesmo alvo ‚Äî sinal de vota√ß√£o em bloco.</p>

```{python}
#| label: voting-blocs
#| echo: false
#| output: asis

if voting_blocs:
    for bloc in voting_blocs:
        voters = ", ".join(bloc.get("voters", []))
        print(f"<div style='margin:0.4rem 0;'><strong>Semana {bloc.get('week')}</strong> ‚Äî "
              f"<span class='val-neg'>{bloc.get('count')} votos</span> em <strong>{bloc.get('target')}</strong>"
              f"<br><span class='text-muted'>{voters}</span></div>")
else:
    print("<p class='text-muted'>Nenhum bloco de vota√ß√£o detectado (m√≠n. 4 votos no mesmo alvo).</p>")
```

## Rupturas de Alian√ßa (Streak Breaks)

<p class="text-muted">Sequ√™ncias de 5+ dias de ‚ù§Ô∏è que viraram negativo ‚Äî sinal de "confian√ßa quebrada".</p>

```{python}
#| label: streak-breaks
#| echo: false
#| output: asis

if streak_breaks:
    for b in streak_breaks:
        sev_icon = "üî¥" if b.get("severity") == "strong" else "üü°"
        emoji_label = b.get("new_emoji", "")
        print(
            f"<div style='margin:0.4rem 0;'>{sev_icon} <strong>{b['giver']}</strong> ‚Üí "
            f"<strong>{b['receiver']}</strong>: {b['previous_streak']}d ‚ù§Ô∏è ‚Üí {emoji_label} "
            f"<span class='text-muted'>({b.get('date', '')})</span></div>"
        )
else:
    print("<p class='text-muted'>Nenhuma ruptura de alian√ßa detectada (m√≠n. 5 dias de ‚ù§Ô∏è seguidos).</p>")
```

## Percep√ß√£o do Poder: L√≠der/Anjo

<p class="text-muted">Como a casa reage (no querid√¥metro secreto) quando algu√©m ganha L√≠der ou Anjo? Compara a m√©dia de ‚ù§Ô∏è e negativos recebidos antes, durante e depois de cada per√≠odo de poder.</p>

```{python}
#| label: power-perception
#| echo: false
#| output: asis

def get_daily_snapshot_map():
    """Group snapshots by date, keep last per day."""
    by_date = {}
    for fp, date in snapshots:
        by_date[date] = fp
    return by_date

def compute_reception_metrics(filepath, name):
    """Load snapshot, compute hearts/negatives received for one participant."""
    participants_list, _ = load_snapshot(filepath)
    p = next((p for p in participants_list if p.get("name") == name), None)
    if not p:
        return None
    hearts = 0
    negatives = 0
    total = 0
    for rxn in p.get("characteristics", {}).get("receivedReactions", []):
        label = rxn.get("label", "")
        amount = rxn.get("amount", 0) or 0
        total += amount
        if label in POSITIVE:
            hearts += amount
        elif label in MILD_NEGATIVE or label in STRONG_NEGATIVE:
            negatives += amount
    return {"hearts": hearts, "negatives": negatives, "total": total}

def avg_metrics(metrics_list):
    """Average a list of metric dicts."""
    valid = [m for m in metrics_list if m]
    if not valid:
        return None
    n = len(valid)
    return {
        "hearts": sum(m["hearts"] for m in valid) / n,
        "negatives": sum(m["negatives"] for m in valid) / n,
        "total": sum(m["total"] for m in valid) / n,
    }

def fmt_metrics(m):
    """Format metrics as HTML string."""
    if not m or m["total"] == 0:
        return "N/A"
    h_pct = m["hearts"] / m["total"] * 100
    n_pct = m["negatives"] / m["total"] * 100
    return f"‚ù§Ô∏è {m['hearts']:.0f} ({h_pct:.0f}%) ¬∑ üêç {m['negatives']:.0f} ({n_pct:.0f}%)"

def fmt_delta(before, during):
    """Format delta between two metric windows."""
    if not before or not during or before["total"] == 0 or during["total"] == 0:
        return "N/A"
    dh = during["hearts"] - before["hearts"]
    dn = during["negatives"] - before["negatives"]
    dh_pct = (during["hearts"]/during["total"] - before["hearts"]/before["total"]) * 100
    dn_pct = (during["negatives"]/during["total"] - before["negatives"]/before["total"]) * 100
    return f"{dh:+.0f} ‚ù§Ô∏è ({dh_pct:+.0f}pp)<br>{dn:+.0f} neg ({dn_pct:+.0f}pp)"

def detect_role_periods(role_name):
    """Parse roles_daily to find (name, start_date, end_date) periods."""
    roles_data = json.loads(Path("data/derived/roles_daily.json").read_text(encoding="utf-8"))
    periods = []
    current_holder = None
    current_start = None
    last_date = None
    for entry in roles_data["daily"]:
        date = entry["date"]
        holders = entry["roles"].get(role_name, [])
        holder = holders[0] if holders else None
        if holder != current_holder:
            if current_holder and current_start:
                periods.append((current_holder, current_start, last_date))
            current_holder = holder
            current_start = date if holder else None
        last_date = date
    if current_holder and current_start:
        periods.append((current_holder, current_start, last_date))
    return periods

daily_map = get_daily_snapshot_map()
all_dates = sorted(daily_map.keys())

rows_power = []
for role_name, role_label, role_emoji in [("L√≠der", "L√≠der", "üëë"), ("Anjo", "Anjo", "üòá")]:
    periods = detect_role_periods(role_name)
    for holder, start, end in periods:
        # Before: last 2 dates before start
        before_dates = [d for d in all_dates if d < start][-2:]
        # During: dates in [start, end]
        during_dates = [d for d in all_dates if start <= d <= end]
        # After: first 2 dates after end
        after_dates = [d for d in all_dates if d > end][:2]

        before_metrics = avg_metrics([compute_reception_metrics(daily_map[d], holder) for d in before_dates if d in daily_map])
        during_metrics = avg_metrics([compute_reception_metrics(daily_map[d], holder) for d in during_dates if d in daily_map])

        is_ongoing = (end == all_dates[-1]) if all_dates else False
        if is_ongoing:
            after_str = "<em>Em andamento</em>"
            delta_str = fmt_delta(before_metrics, during_metrics)
        else:
            after_metrics = avg_metrics([compute_reception_metrics(daily_map[d], holder) for d in after_dates if d in daily_map])
            after_str = fmt_metrics(after_metrics)
            delta_str = fmt_delta(before_metrics, during_metrics)

        n_days = len(during_dates)
        rows_power.append({
            "Poder": f"{role_emoji} {role_label}",
            "Participante": holder,
            "Per√≠odo": f"{start} ‚Üí {end}",
            "Dias": n_days,
            "Antes": fmt_metrics(before_metrics),
            "Durante": fmt_metrics(during_metrics),
            "Depois": after_str,
            "Œî Durante‚àíAntes": delta_str,
        })

if rows_power:
    power_df = pd.DataFrame(rows_power)
    print(power_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="powerPerceptionTable"))
else:
    print("<p class='text-muted'>Sem per√≠odos de L√≠der/Anjo detectados.</p>")
```

## Impacto Dirigido: Rea√ß√µes antes/depois de eventos

<p class="text-muted">Como o querid√¥metro muda entre ator‚Üîalvo antes e depois de eventos dirigidos (indica√ß√£o, contragolpe, monstro, veto, etc.)? Mostra a rea√ß√£o espec√≠fica que cada um dava ao outro.</p>

```{python}
#| label: directed-impact
#| echo: false
#| output: asis

# Load all directed events
manual_path = Path("data/manual_events.json")
auto_path = Path("data/derived/auto_events.json")

directed_events = []

# Manual power events
if manual_path.exists():
    manual = json.loads(manual_path.read_text(encoding="utf-8"))
    for ev in manual.get("power_events", []):
        etype = ev.get("type", "")
        actor = ev.get("actor", "")
        target = ev.get("target", "")
        # Skip non-directed, self-targeted, multi-actor, system actors
        if not actor or not target or actor == target:
            continue
        if " + " in actor:
            continue
        if ev.get("self") or ev.get("self_inflicted"):
            continue
        skip_types = {"ganha_ganha_escolha", "emparedado", "bate_volta"}
        if etype in skip_types:
            continue
        system_actors = {"Prova do L√≠der", "Big Fone", "Din√¢mica da casa", "Prova do Anjo", "Prova Bate e Volta"}
        if actor in system_actors:
            continue
        directed_events.append({
            "date": ev.get("date"),
            "type": etype,
            "actor": actor,
            "target": target,
            "source": ev.get("source", ""),
        })

# Auto events (monstro mainly ‚Äî lider/anjo have system actors)
if auto_path.exists():
    auto = json.loads(auto_path.read_text(encoding="utf-8"))
    for ev in auto.get("events", []):
        etype = ev.get("type", "")
        actor = ev.get("actor", "")
        target = ev.get("target", "")
        if not actor or not target or actor == target:
            continue
        system_actors = {"Prova do L√≠der", "Big Fone", "Din√¢mica da casa", "Prova do Anjo", "Prova Bate e Volta"}
        if actor in system_actors:
            continue
        if etype in {"monstro"}:
            directed_events.append({
                "date": ev.get("date"),
                "type": etype,
                "actor": actor,
                "target": target,
                "source": ev.get("source", ""),
            })

# Deduplicate by (date, type, actor, target)
seen = set()
unique_events = []
for ev in directed_events:
    key = (ev["date"], ev["type"], ev["actor"], ev["target"])
    if key not in seen:
        seen.add(key)
        unique_events.append(ev)
unique_events.sort(key=lambda e: (e["date"], e["type"]))

# Build reaction changes
rows_directed = []
for ev in unique_events:
    event_date = ev["date"]
    actor = ev["actor"]
    target = ev["target"]
    etype = ev["type"]
    emoji = POWER_EVENT_EMOJI.get(etype, "")

    # Before: last snapshot date strictly before event date
    before_dates = [d for d in all_dates if d < event_date]
    # After: first snapshot date >= event date
    after_dates = [d for d in all_dates if d >= event_date]

    before_date = before_dates[-1] if before_dates else None
    after_date = after_dates[0] if after_dates else None

    # If before == after (event on snapshot day), push before back one more
    if before_date and after_date and before_date == after_date:
        before_dates_strict = [d for d in all_dates if d < before_date]
        before_date = before_dates_strict[-1] if before_dates_strict else None

    def get_reaction_pair(date_key, a, b):
        if not date_key or date_key not in daily_map:
            return "‚Äî", "‚Äî"
        ps, _ = load_snapshot(daily_map[date_key])
        mat = build_reaction_matrix(ps)
        names_in = {p.get("name") for p in ps}
        ab_label = mat.get((a, b), "")
        ba_label = mat.get((b, a), "")
        ab_str = f"{REACTION_EMOJI.get(ab_label, '')} {ab_label}".strip() if ab_label else ("‚Äî" if a in names_in and b in names_in else "‚Äî <em>(saiu)</em>")
        ba_str = f"{REACTION_EMOJI.get(ba_label, '')} {ba_label}".strip() if ba_label else ("‚Äî" if a in names_in and b in names_in else "‚Äî <em>(saiu)</em>")
        return ab_str, ba_str

    ab_before, ba_before = get_reaction_pair(before_date, actor, target)
    ab_after, ba_after = get_reaction_pair(after_date, actor, target)

    # Flag notable changes
    def classify_reaction(label_str):
        if "Cora√ß√£o" in label_str and "partido" not in label_str:
            return "positive"
        if any(neg in label_str for neg in ["Cobra", "Alvo", "V√¥mito", "Mentiroso"]):
            return "strong_neg"
        if any(neg in label_str for neg in ["Planta", "Mala", "Biscoito", "partido"]):
            return "mild_neg"
        return "unknown"

    signals = []
    # Target turned hostile toward actor?
    ba_cls_before = classify_reaction(ba_before)
    ba_cls_after = classify_reaction(ba_after)
    if ba_cls_before == "positive" and ba_cls_after in ("strong_neg", "mild_neg"):
        signals.append("üî• Alvo retaliou")
    elif ba_cls_before in ("strong_neg", "mild_neg") and ba_cls_after in ("strong_neg", "mild_neg"):
        signals.append("üßä Hostilidade mantida")
    # Actor changed toward target?
    ab_cls_before = classify_reaction(ab_before)
    ab_cls_after = classify_reaction(ab_after)
    if ab_cls_before == "positive" and ab_cls_after in ("strong_neg", "mild_neg"):
        signals.append("‚ö° Ator rompeu")
    # Bidirectional escalation
    if (ba_cls_after in ("strong_neg", "mild_neg") and ab_cls_after in ("strong_neg", "mild_neg")
            and (ba_cls_before == "positive" or ab_cls_before == "positive")):
        signals.append("üí£ Escalada m√∫tua")

    signal_str = "<br>".join(signals) if signals else "‚Äî"

    rows_directed.append({
        "Data": event_date,
        "Evento": f"{emoji} {etype}",
        "Ator": actor,
        "Alvo": target,
        "Ator‚ÜíAlvo (antes)": ab_before,
        "Ator‚ÜíAlvo (depois)": ab_after,
        "Alvo‚ÜíAtor (antes)": ba_before,
        "Alvo‚ÜíAtor (depois)": ba_after,
        "Sinal": signal_str,
    })

if rows_directed:
    dir_df = pd.DataFrame(rows_directed)
    print(dir_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="directedImpactTable"))
else:
    print("<p class='text-muted'>Nenhum evento dirigido encontrado.</p>")
```

## Observa√ß√µes sobre timing

<div class="text-muted" style="font-size: 0.9rem; line-height: 1.6;">
<ul>
<li><strong>Querid√¥metro</strong> atualiza ~10h-12h BRT (ap√≥s o Raio-X). L√≠der √© decidido domingo √† noite ‚Üí primeira mudan√ßa vis√≠vel aparece na ter√ßa.</li>
<li><strong>Anjo</strong> tem ciclo curto (~1-2 dias), tornando as janelas "antes/depois" mais ruidosas.</li>
<li><strong>Querid√¥metro √© SECRETO</strong> ‚Äî mudan√ßas refletem sentimento genu√≠no, n√£o performance. Mas eventos p√∫blicos (indica√ß√£o, monstro) s√£o conhecidos por todos.</li>
<li><strong>Amostra pequena</strong>: 3 ciclos de L√≠der, 2 de Anjo, ~15 eventos dirigidos. Tend√™ncias s√£o indicativas, n√£o estatisticamente significativas.</li>
<li><strong>"Antes" e "depois"</strong> comparam snapshots adjacentes ‚Äî pode incluir efeito de outros eventos simult√¢neos.</li>
</ul>
</div>

## Badge vs Realidade (Pared√µes)

```{python}
#| label: badge-vs-reality
#| echo: false
#| output: asis

import pandas as pd

# Load precomputed badge data
_pb_path = Path("data/derived/paredao_badges.json")
paredao_badges_data = json.load(open(_pb_path, encoding="utf-8")) if _pb_path.exists() else {}
paredoes_data = json.loads(Path("data/paredoes.json").read_text(encoding="utf-8")) if Path("data/paredoes.json").exists() else {}

rows_all = []
for par in paredoes_data.get("paredoes", []) if paredoes_data else []:
    numero = par.get("numero")
    data_form = par.get("data_formacao") or par.get("data")
    if not numero or not data_form:
        continue
    badge_entry = paredao_badges_data.get("by_paredao", {}).get(str(numero), {})
    badges = badge_entry.get("badges", [])
    if not badges:
        continue
    df = pd.DataFrame([{
        "Participante": b["participante"],
        "Votos (casa)": b["votos_casa"],
        "Indica√ß√µes": b["indicacoes"],
        "Eleg√≠vel voto": "sim" if b["elegivel_voto"] else "n√£o",
        "Vulnerabilidade": b["vulnerabilidade"],
        "Impacto Negativo": b["impacto_negativo"],
        "Impact score": b["impact_score"],
        "Falsos amigos": b["falsos_amigos"],
    } for b in badges])
    df.insert(0, "Pared√£o", f"{numero}¬∫ ({data_form})")
    rows_all.append(df)

if not rows_all:
    print("Sem dados de pared√£o para comparar.")
else:
    all_df = pd.concat(rows_all, ignore_index=True)
    print(all_df.to_html(index=False, classes="table table-sm table-dark", escape=False))

    # Contradi√ß√µes
    print("\n### Contradi√ß√µes (badge vs realidade)\n")
    vuln_no_votes = all_df[(all_df["Votos (casa)"] == 0) & (all_df["Indica√ß√µes"] == 0) & (all_df["Eleg√≠vel voto"] == "sim")]
    vuln_no_votes = vuln_no_votes[vuln_no_votes["Vulnerabilidade"].isin(["üü† VULNER√ÅVEL", "üî¥ MUITO VULNER√ÅVEL"])]
    if vuln_no_votes.empty:
        print("<p class='text-muted'>Nenhum vulner√°vel sem votos nesta forma√ß√£o.</p>")
    else:
        print("<p class='text-muted'>Vulner√°veis sem votos (surpresa n√£o se confirmou):</p>")
        print(vuln_no_votes[["Pared√£o", "Participante", "Vulnerabilidade", "Votos (casa)"]]
              .to_html(index=False, classes="table table-sm table-dark", escape=False))

    prot_with_votes = all_df[(all_df["Votos (casa)"] >= 3) & (all_df["Eleg√≠vel voto"] == "sim")]
    prot_with_votes = prot_with_votes[prot_with_votes["Vulnerabilidade"].isin(["üü¢ PROTEGIDO", "üü° ATEN√á√ÉO"])]
    if prot_with_votes.empty:
        print("<p class='text-muted'>Nenhum protegido/aten√ß√£o com muitos votos.</p>")
    else:
        print("<p class='text-muted'>Protegidos/aten√ß√£o com muitos votos (voto coletivo/bloco):</p>")
        print(prot_with_votes[["Pared√£o", "Participante", "Vulnerabilidade", "Votos (casa)"]]
              .to_html(index=False, classes="table table-sm table-dark", escape=False))
```

## Retro: Big Fone Consenso (Semana 3)

Os 3 atendentes do Big Fone (Juliano Floss, Babu Santana, Marcelo) escolheram **Jonas Sulzbach** por consenso.
O scoring previu corretamente? Os componentes fazem sentido?

```{python}
#| label: big-fone-retro
#| echo: false
#| output: asis

# Load consensus analysis + relations for component breakdown
_idx_path = Path("data/derived/index_data.json")
_rel_path = Path("data/derived/relations_scores.json")
bfc = None
rel_data = {}
if _idx_path.exists():
    bfc = json.load(open(_idx_path, encoding="utf-8")).get("big_fone_consensus")
if _rel_path.exists():
    rel_data = json.load(open(_rel_path, encoding="utf-8"))

ACTUAL_TARGET = "Jonas Sulzbach"
pairs_daily = rel_data.get("pairs_daily", {})

if not bfc or not bfc.get("attendees"):
    print("<p class='text-muted'>Dados do consenso n√£o dispon√≠veis.</p>")
else:
    attendees = bfc["attendees"]
    targets = bfc.get("targets", [])
    consensus_targets = [t for t in targets if t.get("tier") == "consensus"]
    by_score = sorted(consensus_targets, key=lambda t: t["combined_score"])
    actual = next((t for t in targets if t["name"] == ACTUAL_TARGET), None)
    rank_score = next((i for i, t in enumerate(by_score, 1) if t["name"] == ACTUAL_TARGET), None)

    html = '<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'

    # --- Verdict badge ---
    if rank_score == 1:
        verdict_color, verdict = "#2ecc71", "ACERTOU ‚Äî Jonas era #1 entre os alvos dos 3"
    elif rank_score and rank_score <= 2:
        verdict_color, verdict = "#f39c12", f"PR√ìXIMO ‚Äî Jonas era #{rank_score}"
    else:
        verdict_color, verdict = "#e74c3c", f"ERROU ‚Äî Jonas era #{rank_score}" if rank_score else "N√£o previsto"

    html += f'<div style="display:flex; align-items:center; gap:12px; margin-bottom:1rem; flex-wrap:wrap;">'
    html += f'<span style="background:{verdict_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.9em;">{verdict}</span>'
    html += f'<span style="color:#aaa; font-size:0.85em;">Alvo real: <strong style="color:#eee;">{ACTUAL_TARGET}</strong></span>'
    html += '</div>'

    # --- Main table: all consensus targets ranked, with per-attendee breakdown ---
    html += '<h4 style="color:#f0c040; margin:1rem 0 0.5rem;">Alvos vi√°veis: quem os 3 atacavam no querid√¥metro</h4>'
    html += '<p style="color:#888; font-size:0.8em; margin-bottom:0.5rem;">Somente alvos que <em>todos os 3</em> davam rea√ß√£o negativa. Ordenado pelo score combinado (soma dos 3 pair scores).</p>'

    html += '<div style="overflow-x:auto;">'
    html += '<table style="width:100%; border-collapse:collapse; font-size:0.85em;">'
    html += '<tr style="border-bottom:1px solid #555;">'
    html += '<th style="padding:6px 8px; text-align:left; color:#ccc;">Alvo</th>'
    for att in attendees:
        html += f'<th style="padding:6px 8px; text-align:center; color:#ccc;">{att.split()[0]}</th>'
    html += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Combinado</th>'
    html += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Jonas‚Üíalvo?</th>'
    html += '</tr>'

    for t in by_score:
        is_actual = t["name"] == ACTUAL_TARGET
        row_bg = "background:#1a2a1a;" if is_actual else ""
        row_border = "border-left:3px solid #2ecc71;" if is_actual else ""

        html += f'<tr style="{row_bg} {row_border} border-bottom:1px solid #333;">'
        marker = " ‚úÖ" if is_actual else ""
        html += f'<td style="padding:6px 8px; color:#eee;"><strong>{t["name"]}</strong>{marker}</td>'

        # Per-attendee score + emoji
        for att in attendees:
            sc = t["scores"].get(att, 0)
            em = t["emojis"].get(att, "?")
            html += f'<td style="padding:6px 8px; text-align:center;">{em} <span style="color:#e74c3c;">{sc:+.2f}</span></td>'

        # Combined
        html += f'<td style="padding:6px 8px; text-align:center; color:#e74c3c; font-weight:bold;">{t["combined_score"]:+.2f}</td>'

        # Mutual indicator
        is_mutual = t.get("is_fully_mutual", False)
        mutual_label = "‚öîÔ∏è M√∫tuo" if is_mutual else "‚ù§Ô∏è N√£o sabe"
        mutual_color = "#e74c3c" if is_mutual else "#f39c12"
        html += f'<td style="padding:6px 8px; text-align:center; color:{mutual_color}; font-size:0.85em;">{mutual_label}</td>'
        html += '</tr>'

    html += '</table></div>'

    # --- Component decomposition: what drove each attendee‚ÜíJonas score? ---
    if actual:
        html += '<h4 style="color:#f0c040; margin:1.2rem 0 0.5rem;">O que comp√µe cada score ‚Üí Jonas</h4>'
        html += '<p style="color:#888; font-size:0.8em; margin-bottom:0.5rem;">Decomposi√ß√£o do pair score de cada atendente para Jonas. Querid√¥metro √© o emoji di√°rio; os demais s√£o eventos acumulados.</p>'

        html += '<table style="width:100%; border-collapse:collapse; font-size:0.85em;">'
        html += '<tr style="border-bottom:1px solid #555;">'
        html += '<th style="padding:6px 8px; text-align:left; color:#ccc;">Atendente</th>'
        html += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Emoji</th>'

        # Collect all component keys across attendees
        all_comp_keys = []
        att_components = {}
        for att in attendees:
            comps = pairs_daily.get(att, {}).get(ACTUAL_TARGET, {}).get("components", {})
            att_components[att] = comps
            for k in comps:
                if k not in all_comp_keys:
                    all_comp_keys.append(k)

        comp_labels = {"queridometro": "Querid√¥metro", "power_event": "Eventos de poder",
                       "sincerao": "Sincer√£o", "vote": "Votos", "vip": "VIP/Xepa"}
        for ck in all_comp_keys:
            html += f'<th style="padding:6px 8px; text-align:center; color:#ccc;">{comp_labels.get(ck, ck)}</th>'
        html += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Total</th>'
        html += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Jonas‚Üí</th>'
        html += '</tr>'

        for att in attendees:
            comps = att_components[att]
            total = sum(comps.values())
            em = actual["emojis"].get(att, "?")
            mutual_info = actual.get("mutual_hostility", {}).get(att, {})
            back_em = mutual_info.get("emoji", "?")
            back_neg = mutual_info.get("is_negative", False)
            back_color = "#e74c3c" if back_neg else "#2ecc71"

            html += f'<tr style="border-bottom:1px solid #333;">'
            html += f'<td style="padding:6px 8px; color:#eee;">{att}</td>'
            html += f'<td style="padding:6px 8px; text-align:center;">{em}</td>'
            for ck in all_comp_keys:
                v = comps.get(ck, 0)
                if v == 0:
                    html += f'<td style="padding:6px 8px; text-align:center; color:#555;">‚Äî</td>'
                else:
                    c = "#e74c3c" if v < 0 else "#2ecc71"
                    html += f'<td style="padding:6px 8px; text-align:center; color:{c}; font-weight:bold;">{v:+.2f}</td>'
            html += f'<td style="padding:6px 8px; text-align:center; color:#e74c3c; font-weight:bold;">{total:+.2f}</td>'
            html += f'<td style="padding:6px 8px; text-align:center;"><span style="color:{back_color};">{back_em}</span></td>'
            html += '</tr>'

        html += '</table>'

        # Component totals
        comp_totals = {ck: sum(att_components[att].get(ck, 0) for att in attendees) for ck in all_comp_keys}
        total_all = sum(comp_totals.values())
        html += '<div style="margin-top:0.8rem; padding:0.6rem 0.8rem; background:#111; border-radius:6px; font-size:0.85em; color:#aaa;">'
        html += '<strong style="color:#ccc;">Soma dos 3:</strong> '
        parts = []
        for ck in all_comp_keys:
            v = comp_totals[ck]
            label = comp_labels.get(ck, ck)
            c = "#e74c3c" if v < 0 else "#2ecc71"
            parts.append(f'{label} <span style="color:{c}; font-weight:bold;">{v:+.2f}</span>')
        html += ' + '.join(parts)
        html += f' = <strong style="color:#e74c3c;">{total_all:+.2f}</strong>'

        # Percentage breakdown
        if total_all != 0:
            html += '<br><strong style="color:#ccc;">Peso relativo:</strong> '
            pct_parts = []
            for ck in all_comp_keys:
                v = comp_totals[ck]
                pct = abs(v) / sum(abs(comp_totals[k]) for k in all_comp_keys) * 100
                label = comp_labels.get(ck, ck)
                pct_parts.append(f'{label} {pct:.0f}%')
            html += ' ¬∑ '.join(pct_parts)
        html += '</div>'

    # --- Compare: why Jonas and not the others? ---
    html += '<h4 style="color:#f0c040; margin:1.2rem 0 0.5rem;">Por que Jonas e n√£o os outros alvos?</h4>'
    html += '<div style="color:#ccc; font-size:0.85em; line-height:1.7;">'

    if rank_score == 1 and len(by_score) > 1:
        gap = by_score[1]["combined_score"] - by_score[0]["combined_score"]
        runner_up = by_score[1]["name"]

        # What made Jonas different: check if all 3 had power_events against him
        jonas_power = sum(
            pairs_daily.get(att, {}).get(ACTUAL_TARGET, {}).get("components", {}).get("power_event", 0)
            for att in attendees
        )
        jonas_querido = sum(
            pairs_daily.get(att, {}).get(ACTUAL_TARGET, {}).get("components", {}).get("queridometro", 0)
            for att in attendees
        )

        html += f'<p>Jonas liderava com <strong>{actual["combined_score"]:+.2f}</strong>, '
        html += f'um gap de <strong>{gap:+.2f}</strong> para o 2¬∫ ({runner_up}).</p>'

        html += '<p><strong style="color:#e74c3c;">Fator decisivo: eventos de poder acumulados.</strong> '
        html += f'Jonas recebia {jonas_power:+.2f} de power_events dos 3 atendentes '
        html += f'(vs {jonas_querido:+.2f} do querid√¥metro sozinho). '

        # Compare with runner-up
        ru_power = sum(
            pairs_daily.get(att, {}).get(runner_up, {}).get("components", {}).get("power_event", 0)
            for att in attendees
        )
        ru_querido = sum(
            pairs_daily.get(att, {}).get(runner_up, {}).get("components", {}).get("queridometro", 0)
            for att in attendees
        )
        html += f'Em contraste, {runner_up} recebia {ru_power:+.2f} de power_events e {ru_querido:+.2f} do querid√¥metro. '
        html += 'Os eventos (Monstro recebido, indica√ß√µes anteriores) amplificaram a rejei√ß√£o que o querid√¥metro j√° mostrava.</p>'

    # Blind spot analysis
    if actual and not actual.get("is_fully_mutual"):
        blind_atts = [att for att in attendees
                      if not actual.get("mutual_hostility", {}).get(att, {}).get("is_negative", False)]
        if blind_atts:
            html += f'<p><strong style="color:#f39c12;">Ponto cego de Jonas:</strong> '
            html += f'dava ‚ù§Ô∏è para {", ".join(blind_atts)} ‚Äî a hostilidade era unilateral. '
            html += 'Jonas n√£o sabia que era alvo deles, o que tipifica uma indica√ß√£o-surpresa. '
            html += 'Alvos m√∫tuos (Brigido, Gabriela) tinham scores menores justamente porque a hostilidade rec√≠proca '
            html += 'pode inibir a a√ß√£o ‚Äî quando ambos se atacam, a tens√£o √© conhecida. '
            html += 'O ponto cego unilateral torna a a√ß√£o mais f√°cil para os atores.</p>'

    html += '</div>'

    # --- Nota sobre consensus_pct ---
    html += '<div style="margin-top:0.8rem; padding:0.6rem 0.8rem; background:#222; border:1px solid #444; border-radius:6px; font-size:0.82em; color:#888;">'
    html += '<strong style="color:#aaa;">Nota sobre consensus %:</strong> '
    html += 'Jonas era #3 por consensus_pct (54% vs 64% de Brigido/Gabriela). '
    html += 'Essa m√©trica mede "qual % de hipot√©ticos 3¬∫s atendentes concordariam" ‚Äî √∫til como an√°lise de robustez, '
    html += 'mas n√£o como preditor quando os atores j√° s√£o conhecidos. O combined score dos 3 atores reais √© a m√©trica correta.'
    html += '</div>'

    # --- Final verdict ---
    html += '<div style="background:#1a2a1a; border:1px solid #2ecc71; border-radius:8px; padding:0.8rem 1rem; margin-top:1rem;">'
    html += '<strong style="color:#2ecc71;">Veredicto:</strong> '
    if rank_score == 1:
        html += '<span style="color:#ccc;">O scoring <strong>acertou</strong>. Jonas era o alvo #1 dos 3 atendentes por larga margem. '
        html += 'A combina√ß√£o de querid√¥metro negativo + eventos de poder acumulados capturou corretamente a intensidade da rejei√ß√£o conjunta. '
        html += '<strong>Nenhum ajuste de pesos necess√°rio</strong> ‚Äî o sistema funcionou como esperado para este caso.</span>'
    elif rank_score and rank_score <= 2:
        html += f'<span style="color:#ccc;">O scoring chegou perto (#{rank_score}). Considerar se o peso de power_events est√° calibrado.</span>'
    else:
        html += '<span style="color:#ccc;">O scoring errou. Revisar pesos dos componentes ‚Äî especialmente a propor√ß√£o entre querid√¥metro e eventos.</span>'
    html += '</div>'

    html += '</div>'
    print(html)
```

## Retro: Votos vs Scoring (Pared√µes 1 & 2)

<p class="text-muted">Para cada pared√£o passado, compara o voto real de cada participante com o alvo previsto pelo scoring (o alvo mais negativo eleg√≠vel). Usa <code>pairs_daily</code> para ativos e <code>pairs_all</code> para eliminados/desistentes. <strong>Limita√ß√£o:</strong> usa scores <em>atuais</em> (Jan 31), n√£o congelados na data do pared√£o.</p>

```{python}
#| label: vote-prediction-retro
#| echo: false
#| output: asis

# --- Retro: compare pairs_daily predicted votes vs actual votes ---
paredoes_path = Path("data/paredoes.json")
paredoes_file = json.loads(paredoes_path.read_text(encoding="utf-8")) if paredoes_path.exists() else {}

pairs_d = relations.get("pairs_daily", {})
pairs_all = relations.get("pairs_all", {})

html_retro = ""

retro_summary = []

for par in paredoes_file.get("paredoes", []):
    numero = par.get("numero")
    votos_casa = par.get("votos_casa", {})
    if not votos_casa:
        continue

    impedidos = set(par.get("impedidos_votar", []))
    anulados = set(par.get("votos_anulados", []))
    data_form = par.get("data_formacao", par.get("data", ""))

    exact = 0
    top3 = 0
    total_voters = 0
    rows_retro = []

    for voter, actual_target in votos_casa.items():
        if voter in impedidos or voter in anulados:
            continue

        # Get voter's pair scores ‚Äî try pairs_daily first, fall back to pairs_all
        voter_pairs = pairs_d.get(voter, {}) or pairs_all.get(voter, {})
        if not voter_pairs:
            rows_retro.append({
                "Votante": voter,
                "Voto real": actual_target,
                "Previsto (#1)": "‚Äî <em>(sem scores)</em>",
                "Score #1": "",
                "Rank do real": "‚Äî",
                "Score real": "‚Äî",
                "#2": "",
                "#3": "",
                "Acerto": "‚¨ú",
            })
            total_voters += 1
            continue

        # Build full target list: merge pairs_daily + pairs_all for this voter
        # so eliminated targets (e.g. Paulo Augusto) appear in the ranking
        merged_pairs = {}
        for t, rec in pairs_all.get(voter, {}).items():
            if t != voter:
                merged_pairs[t] = rec
        for t, rec in voter_pairs.items():
            if t != voter:
                merged_pairs[t] = rec  # pairs_daily overrides pairs_all

        # Sort targets by score ascending (most negative first = predicted vote)
        sorted_targets = sorted(merged_pairs.items(), key=lambda x: x[1].get("score", 0))

        predicted_target = sorted_targets[0][0] if sorted_targets else "‚Äî"
        predicted_score = sorted_targets[0][1].get("score", 0) if sorted_targets else 0

        # Find rank of actual target
        target_names = [t for t, _ in sorted_targets]
        if actual_target in target_names:
            actual_rank = target_names.index(actual_target) + 1
            actual_score = next(rec.get("score", 0) for t, rec in sorted_targets if t == actual_target)
        else:
            actual_rank = "‚Äî"
            actual_score = "‚Äî"

        is_exact = (predicted_target == actual_target)
        is_top3 = actual_rank != "‚Äî" and isinstance(actual_rank, int) and actual_rank <= 3

        if is_exact:
            exact += 1
        if is_top3:
            top3 += 1
        total_voters += 1

        choice2 = sorted_targets[1][0] if len(sorted_targets) > 1 else ""
        choice3 = sorted_targets[2][0] if len(sorted_targets) > 2 else ""

        acerto_icon = "‚úÖ" if is_exact else ("üü°" if is_top3 else "‚ùå")

        rows_retro.append({
            "Votante": voter,
            "Voto real": f"<strong>{actual_target}</strong>",
            "Previsto (#1)": f"<strong>{predicted_target}</strong>",
            "Score #1": fmt_score(predicted_score),
            "Rank do real": actual_rank if actual_rank != "‚Äî" else "‚Äî",
            "Score real": fmt_score(actual_score) if actual_score != "‚Äî" else "‚Äî",
            "#2": choice2,
            "#3": choice3,
            "Acerto": acerto_icon,
        })

    if not rows_retro:
        continue

    exact_pct = exact / total_voters * 100 if total_voters else 0
    top3_pct = top3 / total_voters * 100 if total_voters else 0

    # Count voters targeting eliminated participants (no scores available)
    no_score_voters = sum(1 for r in rows_retro if "sem scores" in str(r.get("Previsto (#1)", "")))
    scorable_voters = total_voters - no_score_voters
    exact_scorable_pct = exact / scorable_voters * 100 if scorable_voters else 0

    retro_summary.append({
        "paredao": numero,
        "exact": exact,
        "top3": top3,
        "total": total_voters,
        "exact_pct": exact_pct,
        "top3_pct": top3_pct,
        "scorable": scorable_voters,
        "exact_scorable_pct": exact_scorable_pct,
    })

    # Render summary card
    html_retro += f'<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
    html_retro += f'<h4 style="color:#f0c040; margin:0 0 0.8rem;">{numero}¬∫ Pared√£o ({data_form})</h4>'

    # Accuracy badges
    exact_color = "#2ecc71" if exact_pct >= 40 else ("#f39c12" if exact_pct >= 20 else "#e74c3c")
    top3_color = "#2ecc71" if top3_pct >= 60 else ("#f39c12" if top3_pct >= 40 else "#e74c3c")
    html_retro += '<div style="display:flex; gap:12px; flex-wrap:wrap; margin-bottom:0.8rem;">'
    html_retro += f'<span style="background:{exact_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.9em;">Exato: {exact}/{total_voters} ({exact_pct:.0f}%)</span>'
    html_retro += f'<span style="background:{top3_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.9em;">Top-3: {top3}/{total_voters} ({top3_pct:.0f}%)</span>'
    if no_score_voters > 0:
        html_retro += f'<span style="background:#555; color:#eee; padding:4px 12px; border-radius:6px; font-size:0.85em;">Excl. eliminados: {exact}/{scorable_voters} ({exact_scorable_pct:.0f}%)</span>'
    html_retro += '</div>'

    # Detail table
    retro_df = pd.DataFrame(rows_retro)
    html_retro += retro_df.to_html(index=False, classes="table table-sm table-dark", escape=False)
    html_retro += '</div>'

# Overall summary
if retro_summary:
    total_exact = sum(s["exact"] for s in retro_summary)
    total_top3 = sum(s["top3"] for s in retro_summary)
    total_all = sum(s["total"] for s in retro_summary)
    total_scorable = sum(s["scorable"] for s in retro_summary)

    html_retro += '<div style="background:#222; border:1px solid #555; border-radius:8px; padding:0.8rem 1rem; margin:1rem 0;">'
    html_retro += f'<strong style="color:#f0c040;">Resumo geral:</strong> '
    html_retro += f'Exato {total_exact}/{total_all} ({total_exact/total_all*100:.0f}%) ¬∑ '
    html_retro += f'Top-3 {total_top3}/{total_all} ({total_top3/total_all*100:.0f}%) ¬∑ '
    html_retro += f'Apenas participantes com scores: {total_exact}/{total_scorable} ({total_exact/total_scorable*100:.0f}% exato)'
    html_retro += '</div>'

# Methodology box
html_retro += '<div style="background:#111; border:1px solid #333; border-radius:8px; padding:0.8rem 1rem; margin:1rem 0; font-size:0.85em; color:#aaa;">'
html_retro += '<strong style="color:#ccc;">Metodologia</strong><br>'
html_retro += '<ul style="margin:0.3rem 0 0;">'
html_retro += '<li><strong>Previs√£o:</strong> para cada votante, o alvo previsto √© o participante eleg√≠vel com o menor (mais negativo) score <code>pairs_daily</code> combinado.</li>'
html_retro += '<li><strong>Componentes do score:</strong> querid√¥metro (emoji di√°rio, 70% janela reativa 3d + 30% mem√≥ria de sequ√™ncia) + eventos acumulados (poder, votos, sincer√£o, VIP) sem decay.</li>'
html_retro += '<li><strong>Fonte dos scores:</strong> usa <code>pairs_daily</code> para participantes ativos e <code>pairs_all</code> (com querid√¥metro do √∫ltimo snapshot pr√©-sa√≠da) para eliminados/desistentes.</li>'
html_retro += '<li><strong>Limita√ß√µes:</strong> scores atuais incluem eventos p√≥s-pared√£o; n√£o modela voto estrat√©gico ou coordena√ß√£o de alian√ßas.</li>'
html_retro += '<li><strong>M√©tricas:</strong> Exato = previsto == real; Top-3 = real estava entre os 3 alvos mais negativos do votante.</li>'
html_retro += '</ul></div>'

print(html_retro)
```

## Previs√£o: Votos do 3¬∫ Pared√£o

<p class="text-muted">Forma√ß√£o em 1¬∫ de Fevereiro. L√≠der: <strong>Maxiane</strong> (n√£o vota, n√£o pode ser votada). Jonas Sulzbach j√° indicado (Big Fone consenso ‚Äî pode votar). Anjo: <strong>Sarah Andrade</strong> (vota normalmente, <strong>pode ser votada</strong> ‚Äî Anjo n√£o √© autoimune). Imunizado(a) pelo Anjo: a definir (ao vivo).</p>

```{python}
#| label: vote-prediction-3rd
#| echo: false
#| output: asis

# --- 3rd Pared√£o prediction ---
pairs_d = relations.get("pairs_daily", {})

# Game state
lider = "Maxiane"
already_nominated = "Jonas Sulzbach"  # Big Fone consensus ‚Äî can vote, already going to pared√£o
anjo = "Sarah Andrade"  # Anjo is NOT auto-immune; can be voted for, votes normally

active_participants = sorted(pairs_d.keys())

# Voters: all active minus L√≠der (19 voters)
voters = [p for p in active_participants if p != lider]

# Targets: all active minus L√≠der, minus already_nominated (Jonas)
# Anjo (Sarah) CAN be voted for ‚Äî Anjo is not auto-immune
# Immune from Anjo is TBD (decided live) ‚Äî not excluded yet
cant_be_voted = {lider, already_nominated}
targets = [p for p in active_participants if p not in cant_be_voted]

html_pred = ""
html_pred += f'<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
html_pred += f'<h4 style="color:#f0c040; margin:0 0 0.5rem;">Estado do jogo</h4>'
html_pred += '<div style="display:flex; gap:16px; flex-wrap:wrap; margin-bottom:0.8rem; font-size:0.9em;">'
html_pred += f'<span>üëë L√≠der: <strong>{lider}</strong> (n√£o vota)</span>'
html_pred += f'<span>üìû Big Fone: <strong>{already_nominated}</strong> (j√° emparedado, vota)</span>'
html_pred += f'<span>üòá Anjo: <strong>{anjo}</strong> (vota, <strong>pode ser votada</strong>)</span>'
html_pred += f'<span>üó≥Ô∏è Votantes: <strong>{len(voters)}</strong></span>'
html_pred += f'<span>üéØ Alvos eleg√≠veis: <strong>{len(targets)}</strong></span>'
html_pred += '</div>'
html_pred += '<div style="color:#888; font-size:0.82em;">‚ö†Ô∏è O imunizado pelo Anjo (decis√£o ao vivo) n√£o est√° exclu√≠do dos alvos ‚Äî ajustar ap√≥s a imuniza√ß√£o.</div>'
html_pred += '</div>'

# --- L√≠der indication analysis ---
html_pred += '<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
html_pred += '<h4 style="color:#f0c040; margin:0 0 0.5rem;">üëë Indica√ß√£o do L√≠der (Maxiane)</h4>'
html_pred += '<p style="color:#aaa; font-size:0.85em;">Top alvos da Maxiane por score mais negativo ‚Äî poss√≠vel indica√ß√£o do L√≠der.</p>'

maxiane_pairs = pairs_d.get(lider, {})
max_sorted = sorted(
    [(t, rec) for t, rec in maxiane_pairs.items() if t != lider],
    key=lambda x: x[1].get("score", 0)
)

html_pred += '<table style="width:100%; border-collapse:collapse; font-size:0.85em; max-width:700px;">'
html_pred += '<tr style="border-bottom:1px solid #555;">'
html_pred += '<th style="padding:6px 8px; text-align:left; color:#ccc;">#</th>'
html_pred += '<th style="padding:6px 8px; text-align:left; color:#ccc;">Alvo</th>'
html_pred += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Score</th>'
html_pred += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Querid√¥metro</th>'
html_pred += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Eventos</th>'
html_pred += '</tr>'
for i, (t, rec) in enumerate(max_sorted[:5]):
    sc = rec.get("score", 0)
    comps = rec.get("components", {})
    q = comps.get("queridometro", 0)
    ev = sc - q  # events = total minus queridometro
    sc_color = "#e74c3c" if sc < 0 else "#2ecc71"
    html_pred += f'<tr style="border-bottom:1px solid #333;">'
    html_pred += f'<td style="padding:6px 8px; color:#888;">{i+1}</td>'
    html_pred += f'<td style="padding:6px 8px; color:#eee;"><strong>{t}</strong></td>'
    html_pred += f'<td style="padding:6px 8px; text-align:center; color:{sc_color}; font-weight:bold;">{sc:+.2f}</td>'
    html_pred += f'<td style="padding:6px 8px; text-align:center;">{fmt_score(q)}</td>'
    html_pred += f'<td style="padding:6px 8px; text-align:center;">{fmt_score(ev)}</td>'
    html_pred += '</tr>'
html_pred += '</table></div>'

# --- Full voter table ---
html_pred += '<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
html_pred += '<h4 style="color:#f0c040; margin:0 0 0.5rem;">üó≥Ô∏è Previs√£o por votante</h4>'
html_pred += '<p style="color:#aaa; font-size:0.85em;">Para cada votante, o alvo eleg√≠vel com score mais negativo. Confian√ßa = gap entre #1 e #2 (maior gap = mais prov√°vel).</p>'

prediction_rows = []
vote_totals = defaultdict(int)

for voter in voters:
    voter_pairs = pairs_d.get(voter, {})
    # Sort eligible targets by score
    eligible = [(t, voter_pairs.get(t, {}).get("score", 0)) for t in targets if t != voter]
    eligible.sort(key=lambda x: x[1])

    if not eligible:
        prediction_rows.append({
            "Votante": voter,
            "Previsto": "‚Äî",
            "Score": "",
            "#2": "",
            "#3": "",
            "Confian√ßa": "",
        })
        continue

    pred1 = eligible[0]
    pred2 = eligible[1] if len(eligible) > 1 else ("", 0)
    pred3 = eligible[2] if len(eligible) > 2 else ("", 0)
    gap = pred2[1] - pred1[1] if pred2[0] else 0

    vote_totals[pred1[0]] += 1

    gap_color = "#2ecc71" if gap >= 0.5 else ("#f39c12" if gap >= 0.2 else "#e74c3c")

    prediction_rows.append({
        "Votante": voter,
        "Previsto": f"<strong>{pred1[0]}</strong>",
        "Score": fmt_score(pred1[1]),
        "#2": f"{pred2[0]} ({pred2[1]:+.2f})" if pred2[0] else "",
        "#3": f"{pred3[0]} ({pred3[1]:+.2f})" if pred3[0] else "",
        "Confian√ßa": f"<span style='color:{gap_color}; font-weight:bold;'>{gap:+.2f}</span>",
    })

pred_df = pd.DataFrame(prediction_rows)
html_pred += pred_df.to_html(index=False, classes="table table-sm table-dark", escape=False)
html_pred += '</div>'

# --- Vote concentration ---
html_pred += '<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
html_pred += '<h4 style="color:#f0c040; margin:0 0 0.5rem;">üìä Concentra√ß√£o de votos previstos</h4>'
html_pred += '<p style="color:#aaa; font-size:0.85em;">Total de votos previstos por alvo (os 2 mais votados v√£o ao pared√£o).</p>'

sorted_totals = sorted(vote_totals.items(), key=lambda x: -x[1])
total_votes = sum(v for _, v in sorted_totals)

html_pred += '<table style="width:100%; border-collapse:collapse; font-size:0.85em; max-width:600px;">'
html_pred += '<tr style="border-bottom:1px solid #555;">'
html_pred += '<th style="padding:6px 8px; text-align:left; color:#ccc;">#</th>'
html_pred += '<th style="padding:6px 8px; text-align:left; color:#ccc;">Alvo</th>'
html_pred += '<th style="padding:6px 8px; text-align:center; color:#ccc;">Votos previstos</th>'
html_pred += '<th style="padding:6px 8px; text-align:left; color:#ccc;">Barra</th>'
html_pred += '</tr>'

max_votes = sorted_totals[0][1] if sorted_totals else 1
for i, (target, votes) in enumerate(sorted_totals):
    bar_width = int(votes / max_votes * 200)
    bar_color = "#e74c3c" if i < 2 else "#555"
    highlight = "border-left:3px solid #e74c3c;" if i < 2 else ""
    label_extra = " üéØ" if i < 2 else ""
    html_pred += f'<tr style="{highlight} border-bottom:1px solid #333;">'
    html_pred += f'<td style="padding:6px 8px; color:#888;">{i+1}</td>'
    html_pred += f'<td style="padding:6px 8px; color:#eee;"><strong>{target}</strong>{label_extra}</td>'
    html_pred += f'<td style="padding:6px 8px; text-align:center; font-weight:bold;">{votes}</td>'
    html_pred += f'<td style="padding:6px 8px;"><div style="background:{bar_color}; height:16px; width:{bar_width}px; border-radius:4px;"></div></td>'
    html_pred += '</tr>'

# Also show targets with 0 votes
zero_targets = [t for t in targets if t not in vote_totals]
for t in sorted(zero_targets):
    html_pred += f'<tr style="border-bottom:1px solid #333;">'
    html_pred += f'<td style="padding:6px 8px; color:#555;">‚Äî</td>'
    html_pred += f'<td style="padding:6px 8px; color:#666;">{t}</td>'
    html_pred += f'<td style="padding:6px 8px; text-align:center; color:#555;">0</td>'
    html_pred += f'<td></td></tr>'

html_pred += '</table>'
html_pred += f'<div style="color:#888; font-size:0.82em; margin-top:0.5rem;">Total: {total_votes} votos previstos de {len(voters)} votantes</div>'
html_pred += '</div>'

# --- Top-2 analysis ---
html_pred += '<div style="background:#1a2a1a; border:1px solid #2ecc71; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
html_pred += '<h4 style="color:#2ecc71; margin:0 0 0.5rem;">üîÆ An√°lise Top-2 (quem vai ao pared√£o?)</h4>'

if len(sorted_totals) >= 2:
    t1_name, t1_votes = sorted_totals[0]
    t2_name, t2_votes = sorted_totals[1]
    t3_name, t3_votes = sorted_totals[2] if len(sorted_totals) > 2 else ("‚Äî", 0)

    # Who votes for top-2
    t1_voters = [r["Votante"] for r in prediction_rows if t1_name in r.get("Previsto", "")]
    t2_voters = [r["Votante"] for r in prediction_rows if t2_name in r.get("Previsto", "")]

    html_pred += '<div style="display:flex; gap:16px; flex-wrap:wrap; margin-bottom:0.8rem;">'
    html_pred += f'<div style="flex:1; min-width:250px; background:#111; border-radius:8px; padding:0.8rem;">'
    html_pred += f'<div style="font-size:1.1em; font-weight:bold; color:#e74c3c;">ü•á {t1_name} ‚Äî {t1_votes} votos</div>'
    html_pred += f'<div style="color:#aaa; font-size:0.85em; margin-top:0.3rem;">Votantes: {", ".join(t1_voters)}</div></div>'
    html_pred += f'<div style="flex:1; min-width:250px; background:#111; border-radius:8px; padding:0.8rem;">'
    html_pred += f'<div style="font-size:1.1em; font-weight:bold; color:#f39c12;">ü•à {t2_name} ‚Äî {t2_votes} votos</div>'
    html_pred += f'<div style="color:#aaa; font-size:0.85em; margin-top:0.3rem;">Votantes: {", ".join(t2_voters)}</div></div>'
    html_pred += '</div>'

    gap12 = t1_votes - t2_votes
    gap23 = t2_votes - t3_votes

    html_pred += '<div style="color:#ccc; font-size:0.9em; line-height:1.7; margin-top:0.5rem;">'
    if gap12 == 0:
        html_pred += f'<p><strong>{t1_name}</strong> e <strong>{t2_name}</strong> empatam com {t1_votes} votos cada ‚Äî disputa equilibrada.</p>'
    else:
        html_pred += f'<p><strong>{t1_name}</strong> lidera com {t1_votes} votos (gap de {gap12} para o 2¬∫).'
        html_pred += f' <strong>{t2_name}</strong> √© o 2¬∫ com {t2_votes} votos.</p>'
    if gap23 <= 1:
        html_pred += f'<p style="color:#f39c12;">‚ö†Ô∏è Disputa apertada: {t2_name} ({t2_votes}) vs {t3_name} ({t3_votes}) ‚Äî apenas {gap23} voto(s) de diferen√ßa para o 3¬∫.</p>'
    html_pred += '</div>'

html_pred += '</div>'

# --- Methodology ---
html_pred += '<div style="background:#111; border:1px solid #333; border-radius:8px; padding:0.8rem 1rem; margin:1rem 0; font-size:0.85em; color:#aaa;">'
html_pred += '<strong style="color:#ccc;">Metodologia da previs√£o</strong><br>'
html_pred += '<ul style="margin:0.3rem 0 0;">'
html_pred += '<li><strong>M√©todo:</strong> para cada votante, o alvo previsto √© o participante eleg√≠vel com o menor (mais negativo) score <code>pairs_daily</code> combinado (querid√¥metro + eventos acumulados).</li>'
html_pred += '<li><strong>Elegibilidade:</strong> exclui L√≠der (Maxiane) e j√° emparedado (Jonas). Anjo (Sarah) <strong>pode ser votada</strong> (n√£o √© autoimune). O imunizado pelo Anjo √© desconhecido ‚Äî ajustar ap√≥s imuniza√ß√£o.</li>'
html_pred += '<li><strong>Confian√ßa:</strong> diferen√ßa entre o score do 1¬∫ e 2¬∫ alvo mais negativo. Gap alto = predi√ß√£o mais robusta; gap baixo = segundo alvo quase t√£o prov√°vel.</li>'
html_pred += '<li><strong>Limita√ß√µes:</strong> n√£o modela voto estrat√©gico, coordena√ß√£o de alian√ßas, ou influ√™ncia de conversas pr√©-pared√£o. Usa scores atuais (Jan 31).</li>'
html_pred += '<li><strong>Valida√ß√£o:</strong> ap√≥s os votos reais, re-rodar esta an√°lise para computar acur√°cia e comparar com a retro dos pared√µes anteriores.</li>'
html_pred += '</ul></div>'

print(html_pred)
```
