---
title: "üß≠ Rela√ß√µes ‚Äî Debug"
subtitle: "Tally completo do score A‚ÜíB (querid√¥metro + eventos)"
---

```{python}
#| label: setup
#| message: false
#| warning: false

import json
from pathlib import Path
from collections import Counter
import pandas as pd
import sys

sys.path.append(str(Path("scripts").resolve()))
from data_utils import (
    require_clean_manual_events, setup_bbb_dark_theme,
    get_all_snapshots, load_snapshot, load_relations_scores,
    build_reaction_matrix, load_reaction_matrices, deserialize_matrix,
    REACTION_EMOJI, SENTIMENT_WEIGHTS, get_week_number,
    parse_roles, POSITIVE, MILD_NEGATIVE, STRONG_NEGATIVE, POWER_EVENT_EMOJI,
    avatar_img, artigo
)

require_clean_manual_events()
setup_bbb_dark_theme()

relations = load_relations_scores()
relations_pairs_daily = relations.get("pairs_daily", {}) or relations.get("pairs", {})
relations_pairs_all = relations.get("pairs_all", {})
contradictions = relations.get("contradictions", {})
received_impact = relations.get("received_impact", {})
voting_blocs = relations.get("voting_blocs", [])
streak_breaks = relations.get("streak_breaks", [])
edges = relations.get("edges", []) or relations.get("edges_daily", []) or relations.get("edges_paredao", [])
meta = relations.get("_metadata", {})
DISPLAY_WEEK_DAILY = meta.get("effective_week_daily") or meta.get("week") or 2
DISPLAY_WEEK_PAREDAO = meta.get("effective_week_paredao") or meta.get("week") or 2
reference_date_daily = meta.get("reference_date_daily") or meta.get("date")
reference_date_paredao = meta.get("reference_date_paredao") or meta.get("date")

snapshots = get_all_snapshots()
latest = snapshots[-1] if snapshots else None
participants = []
latest_date = None
matrix_daily = {}
matrix_paredao = {}
week_snapshot_daily = None
week_snapshot_paredao = None
week_date_daily = None
week_date_paredao = None

# Load precomputed matrices for fast by-date lookup
_precomp = load_reaction_matrices()
_precomp_by_date = _precomp.get("by_date", {}) if _precomp else {}

def _get_matrix_for_date(date_key, participants_list):
    """Get matrix from precomputed data or compute at runtime."""
    if date_key in _precomp_by_date:
        return deserialize_matrix(_precomp_by_date[date_key])
    return build_reaction_matrix(participants_list)

if snapshots:
    if reference_date_daily:
        for fp, date in snapshots:
            if date <= reference_date_daily:
                week_snapshot_daily = (fp, date)
    if not week_snapshot_daily:
        for fp, date in snapshots:
            if get_week_number(date) == DISPLAY_WEEK_DAILY:
                week_snapshot_daily = (fp, date)
    if not week_snapshot_daily:
        week_snapshot_daily = latest
    if reference_date_paredao:
        for fp, date in snapshots:
            if date <= reference_date_paredao:
                week_snapshot_paredao = (fp, date)
    if not week_snapshot_paredao:
        for fp, date in snapshots:
            if get_week_number(date) == DISPLAY_WEEK_PAREDAO:
                week_snapshot_paredao = (fp, date)
    if not week_snapshot_paredao:
        week_snapshot_paredao = latest
if week_snapshot_daily:
    week_fp, week_date_daily = week_snapshot_daily
    participants, _ = load_snapshot(week_fp)
    matrix_daily = _get_matrix_for_date(week_date_daily, participants)
if week_snapshot_paredao:
    week_fp, week_date_paredao = week_snapshot_paredao
    participants, _ = load_snapshot(week_fp)
    matrix_paredao = _get_matrix_for_date(week_date_paredao, participants)


def reaction_label(actor, target, matrix):
    label = matrix.get((actor, target), "")
    emoji = REACTION_EMOJI.get(label, "") if label else ""
    return label, emoji


def classify_relation(score):
    if score >= 0.5:
        return "Amig√°vel", "rel-friend"
    if score <= -0.5:
        return "Hostil", "rel-hostile"
    return "Neutro", "rel-neutral"


def fmt_score(value):
    if value is None:
        return ""
    cls = "val-zero"
    if value > 0:
        cls = "val-pos"
    elif value < 0:
        cls = "val-neg"
    return f"<span class='{cls}'>{value:.2f}</span>"


def flatten_pairs(pairs, matrix):
    rows = []
    for actor, targets in pairs.items():
        for target, rec in targets.items():
            label, emoji = reaction_label(actor, target, matrix)
            comps = rec.get("components", rec.get("components_roll", {}))
            q_score = comps.get("queridometro", 0.0)
            score = rec.get("score", rec.get("roll", 0.0))
            rel_label, rel_class = classify_relation(score)
            s_len = rec.get("streak_len", 0)
            has_break = rec.get("break", False)
            rows.append({
                "Ator": actor,
                "Alvo": target,
                "Rela√ß√£o": f"<span class='rel-pill {rel_class}'>{rel_label}</span>",
                "Emoji (dia)": f"{emoji} {label}".strip(),
                "Q (3d)": fmt_score(q_score),
                "Streak": f"{'üíî ' if has_break else ''}{s_len}d",
                "Power": fmt_score(comps.get("power_event", 0.0)),
                "Sincer√£o": fmt_score(comps.get("sincerao", 0.0)),
                "VIP": fmt_score(comps.get("vip", 0.0)),
                "Voto": fmt_score(comps.get("vote", 0.0)),
                "Score": fmt_score(score),
            })
    return pd.DataFrame(rows)

pairs_daily_df = flatten_pairs(relations_pairs_daily, matrix_daily) if relations_pairs_daily else pd.DataFrame()

edge_rows = []
for ev in edges:
    weight = ev.get("weight", ev.get("weight_roll"))
    edge_rows.append({
        "Data": ev.get("date", ""),
        "Semana": ev.get("week", ""),
        "Tipo": ev.get("type", ""),
        "Evento": ev.get("event_type") or ev.get("sinc_type") or "",
        "Tema": ev.get("tema") or "",
        "Slot": ev.get("slot") or "",
        "Ator": ev.get("actor", ""),
        "Alvo": ev.get("target", ""),
        "Visibilidade": ev.get("visibility") or "",
        "Backlash": "sim" if ev.get("backlash") else "",
        "Voto (tipo)": ev.get("vote_kind") or "",
        "Revelado": "sim" if ev.get("revealed") else "n√£o",
        "Peso": fmt_score(weight) if weight is not None else "",
    })

edges_df = pd.DataFrame(edge_rows)

event_rows = []
for ev in edges:
    if ev.get("week") != DISPLAY_WEEK_PAREDAO:
        continue
    if ev.get("type") == "power_event" and ev.get("event_type") not in {"indicacao", "contragolpe"}:
        continue
    if ev.get("type") != "power_event" and ev.get("type") != "vote":
        continue
    actor = ev.get("actor")
    target = ev.get("target")
    label, emoji = reaction_label(actor, target, matrix_paredao)
    event_rows.append({
        "Data": ev.get("date"),
        "Tipo": ev.get("type"),
        "Evento": ev.get("event_type"),
        "Ator": actor,
        "Alvo": target,
        "Querid√¥metro": f"{emoji} {label}".strip(),
        "Peso evento": fmt_score(ev.get("weight_raw") or 0),
        "Backlash": "sim" if ev.get("backlash") else "",
        "Voto (tipo)": ev.get("vote_kind"),
    })

events_vs_df = pd.DataFrame(event_rows)
```

## Pesos ativos

<style>
.rel-pill {
  display: inline-block;
  padding: 0.1rem 0.45rem;
  border-radius: 999px;
  font-size: 0.75rem;
  font-weight: 600;
  border: 1px solid rgba(255,255,255,0.2);
}
.rel-friend { background: rgba(40,167,69,0.18); color: #a8f0b3; border-color: rgba(40,167,69,0.5); }
.rel-neutral { background: rgba(108,117,125,0.18); color: #d0d0d0; border-color: rgba(108,117,125,0.5); }
.rel-hostile { background: rgba(220,53,69,0.18); color: #ffb3bb; border-color: rgba(220,53,69,0.55); }
.val-pos { color: #8ee4a4; font-weight: 600; }
.val-neg { color: #ff9aa2; font-weight: 600; }
.val-zero { color: #d0d0d0; }
</style>

```{python}
#| label: weights
#| echo: false
#| output: asis

if meta:
    print(f"<div><strong>Data (√∫ltimo sync):</strong> {meta.get('date')}</div>")
    if reference_date_daily:
        print(f"<div><strong>Querid√¥metro base (di√°rio):</strong> {reference_date_daily} (rolling 3d)</div>")
    if reference_date_paredao:
        print(f"<div><strong>Querid√¥metro base (pared√£o):</strong> {reference_date_paredao} (rolling 3d)</div>")
    print(f"<div><strong>Acumula√ß√£o:</strong> sem decay ‚Äî todos os eventos acumulam com peso integral</div>")
    print("<div style='margin-top:0.6rem;'><strong>Pesos (resumo)</strong></div>")
    print(f"<div>Querid√¥metro: {meta.get('weights', {}).get('queridometro')}</div>")
    print(f"<div>Power events: {meta.get('weights', {}).get('power_events')}</div>")
    print(f"<div>Sincer√£o: {meta.get('weights', {}).get('sincerao')}</div>")
    print(f"<div>VIP: {meta.get('weights', {}).get('vip')}</div>")
    print(f"<div>Votos: {meta.get('weights', {}).get('votes')}</div>")
    print(f"<div>Visibilidade: {meta.get('weights', {}).get('visibility_factor')}</div>")
else:
    print("<div>Sem metadados dispon√≠veis.</div>")
```

## Pares (A ‚Üí B) ‚Äî vis√£o di√°ria

<p class="text-muted">Tabela di√°ria ‚Äî querid√¥metro usa 70% janela reativa (3d) + 30% mem√≥ria de sequ√™ncia + penalidade de ruptura. Eventos acumulam sem decay (peso integral). üíî = alian√ßa rompida.</p>

```{python}
#| label: pairs-table
#| echo: false
#| output: asis

if pairs_daily_df.empty:
    print("Nenhum par encontrado.")
else:
    pairs_daily_df = pairs_daily_df.sort_values(["Ator", "Score"], ascending=[True, False])
    print(pairs_daily_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="pairsTable"))
```

## Detalhes por participante

```{python}
#| label: pairs-by-actor
#| echo: false
#| output: asis

if pairs_daily_df.empty:
    print("Nenhum par encontrado.")
else:
    for actor in sorted(pairs_daily_df["Ator"].unique()):
        sub = pairs_daily_df[pairs_daily_df["Ator"] == actor].copy()
        sub = sub.sort_values("Score", ascending=False)
        print(f"<details style='margin: 0.4rem 0;'><summary><strong>{actor}</strong></summary>")
        print(sub.to_html(index=False, classes="table table-sm table-dark", escape=False))
        print("</details>")
```

## Edges individuais (eventos e votos)

```{python}
#| label: edges-table
#| echo: false
#| output: asis

if edges_df.empty:
    print("Nenhum edge registrado.")
else:
    edges_df = edges_df.sort_values(["Semana", "Tipo", "Ator"], ascending=[False, True, True])
    print(edges_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="edgesTable"))
```

<script>
(function() {
  function sortTable(table, colIndex, asc) {
    const tbody = table.tBodies[0];
    if (!tbody) return;
    const rows = Array.from(tbody.rows);
    rows.sort((a, b) => {
      const textA = (a.cells[colIndex] || {}).innerText || '';
      const textB = (b.cells[colIndex] || {}).innerText || '';
      const numA = parseFloat(textA.replace(',', '.').replace('%', '').trim());
      const numB = parseFloat(textB.replace(',', '.').replace('%', '').trim());
      const bothNumeric = !isNaN(numA) && !isNaN(numB) && textA.trim() !== '' && textB.trim() !== '';
      if (bothNumeric) {
        return asc ? (numA - numB) : (numB - numA);
      }
      const cmp = textA.localeCompare(textB, 'pt-BR', {sensitivity: 'base'});
      return asc ? cmp : -cmp;
    });
    rows.forEach(r => tbody.appendChild(r));
  }

  function initSortableHeaders() {
    document.querySelectorAll('table.table-dark').forEach(table => {
      const headers = table.querySelectorAll('thead th');
      headers.forEach((th, idx) => {
        th.style.cursor = 'pointer';
        th.style.userSelect = 'none';
        th.title = 'Clique para ordenar';
        th.dataset.sortDir = 'none';
        th.addEventListener('click', () => {
          // Toggle direction: none ‚Üí desc ‚Üí asc ‚Üí desc ‚Ä¶
          const dir = th.dataset.sortDir === 'desc' ? 'asc' : 'desc';
          // Reset all headers in this table
          headers.forEach(h => {
            h.dataset.sortDir = 'none';
            h.textContent = h.textContent.replace(/ [‚Üë‚Üì]$/, '');
          });
          th.dataset.sortDir = dir;
          th.textContent = th.textContent + (dir === 'asc' ? ' ‚Üë' : ' ‚Üì');
          sortTable(table, idx, dir === 'asc');
        });
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSortableHeaders);
  } else {
    initSortableHeaders();
  }
})();
</script>

## Votos / Indica√ß√µes vs Querid√¥metro (semana exibida)

```{python}
#| label: events-vs-querido
#| echo: false
#| output: asis

if events_vs_df.empty:
    print("Nenhum evento/voto cr√≠tico registrado na semana.")
else:
    events_vs_df = events_vs_df.sort_values(["Tipo", "Ator"], ascending=[True, True])
    print(events_vs_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="eventsTable"))
```
## Pares eliminados (pairs_all)

<p class="text-muted">Pares envolvendo participantes eliminados/desistentes. Q_base usa √∫ltimo snapshot antes da sa√≠da.</p>

```{python}
#| label: pairs-eliminated
#| echo: false
#| output: asis

if relations_pairs_all:
    elim_rows = []
    for actor, targets in relations_pairs_all.items():
        for target, rec in targets.items():
            if rec.get("active_pair", True):
                continue
            comps = rec.get("components", {})
            q_score = comps.get("queridometro", 0.0)
            score = rec.get("score", 0.0)
            rel_label, rel_class = classify_relation(score)
            elim_rows.append({
                "Ator": actor,
                "Alvo": target,
                "Rela√ß√£o": f"<span class='rel-pill {rel_class}'>{rel_label}</span>",
                "Q (3d)": fmt_score(q_score),
                "Power": fmt_score(comps.get("power_event", 0.0)),
                "Sincer√£o": fmt_score(comps.get("sincerao", 0.0)),
                "VIP": fmt_score(comps.get("vip", 0.0)),
                "Voto": fmt_score(comps.get("vote", 0.0)),
                "Score": fmt_score(score),
            })
    if elim_rows:
        elim_df = pd.DataFrame(elim_rows).sort_values(["Score"], ascending=[True])
        print(f"<div class='text-muted'>{len(elim_rows)} pares com pelo menos 1 participante eliminado/desistente</div>")
        print(elim_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="elimPairsTable"))
    else:
        print("<p class='text-muted'>Nenhum par com participantes eliminados encontrado.</p>")
else:
    print("<p class='text-muted'>pairs_all n√£o dispon√≠vel.</p>")
```

## Contradi√ß√µes (voto vs querid√¥metro)

<p class="text-muted">Casos em que A deu rea√ß√£o positiva (Q > 0) a B, mas votou para elimin√°-lo. Taxa de contradi√ß√£o reflete a dissocia√ß√£o entre emoji secreto e voto real.</p>

```{python}
#| label: contradictions
#| echo: false
#| output: asis

if contradictions:
    total = contradictions.get("total", 0)
    total_votes = contradictions.get("total_vote_edges", 0)
    rate = contradictions.get("rate", 0)
    print(f"<div><strong>Contradi√ß√µes:</strong> {total} de {total_votes} votos ({rate:.0%})</div>")

    ctx = contradictions.get("context_notes", {})
    if ctx.get("week_1"):
        print(f"<div class='text-muted' style='margin-top:0.3rem;font-size:0.85rem;'>‚ö†Ô∏è Semana 1: {ctx['week_1']}</div>")

    entries = contradictions.get("vote_vs_queridometro", [])
    if entries:
        rows = []
        for e in entries:
            rows.append({
                "Semana": e.get("week"),
                "Ator": e.get("actor"),
                "Alvo": e.get("target"),
                "Q (base)": fmt_score(e.get("queridometro", 0)),
                "Peso voto": fmt_score(e.get("vote_weight", 0)),
                "Tipo voto": e.get("vote_kind", ""),
            })
        cdf = pd.DataFrame(rows).sort_values(["Semana", "Ator"])
        print(cdf.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="contradictionsTable"))
else:
    print("<p class='text-muted'>Sem dados de contradi√ß√£o.</p>")
```

## Impacto recebido (por participante)

<p class="text-muted">Total de peso de edges recebidas (incoming) por cada participante, incluindo eliminados.</p>

```{python}
#| label: received-impact
#| echo: false
#| output: asis

if received_impact:
    ri_rows = []
    for name, rec in sorted(received_impact.items(), key=lambda x: x[1].get("total", 0)):
        ri_rows.append({
            "Participante": name,
            "Positivo": fmt_score(rec.get("positive", 0)),
            "Negativo": fmt_score(rec.get("negative", 0)),
            "Total": fmt_score(rec.get("total", 0)),
            "Edges": rec.get("count", 0),
        })
    ri_df = pd.DataFrame(ri_rows)
    print(ri_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="receivedImpactTable"))
else:
    print("<p class='text-muted'>Sem dados de impacto recebido.</p>")
```

## Blocos de vota√ß√£o

<p class="text-muted">Semanas com 4+ participantes votando no mesmo alvo ‚Äî sinal de vota√ß√£o em bloco.</p>

```{python}
#| label: voting-blocs
#| echo: false
#| output: asis

if voting_blocs:
    for bloc in voting_blocs:
        voters = ", ".join(bloc.get("voters", []))
        print(f"<div style='margin:0.4rem 0;'><strong>Semana {bloc.get('week')}</strong> ‚Äî "
              f"<span class='val-neg'>{bloc.get('count')} votos</span> em <strong>{bloc.get('target')}</strong>"
              f"<br><span class='text-muted'>{voters}</span></div>")
else:
    print("<p class='text-muted'>Nenhum bloco de vota√ß√£o detectado (m√≠n. 4 votos no mesmo alvo).</p>")
```

## Rupturas de Alian√ßa (Streak Breaks)

<p class="text-muted">Sequ√™ncias de 5+ dias de ‚ù§Ô∏è que viraram negativo ‚Äî sinal de "confian√ßa quebrada".</p>

```{python}
#| label: streak-breaks
#| echo: false
#| output: asis

if streak_breaks:
    for b in streak_breaks:
        sev_icon = "üî¥" if b.get("severity") == "strong" else "üü°"
        emoji_label = b.get("new_emoji", "")
        print(
            f"<div style='margin:0.4rem 0;'>{sev_icon} <strong>{b['giver']}</strong> ‚Üí "
            f"<strong>{b['receiver']}</strong>: {b['previous_streak']}d ‚ù§Ô∏è ‚Üí {emoji_label} "
            f"<span class='text-muted'>({b.get('date', '')})</span></div>"
        )
else:
    print("<p class='text-muted'>Nenhuma ruptura de alian√ßa detectada (m√≠n. 5 dias de ‚ù§Ô∏è seguidos).</p>")
```

## Percep√ß√£o do Poder: L√≠der/Anjo

<p class="text-muted">Como a casa reage (no querid√¥metro secreto) quando algu√©m ganha L√≠der ou Anjo? Compara a m√©dia de ‚ù§Ô∏è e negativos recebidos antes, durante e depois de cada per√≠odo de poder.</p>

```{python}
#| label: power-perception
#| echo: false
#| output: asis

def get_daily_snapshot_map():
    """Group snapshots by date, keep last per day."""
    by_date = {}
    for fp, date in snapshots:
        by_date[date] = fp
    return by_date

def compute_reception_metrics(filepath, name):
    """Load snapshot, compute hearts/negatives received for one participant."""
    participants_list, _ = load_snapshot(filepath)
    p = next((p for p in participants_list if p.get("name") == name), None)
    if not p:
        return None
    hearts = 0
    negatives = 0
    total = 0
    for rxn in p.get("characteristics", {}).get("receivedReactions", []):
        label = rxn.get("label", "")
        amount = rxn.get("amount", 0) or 0
        total += amount
        if label in POSITIVE:
            hearts += amount
        elif label in MILD_NEGATIVE or label in STRONG_NEGATIVE:
            negatives += amount
    return {"hearts": hearts, "negatives": negatives, "total": total}

def avg_metrics(metrics_list):
    """Average a list of metric dicts."""
    valid = [m for m in metrics_list if m]
    if not valid:
        return None
    n = len(valid)
    return {
        "hearts": sum(m["hearts"] for m in valid) / n,
        "negatives": sum(m["negatives"] for m in valid) / n,
        "total": sum(m["total"] for m in valid) / n,
    }

def fmt_metrics(m):
    """Format metrics as HTML string."""
    if not m or m["total"] == 0:
        return "N/A"
    h_pct = m["hearts"] / m["total"] * 100
    n_pct = m["negatives"] / m["total"] * 100
    return f"‚ù§Ô∏è {m['hearts']:.0f} ({h_pct:.0f}%) ¬∑ üêç {m['negatives']:.0f} ({n_pct:.0f}%)"

def fmt_delta(before, during):
    """Format delta between two metric windows."""
    if not before or not during or before["total"] == 0 or during["total"] == 0:
        return "N/A"
    dh = during["hearts"] - before["hearts"]
    dn = during["negatives"] - before["negatives"]
    dh_pct = (during["hearts"]/during["total"] - before["hearts"]/before["total"]) * 100
    dn_pct = (during["negatives"]/during["total"] - before["negatives"]/before["total"]) * 100
    return f"{dh:+.0f} ‚ù§Ô∏è ({dh_pct:+.0f}pp)<br>{dn:+.0f} neg ({dn_pct:+.0f}pp)"

def detect_role_periods(role_name):
    """Parse roles_daily to find (name, start_date, end_date) periods."""
    roles_data = json.loads(Path("data/derived/roles_daily.json").read_text(encoding="utf-8"))
    periods = []
    current_holder = None
    current_start = None
    last_date = None
    for entry in roles_data["daily"]:
        date = entry["date"]
        holders = entry["roles"].get(role_name, [])
        holder = holders[0] if holders else None
        if holder != current_holder:
            if current_holder and current_start:
                periods.append((current_holder, current_start, last_date))
            current_holder = holder
            current_start = date if holder else None
        last_date = date
    if current_holder and current_start:
        periods.append((current_holder, current_start, last_date))
    return periods

daily_map = get_daily_snapshot_map()
all_dates = sorted(daily_map.keys())

rows_power = []
for role_name, role_label, role_emoji in [("L√≠der", "L√≠der", "üëë"), ("Anjo", "Anjo", "üòá")]:
    periods = detect_role_periods(role_name)
    for holder, start, end in periods:
        # Before: last 2 dates before start
        before_dates = [d for d in all_dates if d < start][-2:]
        # During: dates in [start, end]
        during_dates = [d for d in all_dates if start <= d <= end]
        # After: first 2 dates after end
        after_dates = [d for d in all_dates if d > end][:2]

        before_metrics = avg_metrics([compute_reception_metrics(daily_map[d], holder) for d in before_dates if d in daily_map])
        during_metrics = avg_metrics([compute_reception_metrics(daily_map[d], holder) for d in during_dates if d in daily_map])

        is_ongoing = (end == all_dates[-1]) if all_dates else False
        if is_ongoing:
            after_str = "<em>Em andamento</em>"
            delta_str = fmt_delta(before_metrics, during_metrics)
        else:
            after_metrics = avg_metrics([compute_reception_metrics(daily_map[d], holder) for d in after_dates if d in daily_map])
            after_str = fmt_metrics(after_metrics)
            delta_str = fmt_delta(before_metrics, during_metrics)

        n_days = len(during_dates)
        rows_power.append({
            "Poder": f"{role_emoji} {role_label}",
            "Participante": holder,
            "Per√≠odo": f"{start} ‚Üí {end}",
            "Dias": n_days,
            "Antes": fmt_metrics(before_metrics),
            "Durante": fmt_metrics(during_metrics),
            "Depois": after_str,
            "Œî Durante‚àíAntes": delta_str,
        })

if rows_power:
    power_df = pd.DataFrame(rows_power)
    print(power_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="powerPerceptionTable"))
else:
    print("<p class='text-muted'>Sem per√≠odos de L√≠der/Anjo detectados.</p>")
```

## Impacto Dirigido: Rea√ß√µes antes/depois de eventos

<p class="text-muted">Como o querid√¥metro muda entre ator‚Üîalvo antes e depois de eventos dirigidos (indica√ß√£o, contragolpe, monstro, veto, etc.)? Mostra a rea√ß√£o espec√≠fica que cada um dava ao outro.</p>

```{python}
#| label: directed-impact
#| echo: false
#| output: asis

# Load all directed events
manual_path = Path("data/manual_events.json")
auto_path = Path("data/derived/auto_events.json")

directed_events = []

# Manual power events
if manual_path.exists():
    manual = json.loads(manual_path.read_text(encoding="utf-8"))
    for ev in manual.get("power_events", []):
        etype = ev.get("type", "")
        actor = ev.get("actor", "")
        target = ev.get("target", "")
        # Skip non-directed, self-targeted, multi-actor, system actors
        if not actor or not target or actor == target:
            continue
        if " + " in actor:
            continue
        if ev.get("self") or ev.get("self_inflicted"):
            continue
        skip_types = {"ganha_ganha_escolha", "emparedado", "bate_volta"}
        if etype in skip_types:
            continue
        system_actors = {"Prova do L√≠der", "Big Fone", "Din√¢mica da casa", "Prova do Anjo", "Prova Bate e Volta"}
        if actor in system_actors:
            continue
        directed_events.append({
            "date": ev.get("date"),
            "type": etype,
            "actor": actor,
            "target": target,
            "source": ev.get("source", ""),
        })

# Auto events (monstro mainly ‚Äî lider/anjo have system actors)
if auto_path.exists():
    auto = json.loads(auto_path.read_text(encoding="utf-8"))
    for ev in auto.get("events", []):
        etype = ev.get("type", "")
        actor = ev.get("actor", "")
        target = ev.get("target", "")
        if not actor or not target or actor == target:
            continue
        system_actors = {"Prova do L√≠der", "Big Fone", "Din√¢mica da casa", "Prova do Anjo", "Prova Bate e Volta"}
        if actor in system_actors:
            continue
        if etype in {"monstro"}:
            directed_events.append({
                "date": ev.get("date"),
                "type": etype,
                "actor": actor,
                "target": target,
                "source": ev.get("source", ""),
            })

# Deduplicate by (date, type, actor, target)
seen = set()
unique_events = []
for ev in directed_events:
    key = (ev["date"], ev["type"], ev["actor"], ev["target"])
    if key not in seen:
        seen.add(key)
        unique_events.append(ev)
unique_events.sort(key=lambda e: (e["date"], e["type"]))

# Build reaction changes
rows_directed = []
for ev in unique_events:
    event_date = ev["date"]
    actor = ev["actor"]
    target = ev["target"]
    etype = ev["type"]
    emoji = POWER_EVENT_EMOJI.get(etype, "")

    # Before: last snapshot date strictly before event date
    before_dates = [d for d in all_dates if d < event_date]
    # After: first snapshot date >= event date
    after_dates = [d for d in all_dates if d >= event_date]

    before_date = before_dates[-1] if before_dates else None
    after_date = after_dates[0] if after_dates else None

    # If before == after (event on snapshot day), push before back one more
    if before_date and after_date and before_date == after_date:
        before_dates_strict = [d for d in all_dates if d < before_date]
        before_date = before_dates_strict[-1] if before_dates_strict else None

    def get_reaction_pair(date_key, a, b):
        if not date_key or date_key not in daily_map:
            return "‚Äî", "‚Äî"
        ps, _ = load_snapshot(daily_map[date_key])
        mat = _get_matrix_for_date(date_key, ps)
        names_in = {p.get("name") for p in ps}
        ab_label = mat.get((a, b), "")
        ba_label = mat.get((b, a), "")
        ab_str = f"{REACTION_EMOJI.get(ab_label, '')} {ab_label}".strip() if ab_label else ("‚Äî" if a in names_in and b in names_in else "‚Äî <em>(saiu)</em>")
        ba_str = f"{REACTION_EMOJI.get(ba_label, '')} {ba_label}".strip() if ba_label else ("‚Äî" if a in names_in and b in names_in else "‚Äî <em>(saiu)</em>")
        return ab_str, ba_str

    ab_before, ba_before = get_reaction_pair(before_date, actor, target)
    ab_after, ba_after = get_reaction_pair(after_date, actor, target)

    # Flag notable changes
    def classify_reaction(label_str):
        if "Cora√ß√£o" in label_str and "partido" not in label_str:
            return "positive"
        if any(neg in label_str for neg in ["Cobra", "Alvo", "V√¥mito", "Mentiroso"]):
            return "strong_neg"
        if any(neg in label_str for neg in ["Planta", "Mala", "Biscoito", "partido"]):
            return "mild_neg"
        return "unknown"

    signals = []
    # Target turned hostile toward actor?
    ba_cls_before = classify_reaction(ba_before)
    ba_cls_after = classify_reaction(ba_after)
    if ba_cls_before == "positive" and ba_cls_after in ("strong_neg", "mild_neg"):
        signals.append("üî• Alvo retaliou")
    elif ba_cls_before in ("strong_neg", "mild_neg") and ba_cls_after in ("strong_neg", "mild_neg"):
        signals.append("üßä Hostilidade mantida")
    # Actor changed toward target?
    ab_cls_before = classify_reaction(ab_before)
    ab_cls_after = classify_reaction(ab_after)
    if ab_cls_before == "positive" and ab_cls_after in ("strong_neg", "mild_neg"):
        signals.append("‚ö° Ator rompeu")
    # Bidirectional escalation
    if (ba_cls_after in ("strong_neg", "mild_neg") and ab_cls_after in ("strong_neg", "mild_neg")
            and (ba_cls_before == "positive" or ab_cls_before == "positive")):
        signals.append("üí£ Escalada m√∫tua")

    signal_str = "<br>".join(signals) if signals else "‚Äî"

    rows_directed.append({
        "Data": event_date,
        "Evento": f"{emoji} {etype}",
        "Ator": actor,
        "Alvo": target,
        "Ator‚ÜíAlvo (antes)": ab_before,
        "Ator‚ÜíAlvo (depois)": ab_after,
        "Alvo‚ÜíAtor (antes)": ba_before,
        "Alvo‚ÜíAtor (depois)": ba_after,
        "Sinal": signal_str,
    })

if rows_directed:
    dir_df = pd.DataFrame(rows_directed)
    print(dir_df.to_html(index=False, classes="table table-sm table-dark", escape=False, table_id="directedImpactTable"))
else:
    print("<p class='text-muted'>Nenhum evento dirigido encontrado.</p>")
```

## Observa√ß√µes sobre timing

<div class="text-muted" style="font-size: 0.9rem; line-height: 1.6;">
<ul>
<li><strong>Querid√¥metro</strong> atualiza ~10h-12h BRT (ap√≥s o Raio-X). L√≠der √© decidido domingo √† noite ‚Üí primeira mudan√ßa vis√≠vel aparece na ter√ßa.</li>
<li><strong>Anjo</strong> tem ciclo curto (~1-2 dias), tornando as janelas "antes/depois" mais ruidosas.</li>
<li><strong>Querid√¥metro √© SECRETO</strong> ‚Äî mudan√ßas refletem sentimento genu√≠no, n√£o performance. Mas eventos p√∫blicos (indica√ß√£o, monstro) s√£o conhecidos por todos.</li>
<li><strong>Amostra pequena</strong>: 3 ciclos de L√≠der, 2 de Anjo, ~15 eventos dirigidos. Tend√™ncias s√£o indicativas, n√£o estatisticamente significativas.</li>
<li><strong>"Antes" e "depois"</strong> comparam snapshots adjacentes ‚Äî pode incluir efeito de outros eventos simult√¢neos.</li>
</ul>
</div>

## Badge vs Realidade (Pared√µes)

```{python}
#| label: badge-vs-reality
#| echo: false
#| output: asis

# Load precomputed badge data
_pb_path = Path("data/derived/paredao_badges.json")
paredao_badges_data = json.load(open(_pb_path, encoding="utf-8")) if _pb_path.exists() else {}
paredoes_data = json.loads(Path("data/paredoes.json").read_text(encoding="utf-8")) if Path("data/paredoes.json").exists() else {}

rows_all = []
for par in paredoes_data.get("paredoes", []) if paredoes_data else []:
    numero = par.get("numero")
    data_form = par.get("data_formacao") or par.get("data")
    if not numero or not data_form:
        continue
    badge_entry = paredao_badges_data.get("by_paredao", {}).get(str(numero), {})
    badges = badge_entry.get("badges", [])
    if not badges:
        continue
    df = pd.DataFrame([{
        "Participante": b["participante"],
        "Votos (casa)": b["votos_casa"],
        "Indica√ß√µes": b["indicacoes"],
        "Eleg√≠vel voto": "sim" if b["elegivel_voto"] else "n√£o",
        "Vulnerabilidade": b["vulnerabilidade"],
        "Impacto Negativo": b["impacto_negativo"],
        "Impact score": b["impact_score"],
        "Falsos amigos": b["falsos_amigos"],
    } for b in badges])
    df.insert(0, "Pared√£o", f"{numero}¬∫ ({data_form})")
    rows_all.append(df)

if not rows_all:
    print("Sem dados de pared√£o para comparar.")
else:
    all_df = pd.concat(rows_all, ignore_index=True)
    print(all_df.to_html(index=False, classes="table table-sm table-dark", escape=False))

    # Contradi√ß√µes
    print("\n### Contradi√ß√µes (badge vs realidade)\n")
    vuln_no_votes = all_df[(all_df["Votos (casa)"] == 0) & (all_df["Indica√ß√µes"] == 0) & (all_df["Eleg√≠vel voto"] == "sim")]
    vuln_no_votes = vuln_no_votes[vuln_no_votes["Vulnerabilidade"].isin(["üü† VULNER√ÅVEL", "üî¥ MUITO VULNER√ÅVEL"])]
    if vuln_no_votes.empty:
        print("<p class='text-muted'>Nenhum vulner√°vel sem votos nesta forma√ß√£o.</p>")
    else:
        print("<p class='text-muted'>Vulner√°veis sem votos (surpresa n√£o se confirmou):</p>")
        print(vuln_no_votes[["Pared√£o", "Participante", "Vulnerabilidade", "Votos (casa)"]]
              .to_html(index=False, classes="table table-sm table-dark", escape=False))

    prot_with_votes = all_df[(all_df["Votos (casa)"] >= 3) & (all_df["Eleg√≠vel voto"] == "sim")]
    prot_with_votes = prot_with_votes[prot_with_votes["Vulnerabilidade"].isin(["üü¢ PROTEGIDO", "üü° ATEN√á√ÉO"])]
    if prot_with_votes.empty:
        print("<p class='text-muted'>Nenhum protegido/aten√ß√£o com muitos votos.</p>")
    else:
        print("<p class='text-muted'>Protegidos/aten√ß√£o com muitos votos (voto coletivo/bloco):</p>")
        print(prot_with_votes[["Pared√£o", "Participante", "Vulnerabilidade", "Votos (casa)"]]
              .to_html(index=False, classes="table table-sm table-dark", escape=False))
```

## Retro: Big Fone Consenso (Semana 3)

Os 3 atendentes do Big Fone (Juliano Floss, Babu Santana, Marcelo) escolheram **Jonas Sulzbach** por consenso.
O scoring previu corretamente? Os componentes fazem sentido?

```{python}
#| label: big-fone-retro
#| echo: false
#| output: asis

# Load consensus analysis (relations already loaded as `relations` in setup block)
_idx_path = Path("data/derived/index_data.json")
bfc = None
if _idx_path.exists():
    bfc = json.load(open(_idx_path, encoding="utf-8")).get("big_fone_consensus")

ACTUAL_TARGET = "Jonas Sulzbach"
pairs_daily = relations_pairs_daily

if not bfc or not bfc.get("attendees"):
    print("<p class='text-muted'>Dados do consenso n√£o dispon√≠veis.</p>")
else:
    attendees = bfc["attendees"]
    targets = bfc.get("targets", [])
    consensus_targets = [t for t in targets if t.get("tier") == "consensus"]
    by_score = sorted(consensus_targets, key=lambda t: t["combined_score"])
    actual = next((t for t in targets if t["name"] == ACTUAL_TARGET), None)
    rank_score = next((i for i, t in enumerate(by_score, 1) if t["name"] == ACTUAL_TARGET), None)

    html = '<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'

    # --- Verdict badge ---
    if rank_score == 1:
        verdict_color, verdict = "#2ecc71", "ACERTOU ‚Äî Jonas era #1 entre os alvos dos 3"
    elif rank_score and rank_score <= 2:
        verdict_color, verdict = "#f39c12", f"PR√ìXIMO ‚Äî Jonas era #{rank_score}"
    else:
        verdict_color, verdict = "#e74c3c", f"ERROU ‚Äî Jonas era #{rank_score}" if rank_score else "N√£o previsto"

    html += f'<div style="display:flex; align-items:center; gap:12px; margin-bottom:1rem; flex-wrap:wrap;">'
    html += f'<span style="background:{verdict_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.9em;">{verdict}</span>'
    html += f'<span style="color:#aaa; font-size:0.85em;">Alvo real: <strong style="color:#eee;">{ACTUAL_TARGET}</strong></span>'
    html += '</div>'

    # --- Main table: all consensus targets ranked, with per-attendee breakdown ---
    html += '<h4 style="color:#f0c040; margin:1rem 0 0.5rem;">Alvos vi√°veis: quem os 3 atacavam no querid√¥metro</h4>'
    html += '<p class="text-muted" style="font-size:0.8em; margin-bottom:0.5rem;">Somente alvos que <em>todos os 3</em> davam rea√ß√£o negativa. Ordenado pelo score combinado (soma dos 3 pair scores).</p>'

    html += '<div class="scroll-x">'
    html += '<table class="table-full table-md">'
    html += '<tr class="sep-bottom" style="border-color:#555;">'
    html += '<th class="tl text-light" style="padding:6px 8px;">Alvo</th>'
    for att in attendees:
        html += f'<th class="tc text-light" style="padding:6px 8px;">{att.split()[0]}</th>'
    html += '<th class="tc text-light" style="padding:6px 8px;">Combinado</th>'
    html += '<th class="tc text-light" style="padding:6px 8px;">Jonas‚Üíalvo?</th>'
    html += '</tr>'

    for t in by_score:
        is_actual = t["name"] == ACTUAL_TARGET
        row_bg = "background:#1a2a1a;" if is_actual else ""
        row_border = "border-left:3px solid #2ecc71;" if is_actual else ""

        html += f'<tr class="sep-bottom" style="{row_bg} {row_border}">'
        marker = " ‚úÖ" if is_actual else ""
        html += f'<td style="padding:6px 8px; color:#eee;"><strong>{t["name"]}</strong>{marker}</td>'

        # Per-attendee score + emoji
        for att in attendees:
            sc = t["scores"].get(att, 0)
            em = t["emojis"].get(att, "?")
            html += f'<td class="tc" style="padding:6px 8px;">{em} <span style="color:#e74c3c;">{sc:+.2f}</span></td>'

        # Combined
        html += f'<td class="tc text-neg" style="padding:6px 8px;">{t["combined_score"]:+.2f}</td>'

        # Mutual indicator
        is_mutual = t.get("is_fully_mutual", False)
        mutual_label = "‚öîÔ∏è M√∫tuo" if is_mutual else "‚ù§Ô∏è N√£o sabe"
        mutual_color = "#e74c3c" if is_mutual else "#f39c12"
        html += f'<td class="tc table-md" style="padding:6px 8px; color:{mutual_color};">{mutual_label}</td>'
        html += '</tr>'

    html += '</table></div>'

    # --- Component decomposition: what drove each attendee‚ÜíJonas score? ---
    if actual:
        html += '<h4 style="color:#f0c040; margin:1.2rem 0 0.5rem;">O que comp√µe cada score ‚Üí Jonas</h4>'
        html += '<p class="text-muted" style="font-size:0.8em; margin-bottom:0.5rem;">Decomposi√ß√£o do pair score de cada atendente para Jonas. Querid√¥metro √© o emoji di√°rio; os demais s√£o eventos acumulados.</p>'

        html += '<table class="table-full table-md">'
        html += '<tr class="sep-bottom" style="border-color:#555;">'
        html += '<th class="tl text-light" style="padding:6px 8px;">Atendente</th>'
        html += '<th class="tc text-light" style="padding:6px 8px;">Emoji</th>'

        # Collect all component keys across attendees
        all_comp_keys = []
        att_components = {}
        for att in attendees:
            comps = pairs_daily.get(att, {}).get(ACTUAL_TARGET, {}).get("components", {})
            att_components[att] = comps
            for k in comps:
                if k not in all_comp_keys:
                    all_comp_keys.append(k)

        comp_labels = {"queridometro": "Querid√¥metro", "power_event": "Eventos de poder",
                       "sincerao": "Sincer√£o", "vote": "Votos", "vip": "VIP/Xepa"}
        for ck in all_comp_keys:
            html += f'<th class="tc text-light" style="padding:6px 8px;">{comp_labels.get(ck, ck)}</th>'
        html += '<th class="tc text-light" style="padding:6px 8px;">Total</th>'
        html += '<th class="tc text-light" style="padding:6px 8px;">Jonas‚Üí</th>'
        html += '</tr>'

        for att in attendees:
            comps = att_components[att]
            total = sum(comps.values())
            em = actual["emojis"].get(att, "?")
            mutual_info = actual.get("mutual_hostility", {}).get(att, {})
            back_em = mutual_info.get("emoji", "?")
            back_neg = mutual_info.get("is_negative", False)
            back_color = "#e74c3c" if back_neg else "#2ecc71"

            html += f'<tr class="sep-bottom">'
            html += f'<td style="padding:6px 8px; color:#eee;">{att}</td>'
            html += f'<td class="tc" style="padding:6px 8px;">{em}</td>'
            for ck in all_comp_keys:
                v = comps.get(ck, 0)
                if v == 0:
                    html += f'<td class="tc" style="padding:6px 8px; color:#555;">‚Äî</td>'
                else:
                    c = "#e74c3c" if v < 0 else "#2ecc71"
                    html += f'<td class="tc" style="padding:6px 8px; color:{c}; font-weight:bold;">{v:+.2f}</td>'
            html += f'<td class="tc text-neg" style="padding:6px 8px;">{total:+.2f}</td>'
            html += f'<td class="tc" style="padding:6px 8px;"><span style="color:{back_color};">{back_em}</span></td>'
            html += '</tr>'

        html += '</table>'

        # Component totals
        comp_totals = {ck: sum(att_components[att].get(ck, 0) for att in attendees) for ck in all_comp_keys}
        total_all = sum(comp_totals.values())
        html += '<div class="table-md" style="margin-top:0.8rem; padding:0.6rem 0.8rem; background:#111; border-radius:6px; color:#aaa;">'
        html += '<strong class="text-light">Soma dos 3:</strong> '
        parts = []
        for ck in all_comp_keys:
            v = comp_totals[ck]
            label = comp_labels.get(ck, ck)
            c = "#e74c3c" if v < 0 else "#2ecc71"
            parts.append(f'{label} <span style="color:{c}; font-weight:bold;">{v:+.2f}</span>')
        html += ' + '.join(parts)
        html += f' = <strong style="color:#e74c3c;">{total_all:+.2f}</strong>'

        # Percentage breakdown
        if total_all != 0:
            html += '<br><strong class="text-light">Peso relativo:</strong> '
            pct_parts = []
            for ck in all_comp_keys:
                v = comp_totals[ck]
                pct = abs(v) / sum(abs(comp_totals[k]) for k in all_comp_keys) * 100
                label = comp_labels.get(ck, ck)
                pct_parts.append(f'{label} {pct:.0f}%')
            html += ' ¬∑ '.join(pct_parts)
        html += '</div>'

    # --- Compare: why Jonas and not the others? ---
    html += '<h4 style="color:#f0c040; margin:1.2rem 0 0.5rem;">Por que Jonas e n√£o os outros alvos?</h4>'
    html += '<div class="text-light table-md" style="line-height:1.7;">'

    if rank_score == 1 and len(by_score) > 1:
        gap = by_score[1]["combined_score"] - by_score[0]["combined_score"]
        runner_up = by_score[1]["name"]

        # What made Jonas different: check if all 3 had power_events against him
        jonas_power = sum(
            pairs_daily.get(att, {}).get(ACTUAL_TARGET, {}).get("components", {}).get("power_event", 0)
            for att in attendees
        )
        jonas_querido = sum(
            pairs_daily.get(att, {}).get(ACTUAL_TARGET, {}).get("components", {}).get("queridometro", 0)
            for att in attendees
        )

        html += f'<p>Jonas liderava com <strong>{actual["combined_score"]:+.2f}</strong>, '
        html += f'um gap de <strong>{gap:+.2f}</strong> para o 2¬∫ ({runner_up}).</p>'

        html += '<p><strong style="color:#e74c3c;">Fator decisivo: eventos de poder acumulados.</strong> '
        html += f'Jonas recebia {jonas_power:+.2f} de power_events dos 3 atendentes '
        html += f'(vs {jonas_querido:+.2f} do querid√¥metro sozinho). '

        # Compare with runner-up
        ru_power = sum(
            pairs_daily.get(att, {}).get(runner_up, {}).get("components", {}).get("power_event", 0)
            for att in attendees
        )
        ru_querido = sum(
            pairs_daily.get(att, {}).get(runner_up, {}).get("components", {}).get("queridometro", 0)
            for att in attendees
        )
        html += f'Em contraste, {runner_up} recebia {ru_power:+.2f} de power_events e {ru_querido:+.2f} do querid√¥metro. '
        html += 'Os eventos (Monstro recebido, indica√ß√µes anteriores) amplificaram a rejei√ß√£o que o querid√¥metro j√° mostrava.</p>'

    # Blind spot analysis
    if actual and not actual.get("is_fully_mutual"):
        blind_atts = [att for att in attendees
                      if not actual.get("mutual_hostility", {}).get(att, {}).get("is_negative", False)]
        if blind_atts:
            html += f'<p><strong style="color:#f39c12;">Ponto cego de Jonas:</strong> '
            html += f'dava ‚ù§Ô∏è para {", ".join(blind_atts)} ‚Äî a hostilidade era unilateral. '
            html += 'Jonas n√£o sabia que era alvo deles, o que tipifica uma indica√ß√£o-surpresa. '
            html += 'Alvos m√∫tuos (Brigido, Gabriela) tinham scores menores justamente porque a hostilidade rec√≠proca '
            html += 'pode inibir a a√ß√£o ‚Äî quando ambos se atacam, a tens√£o √© conhecida. '
            html += 'O ponto cego unilateral torna a a√ß√£o mais f√°cil para os atores.</p>'

    html += '</div>'

    # --- Nota sobre consensus_pct ---
    html += '<div class="text-muted" style="margin-top:0.8rem; padding:0.6rem 0.8rem; background:#222; border:1px solid #444; border-radius:6px; font-size:0.82em;">'
    html += '<strong style="color:#aaa;">Nota sobre consensus %:</strong> '
    html += 'Jonas era #3 por consensus_pct (54% vs 64% de Brigido/Gabriela). '
    html += 'Essa m√©trica mede "qual % de hipot√©ticos 3¬∫s atendentes concordariam" ‚Äî √∫til como an√°lise de robustez, '
    html += 'mas n√£o como preditor quando os atores j√° s√£o conhecidos. O combined score dos 3 atores reais √© a m√©trica correta.'
    html += '</div>'

    # --- Final verdict ---
    html += '<div style="background:#1a2a1a; border:1px solid #2ecc71; border-radius:8px; padding:0.8rem 1rem; margin-top:1rem;">'
    html += '<strong style="color:#2ecc71;">Veredicto:</strong> '
    if rank_score == 1:
        html += '<span class="text-light">O scoring <strong>acertou</strong>. Jonas era o alvo #1 dos 3 atendentes por larga margem. '
        html += 'A combina√ß√£o de querid√¥metro negativo + eventos de poder acumulados capturou corretamente a intensidade da rejei√ß√£o conjunta. '
        html += '<strong>Nenhum ajuste de pesos necess√°rio</strong> ‚Äî o sistema funcionou como esperado para este caso.</span>'
    elif rank_score and rank_score <= 2:
        html += f'<span class="text-light">O scoring chegou perto (#{rank_score}). Considerar se o peso de power_events est√° calibrado.</span>'
    else:
        html += '<span class="text-light">O scoring errou. Revisar pesos dos componentes ‚Äî especialmente a propor√ß√£o entre querid√¥metro e eventos.</span>'
    html += '</div>'

    html += '</div>'
    print(html)
```

## Retro: Votos vs Scoring (Pared√µes 1 & 2)

<p class="text-muted">Para cada pared√£o passado, compara o voto real de cada participante com o alvo previsto pelo scoring (o alvo mais negativo eleg√≠vel). Usa <code>pairs_daily</code> para ativos e <code>pairs_all</code> para eliminados/desistentes. <strong>Limita√ß√£o:</strong> usa scores <em>atuais</em> (Jan 31), n√£o congelados na data do pared√£o.</p>

```{python}
#| label: vote-prediction-retro
#| echo: false
#| output: asis

# --- Retro: compare pairs_daily predicted votes vs actual votes ---
# paredoes_data was already loaded in the badge-vs-reality block above
paredoes_file = paredoes_data

pairs_d = relations.get("pairs_daily", {})
pairs_all = relations.get("pairs_all", {})

html_retro = ""

retro_summary = []

for par in paredoes_file.get("paredoes", []):
    numero = par.get("numero")
    votos_casa = par.get("votos_casa", {})
    if not votos_casa:
        continue

    impedidos = set(par.get("impedidos_votar", []))
    anulados = set(par.get("votos_anulados", []))
    data_form = par.get("data_formacao", par.get("data", ""))

    exact = 0
    top3 = 0
    total_voters = 0
    rows_retro = []

    for voter, actual_target in votos_casa.items():
        if voter in impedidos or voter in anulados:
            continue

        # Get voter's pair scores ‚Äî try pairs_daily first, fall back to pairs_all
        voter_pairs = pairs_d.get(voter, {}) or pairs_all.get(voter, {})
        if not voter_pairs:
            rows_retro.append({
                "Votante": voter,
                "Voto real": actual_target,
                "Previsto (#1)": "‚Äî <em>(sem scores)</em>",
                "Score #1": "",
                "Rank do real": "‚Äî",
                "Score real": "‚Äî",
                "#2": "",
                "#3": "",
                "Acerto": "‚¨ú",
            })
            total_voters += 1
            continue

        # Build full target list: merge pairs_daily + pairs_all for this voter
        # so eliminated targets (e.g. Paulo Augusto) appear in the ranking
        merged_pairs = {}
        for t, rec in pairs_all.get(voter, {}).items():
            if t != voter:
                merged_pairs[t] = rec
        for t, rec in voter_pairs.items():
            if t != voter:
                merged_pairs[t] = rec  # pairs_daily overrides pairs_all

        # Sort targets by score ascending (most negative first = predicted vote)
        sorted_targets = sorted(merged_pairs.items(), key=lambda x: x[1].get("score", 0))

        predicted_target = sorted_targets[0][0] if sorted_targets else "‚Äî"
        predicted_score = sorted_targets[0][1].get("score", 0) if sorted_targets else 0

        # Find rank of actual target
        target_names = [t for t, _ in sorted_targets]
        if actual_target in target_names:
            actual_rank = target_names.index(actual_target) + 1
            actual_score = next(rec.get("score", 0) for t, rec in sorted_targets if t == actual_target)
        else:
            actual_rank = "‚Äî"
            actual_score = "‚Äî"

        is_exact = (predicted_target == actual_target)
        is_top3 = actual_rank != "‚Äî" and isinstance(actual_rank, int) and actual_rank <= 3

        if is_exact:
            exact += 1
        if is_top3:
            top3 += 1
        total_voters += 1

        choice2 = sorted_targets[1][0] if len(sorted_targets) > 1 else ""
        choice3 = sorted_targets[2][0] if len(sorted_targets) > 2 else ""

        acerto_icon = "‚úÖ" if is_exact else ("üü°" if is_top3 else "‚ùå")

        rows_retro.append({
            "Votante": voter,
            "Voto real": f"<strong>{actual_target}</strong>",
            "Previsto (#1)": f"<strong>{predicted_target}</strong>",
            "Score #1": fmt_score(predicted_score),
            "Rank do real": actual_rank if actual_rank != "‚Äî" else "‚Äî",
            "Score real": fmt_score(actual_score) if actual_score != "‚Äî" else "‚Äî",
            "#2": choice2,
            "#3": choice3,
            "Acerto": acerto_icon,
        })

    if not rows_retro:
        continue

    exact_pct = exact / total_voters * 100 if total_voters else 0
    top3_pct = top3 / total_voters * 100 if total_voters else 0

    # Count voters targeting eliminated participants (no scores available)
    no_score_voters = sum(1 for r in rows_retro if "sem scores" in str(r.get("Previsto (#1)", "")))
    scorable_voters = total_voters - no_score_voters
    exact_scorable_pct = exact / scorable_voters * 100 if scorable_voters else 0

    retro_summary.append({
        "paredao": numero,
        "exact": exact,
        "top3": top3,
        "total": total_voters,
        "exact_pct": exact_pct,
        "top3_pct": top3_pct,
        "scorable": scorable_voters,
        "exact_scorable_pct": exact_scorable_pct,
    })

    # Render summary card
    html_retro += f'<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
    html_retro += f'<h4 style="color:#f0c040; margin:0 0 0.8rem;">{numero}¬∫ Pared√£o ({data_form})</h4>'

    # Accuracy badges
    exact_color = "#2ecc71" if exact_pct >= 40 else ("#f39c12" if exact_pct >= 20 else "#e74c3c")
    top3_color = "#2ecc71" if top3_pct >= 60 else ("#f39c12" if top3_pct >= 40 else "#e74c3c")
    html_retro += '<div style="display:flex; gap:12px; flex-wrap:wrap; margin-bottom:0.8rem;">'
    html_retro += f'<span style="background:{exact_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.9em;">Exato: {exact}/{total_voters} ({exact_pct:.0f}%)</span>'
    html_retro += f'<span style="background:{top3_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.9em;">Top-3: {top3}/{total_voters} ({top3_pct:.0f}%)</span>'
    if no_score_voters > 0:
        html_retro += f'<span style="background:#555; color:#eee; padding:4px 12px; border-radius:6px; font-size:0.85em;">Excl. eliminados: {exact}/{scorable_voters} ({exact_scorable_pct:.0f}%)</span>'
    html_retro += '</div>'

    # Detail table
    retro_df = pd.DataFrame(rows_retro)
    html_retro += retro_df.to_html(index=False, classes="table table-sm table-dark", escape=False)
    html_retro += '</div>'

# Overall summary
if retro_summary:
    total_exact = sum(s["exact"] for s in retro_summary)
    total_top3 = sum(s["top3"] for s in retro_summary)
    total_all = sum(s["total"] for s in retro_summary)
    total_scorable = sum(s["scorable"] for s in retro_summary)

    html_retro += '<div style="background:#222; border:1px solid #555; border-radius:8px; padding:0.8rem 1rem; margin:1rem 0;">'
    html_retro += f'<strong style="color:#f0c040;">Resumo geral:</strong> '
    html_retro += f'Exato {total_exact}/{total_all} ({total_exact/total_all*100:.0f}%) ¬∑ '
    html_retro += f'Top-3 {total_top3}/{total_all} ({total_top3/total_all*100:.0f}%) ¬∑ '
    html_retro += f'Apenas participantes com scores: {total_exact}/{total_scorable} ({total_exact/total_scorable*100:.0f}% exato)'
    html_retro += '</div>'

# Methodology box
html_retro += '<div class="table-md" style="background:#111; border:1px solid #333; border-radius:8px; padding:0.8rem 1rem; margin:1rem 0; color:#aaa;">'
html_retro += '<strong class="text-light">Metodologia</strong><br>'
html_retro += '<ul style="margin:0.3rem 0 0;">'
html_retro += '<li><strong>Previs√£o:</strong> para cada votante, o alvo previsto √© o participante eleg√≠vel com o menor (mais negativo) score <code>pairs_daily</code> combinado.</li>'
html_retro += '<li><strong>Componentes do score:</strong> querid√¥metro (emoji di√°rio, 70% janela reativa 3d + 30% mem√≥ria de sequ√™ncia) + eventos acumulados (poder, votos, sincer√£o, VIP) sem decay.</li>'
html_retro += '<li><strong>Fonte dos scores:</strong> usa <code>pairs_daily</code> para participantes ativos e <code>pairs_all</code> (com querid√¥metro do √∫ltimo snapshot pr√©-sa√≠da) para eliminados/desistentes.</li>'
html_retro += '<li><strong>Limita√ß√µes:</strong> scores atuais incluem eventos p√≥s-pared√£o; n√£o modela voto estrat√©gico ou coordena√ß√£o de alian√ßas.</li>'
html_retro += '<li><strong>M√©tricas:</strong> Exato = previsto == real; Top-3 = real estava entre os 3 alvos mais negativos do votante.</li>'
html_retro += '</ul></div>'

print(html_retro)
```

## Previs√£o de Votos ‚Äî Modelo Aprimorado

<p class="text-muted">Previs√£o de votos da casa usando modelo de sentimento aprimorado com consenso de cluster, hist√≥rico de blocos e prote√ß√£o intra-cluster. Dados pr√©-computados em <code>vote_prediction.json</code>.</p>

```{python}
#| label: vote-prediction-enhanced
#| echo: false
#| output: asis

VOTE_PRED_FILE = Path("data/derived/vote_prediction.json")
vote_pred = json.loads(VOTE_PRED_FILE.read_text(encoding="utf-8")) if VOTE_PRED_FILE.exists() else {}
vp_meta = vote_pred.get("_metadata", {})
vp_by_paredao = vote_pred.get("by_paredao", {})
vp_cumulative = vote_pred.get("cumulative", {})

html_vp = ""

if not vp_by_paredao:
    html_vp += '<div style="background:#1a1a2e; border:1px solid #444; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
    html_vp += '<p class="text-muted">Arquivo <code>vote_prediction.json</code> n√£o encontrado. Execute <code>python scripts/build_derived_data.py</code>.</p>'
    html_vp += '</div>'
    print(html_vp)

else:
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # CUMULATIVE ACCURACY CARD
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    enh = vp_cumulative.get("enhanced", {})
    base = vp_cumulative.get("baseline", {})
    if enh.get("total"):
        enh_pct = enh["pct"]
        base_pct = base["pct"]
        diff = enh_pct - base_pct
        diff_str = f"+{diff:.1f}pp" if diff > 0 else f"{diff:.1f}pp" if diff < 0 else "=0"
        diff_color = "#2ecc71" if diff > 0 else ("#e74c3c" if diff < 0 else "#888")

        html_vp += '<div style="background:#1a2a1a; border:1px solid #2ecc71; border-radius:12px; padding:1.2rem; margin:1rem 0;">'
        html_vp += '<h4 style="color:#2ecc71; margin:0 0 0.8rem;">üìä Acur√°cia acumulada (todos os pared√µes com votos)</h4>'
        html_vp += '<div style="display:flex; gap:16px; flex-wrap:wrap;">'
        html_vp += f'<div class="tc" style="background:#222; padding:12px 20px; border-radius:8px;"><div style="color:#aaa; font-size:0.8em;">Modelo Aprimorado</div><div class="text-pos" style="font-size:1.8em;">{enh_pct:.1f}%</div><div class="text-muted table-md">{enh["correct"]}/{enh["total"]}</div></div>'
        html_vp += f'<div class="tc" style="background:#222; padding:12px 20px; border-radius:8px;"><div style="color:#aaa; font-size:0.8em;">Baseline (sentimento)</div><div style="color:#f39c12; font-size:1.8em; font-weight:bold;">{base_pct:.1f}%</div><div class="text-muted table-md">{base["correct"]}/{base["total"]}</div></div>'
        html_vp += f'<div class="tc" style="background:#222; padding:12px 20px; border-radius:8px;"><div style="color:#aaa; font-size:0.8em;">Diferen√ßa</div><div style="color:{diff_color}; font-size:1.8em; font-weight:bold;">{diff_str}</div><div class="text-muted table-md">aprimorado vs baseline</div></div>'
        html_vp += '</div></div>'

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # PER-PARED√ÉO SECTIONS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # paredoes_data already loaded in badge-vs-reality block above
    paredoes_list = paredoes_data.get("paredoes", [])

    for num_str in sorted(vp_by_paredao.keys(), key=int, reverse=True):
        par_pred = vp_by_paredao[num_str]
        par_status = par_pred["status"]
        formation_date = par_pred["formation_date"]
        elig = par_pred["eligibility"]
        predictions = par_pred["predictions"]
        aggregate = par_pred["aggregate"]
        retro = par_pred.get("retrospective")
        lider_pred = par_pred.get("lider_prediction")

        # Find real votes
        par_idx = int(num_str) - 1
        real_votes = paredoes_list[par_idx].get("votos_casa", {}) if par_idx < len(paredoes_list) else {}
        status_label = "Em andamento" if par_status == "em_andamento" else "Finalizado"
        status_icon = "üî¥" if par_status == "em_andamento" else "‚úÖ"

        html_vp += f'<div style="background:#1a1a2e; border:1px solid #555; border-radius:12px; padding:1.2rem; margin:1.5rem 0;">'
        html_vp += f'<h4 style="color:#f0c040; margin:0 0 0.8rem;">{status_icon} {num_str}¬∫ Pared√£o ‚Äî {formation_date} ({status_label})</h4>'

        # Game state
        html_vp += '<div class="table-md" style="display:flex; gap:12px; flex-wrap:wrap; margin-bottom:0.8rem;">'
        for reason_name, reason_text in elig["ineligible_reasons"].items():
            icon_map = {"L√≠der": "üëë", "Indicado do L√≠der": "üëë‚Üí", "Imunizado": "üõ°Ô∏è", "Din√¢mica": "üìû", "Contragolpe": "‚öîÔ∏è", "Anjo (autoimune)": "üòá"}
            icon = icon_map.get(reason_text, "üö´")
            html_vp += f'<span>{icon} {reason_name}: <strong>{reason_text}</strong></span>'
        html_vp += f'<span>üó≥Ô∏è Votantes: <strong>{len(elig["voters"])}</strong></span>'
        html_vp += '</div>'

        # L√≠der indication
        if lider_pred:
            lider_mark = "‚úÖ" if lider_pred.get("correct") else "‚ùå"
            lider_actual = lider_pred.get("actual", "?")
            html_vp += f'<div class="text-light" style="font-size:0.9em; margin-bottom:0.5rem;">{lider_mark} Indica√ß√£o do L√≠der: previu <strong>{lider_pred["predicted"]}</strong> ({lider_pred["score"]:+.2f}), real: <strong>{lider_actual}</strong></div>'

        # Retrospective accuracy badges
        if retro:
            ind = retro["individual"]
            hc = retro["high_confidence"]
            top2 = retro["top2_match"]
            baseline_acc = retro["baseline_accuracy"]

            acc_color = "#2ecc71" if ind["pct"] >= 60 else ("#f39c12" if ind["pct"] >= 40 else "#e74c3c")
            hc_color = "#2ecc71" if hc["pct"] >= 70 else ("#f39c12" if hc["pct"] >= 50 else "#e74c3c")
            top2_color = "#2ecc71" if top2 else "#e74c3c"

            html_vp += '<div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:0.8rem;">'
            html_vp += f'<span style="background:{acc_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.85em;">Voto a voto: {ind["correct"]}/{ind["total"]} ({ind["pct"]:.0f}%)</span>'
            html_vp += f'<span style="background:{hc_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.85em;">Alta confian√ßa: {hc["correct"]}/{hc["total"]} ({hc["pct"]:.0f}%)</span>'
            html_vp += f'<span style="background:{top2_color}; color:#fff; padding:4px 12px; border-radius:6px; font-weight:bold; font-size:0.85em;">Top-2: {"‚úÖ" if top2 else "‚ùå"}</span>'
            html_vp += f'<span style="background:#555; color:#eee; padding:4px 12px; border-radius:6px; font-size:0.85em;">Baseline: {baseline_acc:.0f}%</span>'
            html_vp += '</div>'

        # Vote concentration (predicted vs real)
        conc = aggregate["vote_concentration"]
        sorted_conc = sorted(conc.items(), key=lambda x: -x[1])

        html_vp += '<div style="display:flex; gap:20px; flex-wrap:wrap; margin-bottom:0.8rem;">'

        # Predicted concentration
        html_vp += '<div style="flex:1; min-width:250px;">'
        html_vp += '<h5 style="color:#aaa; margin:0 0 0.3rem; font-size:0.85em;">Previs√£o</h5>'
        max_v = sorted_conc[0][1] if sorted_conc else 1
        for i, (target, votes) in enumerate(sorted_conc[:5]):
            bar_w = int(votes / max_v * 120)
            bar_c = "#e74c3c" if i < 2 else "#555"
            html_vp += f'<div style="display:flex; align-items:center; gap:6px; font-size:0.85em; padding:2px 0;"><span style="min-width:120px; color:#eee;"><strong>{target}</strong></span><span class="tc" style="min-width:20px; font-weight:bold;">{votes}</span><div style="background:{bar_c}; height:12px; width:{bar_w}px; border-radius:3px;"></div></div>'
        html_vp += '</div>'

        # Real concentration
        if real_votes:
            real_count = Counter(real_votes.values())
            real_ranking = real_count.most_common()
            html_vp += '<div style="flex:1; min-width:250px;">'
            html_vp += '<h5 style="color:#aaa; margin:0 0 0.3rem; font-size:0.85em;">Real</h5>'
            max_r = real_ranking[0][1] if real_ranking else 1
            for i, (target, votes) in enumerate(real_ranking):
                bar_w = int(votes / max_r * 120)
                bar_c = "#2ecc71" if i < 2 else "#555"
                html_vp += f'<div style="display:flex; align-items:center; gap:6px; font-size:0.85em; padding:2px 0;"><span style="min-width:120px; color:#eee;"><strong>{target}</strong></span><span class="tc" style="min-width:20px; font-weight:bold;">{votes}</span><div style="background:{bar_c}; height:12px; width:{bar_w}px; border-radius:3px;"></div></div>'
            html_vp += '</div>'

        html_vp += '</div>'

        # Detailed vote table
        if real_votes:
            html_vp += '<details style="margin:0.5rem 0;"><summary style="cursor:pointer; color:#f0c040; font-size:0.9em;">üó≥Ô∏è Detalhe voto a voto</summary>'
            html_vp += '<div class="scroll-x" style="margin-top:0.5rem;">'

            vote_rows = []
            for voter in sorted(predictions.keys()):
                pred = predictions[voter]
                real = real_votes.get(voter)
                if not real:
                    continue
                match = pred["predicted"] == real
                conf = pred["confidence"]
                conf_color = "#2ecc71" if conf == "Alta" else ("#f39c12" if conf == "M√©dia" else "#e74c3c")
                gap = pred["gap"]

                # Show cluster adjustments if any
                top1 = pred["top3"][0] if pred["top3"] else {}
                adj_parts = []
                comps = top1.get("components", {})
                if comps.get("cluster_consensus", 0) != 0:
                    adj_parts.append(f"cluster: {comps['cluster_consensus']:+.2f}")
                if comps.get("bloc_history", 0) != 0:
                    adj_parts.append(f"bloco: {comps['bloc_history']:+.2f}")
                if comps.get("cluster_protection", 0) != 0:
                    adj_parts.append(f"prot: {comps['cluster_protection']:+.2f}")
                adj_str = f" ({', '.join(adj_parts)})" if adj_parts else ""

                vote_rows.append({
                    "": "‚úÖ" if match else "‚ùå",
                    "Votante": voter,
                    "Previsto": f"<strong>{pred['predicted']}</strong>",
                    "Real": f"<strong>{real}</strong>",
                    "Score": fmt_score(pred["score"]),
                    "Confian√ßa": f"<span style='color:{conf_color};'>{conf} ({gap:+.2f})</span>",
                    "Ajustes": adj_str,
                })

            if vote_rows:
                vote_df = pd.DataFrame(vote_rows)
                html_vp += vote_df.to_html(index=False, classes="table table-sm table-dark", escape=False)
            html_vp += '</div></details>'

        # Error analysis
        if retro and retro.get("errors"):
            errors = retro["errors"]
            html_vp += f'<details style="margin:0.5rem 0;"><summary style="cursor:pointer; color:#e74c3c; font-size:0.9em;">üí° An√°lise dos {len(errors)} erros</summary>'
            html_vp += '<div class="text-light" style="font-size:0.9em; line-height:1.8; margin-top:0.5rem;">'
            for err in errors:
                icon = "üé≤" if err["analysis"] == "gap m√≠nimo (coin flip)" else "ü§ù"
                html_vp += f'<p style="margin:0.3rem 0;">{icon} <strong>{err["voter"]}</strong>: previu <span style="color:#e74c3c;">{err["predicted"]}</span> ‚Üí votou <strong style="color:#2ecc71;">{err["actual"]}</strong> ({err["confidence"]}) ‚Äî {err["analysis"]}</p>'
            html_vp += '</div></details>'

        # Model adjustments breakdown
        has_adjustments = any(
            any(t.get("components", {}).get(k, 0) != 0
                for t in pred.get("top3", [])
                for k in ["cluster_consensus", "bloc_history", "cluster_protection"])
            for pred in predictions.values()
        )
        if has_adjustments:
            html_vp += '<details style="margin:0.5rem 0;"><summary style="cursor:pointer; color:#aaa; font-size:0.9em;">üîß Ajustes do modelo aprimorado</summary>'
            html_vp += '<div class="text-light table-md" style="margin-top:0.5rem;">'
            for voter in sorted(predictions.keys()):
                pred = predictions[voter]
                for t in pred.get("top3", []):
                    expl = t.get("explanation")
                    if expl:
                        html_vp += f'<div style="padding:2px 0;">{voter} ‚Üí {t["target"]}: {expl}</div>'
            html_vp += '</div></details>'

        html_vp += '</div>'

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # METHODOLOGY
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    config = vp_meta.get("config", {})
    html_vp += '<div class="table-md" style="background:#111; border:1px solid #333; border-radius:8px; padding:0.8rem 1rem; margin:1rem 0; color:#aaa;">'
    html_vp += '<strong class="text-light">Metodologia ‚Äî Modelo Aprimorado (v2)</strong><br>'
    html_vp += '<ul style="margin:0.3rem 0 0;">'
    html_vp += '<li><strong>Pass 1 (base):</strong> para cada votante, o alvo previsto √© o participante eleg√≠vel com o menor score combinado, usando a <strong>matriz de rea√ß√µes da data de forma√ß√£o</strong> (n√£o a data atual). O score combina: rea√ß√£o do votante‚Üíalvo (50%) + consist√™ncia hist√≥rica negativa (30%) + reciprocidade (20%) + eventos acumulados.</li>'
    html_vp += f'<li><strong>Pass 2 (consenso de cluster):</strong> se ‚â•{config.get("cluster_consensus_threshold", 0.5)*100:.0f}% dos membros do cluster preveem o mesmo alvo e o alvo est√° no top-3 do votante, aplica boost de at√© {config.get("cluster_consensus_max_boost", -0.8)}.</li>'
    html_vp += f'<li><strong>Hist√≥rico de blocos:</strong> se ‚â•{config.get("bloc_overlap_min", 3)} peers de blocos anteriores preveem o mesmo alvo (top-3), aplica boost de {config.get("bloc_overlap_boost", -0.3)}.</li>'
    html_vp += f'<li><strong>Prote√ß√£o intra-cluster:</strong> alvos do mesmo cluster recebem penalidade de +{config.get("same_cluster_penalty", 0.05)} (votos intra-cluster s√£o raros: 11-26%).</li>'
    html_vp += '<li><strong>Confian√ßa:</strong> gap entre o score do 1¬∫ e 2¬∫ alvo. Alta ‚â•0.5, M√©dia ‚â•0.2, Baixa &lt;0.2.</li>'
    html_vp += '<li><strong>Ancoragem temporal:</strong> cada pared√£o usa o snapshot de rea√ß√µes da sua <strong>data de forma√ß√£o</strong>, n√£o a data atual. Eventos (<code>power_event</code>, <code>sincerao</code>, <code>vote</code>) s√£o somados como acumulado hist√≥rico.</li>'
    html_vp += '</ul></div>'

    print(html_vp)
```

## Previs√£o ‚Äî Pr√≥ximo Pared√£o

```{python}
#| label: paredao-prediction
#| echo: false
#| output: asis

# ‚îÄ‚îÄ Detect current L√≠der + Anjo from roles_daily.json ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
_rd = json.loads(Path("data/derived/roles_daily.json").read_text(encoding="utf-8"))
_rd_daily = _rd.get("daily", [])
_rd_latest = _rd_daily[-1] if _rd_daily else {}
lider_list = _rd_latest.get("roles", {}).get("L√≠der", [])
anjo_list = _rd_latest.get("roles", {}).get("Anjo", [])
vip_list = _rd_latest.get("vip", [])
lider_name = lider_list[0] if lider_list else None

# ‚îÄ‚îÄ Load avatars from participants_index.json ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
_pix = json.loads(Path("data/derived/participants_index.json").read_text(encoding="utf-8"))
_pix_list = _pix.get("participants", _pix) if isinstance(_pix, dict) else _pix
_avatars = {p["name"]: p.get("avatar", "") for p in _pix_list}
_active_names = {p["name"] for p in _pix_list if p.get("active", True)}

html_pred = ""

if not lider_name:
    html_pred += '<div style="background:#1a1a2e; border:1px solid #444; border-radius:10px; '
    html_pred += 'padding:1.5rem; margin:1rem 0; text-align:center; color:#aaa; font-size:1.1em;">'
    html_pred += 'üè† <strong>Sem l√≠der ativo</strong> ‚Äî previs√£o de indica√ß√£o indispon√≠vel.</div>'
else:
    # ‚îÄ‚îÄ L√≠der's scores toward all participants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lider_scores = relations_pairs_daily.get(lider_name, {})

    # Eligible targets: active participants minus the L√≠der
    eligible = {name: entry for name, entry in lider_scores.items()
                if name in _active_names and name != lider_name}

    # Rank by score ascending (most negative = most likely nomination)
    ranked = sorted(eligible.items(), key=lambda x: x[1].get("score", 0))

    # ‚îÄ‚îÄ Anjo immunity info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    anjo_name = anjo_list[0] if anjo_list else None

    # Check if there's an active pared√£o with immunization info
    _par_data = json.loads(Path("data/paredoes.json").read_text(encoding="utf-8"))
    _par_list = _par_data.get("paredoes", [])
    _par_active = [p for p in _par_list if p.get("status") == "em_andamento"]
    imunizado_nome = None
    if _par_active:
        _imun = _par_active[-1].get("imunizado", {})
        imunizado_nome = _imun.get("quem") if _imun else None

    # ‚îÄ‚îÄ Load edges for detail rows ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    _all_edges = relations.get("edges", [])

    # ‚îÄ‚îÄ Build querid√¥metro history per pair (L√≠der ‚Üî each target) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    _slug_to_label = {
        "coracao": "Cora√ß√£o", "planta": "Planta", "cobra": "Cobra",
        "mala": "Mala", "biscoito": "Biscoito", "coracao-partido": "Cora√ß√£o partido",
        "alvo": "Alvo", "vomito": "V√¥mito", "mentiroso": "Mentiroso",
    }
    _emoji_map = {
        "Cora√ß√£o": "‚ù§Ô∏è", "Planta": "üå±", "Cobra": "üêç", "Mala": "üíº",
        "Biscoito": "üç™", "Cora√ß√£o partido": "üíî", "Alvo": "üéØ",
        "V√¥mito": "ü§Æ", "Mentiroso": "ü§•",
    }
    _querido_history = {}  # {(giver, receiver): [(date, label), ...]}
    _snap_files = get_all_snapshots()
    _by_date = {}
    for _fp, _ds in _snap_files:
        _by_date[_ds] = _fp
    for _date, _fp in sorted(_by_date.items()):
        _parts, _ = load_snapshot(_fp)
        _mat = _get_matrix_for_date(_date, _parts)
        for (g, r), lbl in _mat.items():
            if g == lider_name or r == lider_name:
                _querido_history.setdefault((g, r), []).append((_date, lbl))

    # ‚îÄ‚îÄ Component emoji mapping ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    comp_meta = {
        "queridometro": ("üêç", "#e74c3c", "#2ecc71"),  # emoji, color_neg, color_pos
        "power_event": ("‚öîÔ∏è", "#e74c3c", "#2ecc71"),
        "sincerao":    ("üì¢", "#e67e22", "#3498db"),
        "vote":        ("üó≥Ô∏è", "#e74c3c", "#2ecc71"),
        "vip":         ("üè†", "#3498db", "#3498db"),
        "anjo":        ("üòá", "#3498db", "#3498db"),
    }

    # Edge type display info
    _edge_display = {
        "power_event": ("‚öîÔ∏è", "Power Event"),
        "sincerao": ("üì¢", "Sincer√£o"),
        "vote": ("üó≥Ô∏è", "Voto"),
        "vip": ("üè†", "VIP"),
        "anjo": ("üòá", "Anjo"),
    }

    # ‚îÄ‚îÄ Summary box: top 3 targets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    top3 = ranked[:3]
    art = artigo(lider_name)

    html_pred += '<div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); '
    html_pred += 'border:2px solid #e74c3c; border-radius:12px; padding:1.2rem 1.5rem; margin:1rem 0;">'
    html_pred += f'<div style="font-size:1.2em; margin-bottom:0.8rem;">'
    html_pred += f'üéØ <strong style="color:#e74c3c;">Previs√£o de Indica√ß√£o d{art} L√≠der</strong></div>'

    html_pred += f'<div style="display:flex; align-items:center; gap:0.8rem; margin-bottom:1rem;">'
    html_pred += f'{avatar_img(lider_name, _avatars, size=40)}'
    html_pred += f'<span style="font-size:1.1em; color:#eee;"><strong>{lider_name}</strong> '
    html_pred += f'<span class="text-muted">‚Äî L√≠der da Semana {DISPLAY_WEEK_DAILY}</span></span></div>'

    html_pred += '<div style="display:flex; gap:0.8rem; flex-wrap:wrap; margin-bottom:0.8rem;">'
    for i, (tname, tentry) in enumerate(top3):
        sc = tentry.get("score", 0)
        color = "#e74c3c" if sc < -2 else "#e67e22" if sc < 0 else "#2ecc71"
        vip_tag = ' <span style="color:#3498db; font-size:0.75em;">VIP</span>' if tname in vip_list else ""
        html_pred += f'<div style="background:#111; border:1px solid {color}; border-radius:8px; '
        html_pred += f'padding:0.6rem 0.8rem; min-width:140px; flex:1;">'
        html_pred += f'<div class="text-muted" style="font-size:0.75em;">#{i+1} mais prov√°vel</div>'
        html_pred += f'<div style="display:flex; align-items:center; gap:0.4rem; margin:0.3rem 0;">'
        html_pred += f'{avatar_img(tname, _avatars, size=24)} '
        html_pred += f'<strong style="color:#eee;">{tname}</strong>{vip_tag}</div>'
        html_pred += f'<div style="color:{color}; font-size:1.1em; font-weight:bold;">{sc:+.2f}</div>'
        html_pred += '</div>'
    html_pred += '</div>'

    # Anjo note
    if anjo_name:
        html_pred += f'<div style="color:#3498db; font-size:0.9em;">üòá Anjo: <strong>{anjo_name}</strong>'
        if imunizado_nome:
            html_pred += f' ‚Äî imunizou <strong>{imunizado_nome}</strong> (bloqueado como alvo)'
        html_pred += '</div>'
    else:
        html_pred += '<div class="text-muted" style="font-size:0.9em;">üòá Anjo ainda n√£o definido esta semana</div>'

    html_pred += '</div>'

    # ‚îÄ‚îÄ Full ranking table ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    html_pred += '<div class="scroll-x" style="margin-top:1.2rem;">'
    html_pred += '<table class="table-full table-md">'
    html_pred += '<thead><tr style="border-bottom:2px solid #444;">'
    for hdr in ["#", "Participante", "Score", "Barra", "Componentes", "Reciprocidade", "Streak", "VIP"]:
        html_pred += f'<th class="tl" style="padding:0.5rem 0.4rem; color:#aaa; white-space:nowrap;">{hdr}</th>'
    html_pred += '</tr></thead><tbody>'

    # Find max absolute score for bar scaling
    max_abs = max((abs(e.get("score", 0)) for _, e in ranked), default=1) or 1

    for rank, (tname, tentry) in enumerate(ranked, 1):
        sc = tentry.get("score", 0)
        comps = tentry.get("components", {})
        streak_len = tentry.get("streak_len", 0)
        has_break = tentry.get("break", False)

        # Score color
        if sc < -2:
            sc_color = "#e74c3c"
        elif sc < 0:
            sc_color = "#e67e22"
        else:
            sc_color = "#2ecc71"

        # Row background: top 3 highlighted
        row_bg = "background:rgba(231,76,60,0.08);" if rank <= 3 else ""

        # Immunity flag
        is_immune = (tname == imunizado_nome)
        immune_tag = ' <span style="background:#3498db; color:#fff; font-size:0.7em; padding:1px 4px; border-radius:3px;">IMUNE</span>' if is_immune else ""

        html_pred += f'<tr class="sep-bottom" style="{row_bg}">'

        # Rank
        html_pred += f'<td class="cell-compact tc text-muted">{rank}</td>'

        # Name + avatar
        html_pred += f'<td class="cell-compact" style="white-space:nowrap;">'
        html_pred += f'{avatar_img(tname, _avatars, size=22)} '
        html_pred += f'<strong style="color:#eee;">{tname}</strong>{immune_tag}</td>'

        # Score
        html_pred += f'<td class="cell-compact" style="color:{sc_color}; font-weight:bold; font-family:monospace;">{sc:+.2f}</td>'

        # Score bar
        bar_pct = min(abs(sc) / max_abs * 100, 100)
        bar_color = "#e74c3c" if sc < 0 else "#2ecc71"
        bar_dir = "right" if sc < 0 else "left"
        html_pred += f'<td class="cell-compact" style="min-width:80px;">'
        html_pred += f'<div style="width:100%; background:#222; border-radius:3px; height:12px; position:relative;">'
        html_pred += f'<div style="width:{bar_pct:.0f}%; background:{bar_color}; height:100%; border-radius:3px; '
        html_pred += f'float:{bar_dir};"></div></div></td>'

        # Components breakdown
        html_pred += f'<td class="cell-compact">'
        chips = []
        for comp_key, (emoji, cneg, cpos) in comp_meta.items():
            val = comps.get(comp_key, 0.0)
            if abs(val) < 0.01:
                continue
            ccolor = cneg if val < 0 else cpos
            chips.append(
                f'<span style="background:{ccolor}22; color:{ccolor}; border:1px solid {ccolor}44; '
                f'border-radius:3px; padding:0px 4px; font-size:0.78em; white-space:nowrap;">'
                f'{emoji} {val:+.2f}</span>'
            )
        html_pred += " ".join(chips) if chips else '<span style="color:#555;">‚Äî</span>'
        html_pred += '</td>'

        # Reciprocity: target ‚Üí L√≠der score
        recip_entry = relations_pairs_daily.get(tname, {}).get(lider_name, {})
        recip_score = recip_entry.get("score", 0) if recip_entry else 0

        if sc < 0 and recip_score < 0:
            recip_label = "‚öîÔ∏è M√∫tua"
            recip_color = "#e74c3c"
        elif sc < 0 and recip_score >= 0:
            recip_label = "üîç Alvo cego"
            recip_color = "#e67e22"
        elif sc >= 0 and recip_score < 0:
            recip_label = "‚ö†Ô∏è Risco oculto"
            recip_color = "#e67e22"
        else:
            recip_label = "üíö Aliados"
            recip_color = "#2ecc71"

        html_pred += f'<td class="cell-compact" style="white-space:nowrap;">'
        html_pred += f'<span class="table-md" style="color:{recip_color};">{recip_label}</span> '
        html_pred += f'<span class="text-muted table-sm">({recip_score:+.2f})</span></td>'

        # Streak
        streak_icon = "üî¥" if has_break else ("üü¢" if streak_len >= 5 else "‚ö™")
        break_tag = ' <span style="color:#e74c3c; font-size:0.75em;">BREAK</span>' if has_break else ""
        html_pred += f'<td class="cell-compact tc" style="white-space:nowrap;">'
        html_pred += f'{streak_icon} {streak_len}d{break_tag}</td>'

        # VIP badge
        is_vip = tname in vip_list
        if is_vip:
            html_pred += '<td class="cell-compact tc">'
            html_pred += '<span style="background:#3498db33; color:#3498db; border:1px solid #3498db55; '
            html_pred += 'border-radius:3px; padding:1px 5px; font-size:0.78em;">VIP</span></td>'
        else:
            html_pred += '<td class="cell-compact tc" style="color:#555;">‚Äî</td>'

        html_pred += '</tr>'

        # ‚îÄ‚îÄ Expandable detail row: edges + querid√¥metro history ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        pair_edges = [e for e in _all_edges if
            (e.get("actor") == lider_name and e.get("target") == tname) or
            (e.get("actor") == tname and e.get("target") == lider_name)]
        pair_edges.sort(key=lambda e: e.get("date", ""))

        hist_fwd = _querido_history.get((lider_name, tname), [])
        hist_rev = _querido_history.get((tname, lider_name), [])

        if pair_edges or hist_fwd:
            html_pred += f'<tr style="{row_bg}"><td colspan="8" style="padding:0;">'
            html_pred += '<details style="margin:0 0.4rem 0.4rem 1.8rem;">'
            html_pred += '<summary class="text-muted table-sm" style="cursor:pointer; '
            html_pred += f'padding:0.2rem 0;">üìã {len(pair_edges)} evento(s) ¬∑ '
            html_pred += f'{len(hist_fwd)} dia(s) de querid√¥metro</summary>'
            html_pred += '<div style="display:flex; gap:1rem; flex-wrap:wrap; margin-top:0.4rem;">'

            # ‚îÄ‚îÄ Edges sub-table ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if pair_edges:
                html_pred += '<div style="flex:1; min-width:280px;">'
                html_pred += '<div style="color:#aaa; font-size:0.78em; margin-bottom:0.3rem;"><strong>Eventos & Edges</strong></div>'
                html_pred += '<table class="table-full table-sm">'
                html_pred += '<thead><tr class="sep-bottom">'
                html_pred += '<th class="tl text-dim" style="padding:2px 4px;">Data</th>'
                html_pred += '<th class="tl text-dim" style="padding:2px 4px;">Tipo</th>'
                html_pred += '<th class="tl text-dim" style="padding:2px 4px;">Dire√ß√£o</th>'
                html_pred += '<th class="tr text-dim" style="padding:2px 4px;">Peso</th>'
                html_pred += '<th class="tl text-dim" style="padding:2px 4px;">Detalhe</th>'
                html_pred += '</tr></thead><tbody>'
                for edge in pair_edges:
                    e_type = edge.get("type", "?")
                    e_actor = edge.get("actor", "")
                    e_target_name = edge.get("target", "")
                    e_weight = edge.get("weight", 0)
                    e_date = edge.get("date", "?")
                    e_emoji, e_label = _edge_display.get(e_type, ("‚ùì", e_type))
                    e_wcolor = "#e74c3c" if e_weight < 0 else "#2ecc71"
                    is_backlash = edge.get("backlash", False)

                    # Direction arrow
                    if e_actor == lider_name:
                        arrow = f'{lider_name.split()[0]} ‚Üí {tname.split()[0]}'
                    else:
                        arrow = f'{tname.split()[0]} ‚Üí {lider_name.split()[0]}'

                    # Detail info
                    detail_parts = []
                    if edge.get("event_type"):
                        detail_parts.append(edge["event_type"])
                    if edge.get("vote_kind"):
                        detail_parts.append(edge["vote_kind"])
                    if is_backlash:
                        detail_parts.append('<span style="color:#e67e22;">backlash</span>')
                    detail_str = " ¬∑ ".join(detail_parts) if detail_parts else "‚Äî"

                    html_pred += f'<tr style="border-bottom:1px solid #222;">'
                    html_pred += f'<td class="text-muted" style="padding:2px 4px; white-space:nowrap;">{e_date}</td>'
                    html_pred += f'<td style="padding:2px 4px; white-space:nowrap;">{e_emoji} {e_label}</td>'
                    html_pred += f'<td style="padding:2px 4px; color:#aaa; font-size:0.9em;">{arrow}</td>'
                    html_pred += f'<td class="tr" style="padding:2px 4px; color:{e_wcolor}; font-family:monospace;">{e_weight:+.2f}</td>'
                    html_pred += f'<td class="text-muted" style="padding:2px 4px;">{detail_str}</td>'
                    html_pred += '</tr>'
                html_pred += '</tbody></table></div>'

            # ‚îÄ‚îÄ Querid√¥metro timeline ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if hist_fwd:
                # Build date-aligned history
                all_dates = sorted(set(d for d, _ in hist_fwd) | set(d for d, _ in hist_rev))
                fwd_by_date = {d: lbl for d, lbl in hist_fwd}
                rev_by_date = {d: lbl for d, lbl in hist_rev}
                # Show last 14 days max
                show_dates = all_dates[-14:]

                html_pred += '<div style="flex:1; min-width:240px;">'
                html_pred += '<div style="color:#aaa; font-size:0.78em; margin-bottom:0.3rem;">'
                html_pred += f'<strong>Querid√¥metro</strong> (√∫ltimos {len(show_dates)} dias)</div>'
                html_pred += '<table class="table-full table-sm">'
                html_pred += '<thead><tr class="sep-bottom">'
                html_pred += f'<th class="tl text-dim" style="padding:2px 4px;">Data</th>'
                html_pred += f'<th class="tc text-dim" style="padding:2px 4px;">{lider_name.split()[0]}‚Üí</th>'
                html_pred += f'<th class="tc text-dim" style="padding:2px 4px;">‚Üí{lider_name.split()[0]}</th>'
                html_pred += '</tr></thead><tbody>'
                for dt in show_dates:
                    fwd_lbl = fwd_by_date.get(dt, "")
                    rev_lbl = rev_by_date.get(dt, "")
                    fwd_e = _emoji_map.get(fwd_lbl, "")
                    rev_e = _emoji_map.get(rev_lbl, "")
                    # Color based on sentiment
                    fwd_sent = SENTIMENT_WEIGHTS.get(fwd_lbl, 0)
                    rev_sent = SENTIMENT_WEIGHTS.get(rev_lbl, 0)
                    fwd_c = "#2ecc71" if fwd_sent > 0 else "#e74c3c" if fwd_sent < -0.5 else "#e67e22" if fwd_sent < 0 else "#555"
                    rev_c = "#2ecc71" if rev_sent > 0 else "#e74c3c" if rev_sent < -0.5 else "#e67e22" if rev_sent < 0 else "#555"
                    html_pred += f'<tr style="border-bottom:1px solid #222;">'
                    html_pred += f'<td class="text-muted" style="padding:1px 4px; font-size:0.9em;">{dt[5:]}</td>'
                    html_pred += f'<td class="tc" style="padding:1px 4px; color:{fwd_c};">{fwd_e}</td>'
                    html_pred += f'<td class="tc" style="padding:1px 4px; color:{rev_c};">{rev_e}</td>'
                    html_pred += '</tr>'
                html_pred += '</tbody></table></div>'

            html_pred += '</div></details></td></tr>'

    html_pred += '</tbody></table></div>'

    # ‚îÄ‚îÄ Methodology note ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    html_pred += '<div class="text-muted" style="background:#111; border:1px solid #333; border-radius:8px; '
    html_pred += 'padding:0.8rem 1rem; margin:1rem 0; font-size:0.82em;">'
    html_pred += '<strong style="color:#aaa;">üìê Metodologia</strong><br>'
    html_pred += 'A previs√£o √© baseada no <strong>score acumulado do L√≠der ‚Üí cada participante</strong>, '
    html_pred += 'calculado pelo sistema de Sentiment Index (querid√¥metro com mem√≥ria de streak + '
    html_pred += 'eventos de poder, Sincer√£o, votos e VIP). O participante com o score mais negativo '
    html_pred += '√© o alvo mais prov√°vel de indica√ß√£o. '
    html_pred += 'Membros do VIP foram escolhidos pelo L√≠der, indicando alian√ßa ‚Äî s√£o alvos improv√°veis. '
    html_pred += '<strong>Isto n√£o √© um modelo preditivo dedicado</strong> ‚Äî √© uma leitura dos dados '
    html_pred += 'de relacionamento acumulados at√© o momento.'
    html_pred += '</div>'

print(html_pred)
```
